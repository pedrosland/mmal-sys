/* automatically generated by rust-bindgen */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage, Align> {
    storage: Storage,
    align: [Align; 0],
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align> {
    #[inline]
    pub fn new(storage: Storage) -> Self {
        Self { storage, align: [] }
    }
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const MMAL_FALSE: u32 = 0;
pub const MMAL_TRUE: u32 = 1;
pub const MMAL_ENCODING_VARIANT_H264_DEFAULT: u32 = 0;
pub const MMAL_ENCODING_VARIANT_MP4A_DEFAULT: u32 = 0;
pub const MMAL_COLOR_SPACE_UNKNOWN: u32 = 0;
pub const MMAL_ES_FORMAT_FLAG_FRAMED: u32 = 1;
pub const MMAL_ENCODING_UNKNOWN: u32 = 0;
pub const MMAL_ENCODING_VARIANT_DEFAULT: u32 = 0;
pub const MMAL_ES_FORMAT_COMPARE_FLAG_TYPE: u32 = 1;
pub const MMAL_ES_FORMAT_COMPARE_FLAG_ENCODING: u32 = 2;
pub const MMAL_ES_FORMAT_COMPARE_FLAG_BITRATE: u32 = 4;
pub const MMAL_ES_FORMAT_COMPARE_FLAG_FLAGS: u32 = 8;
pub const MMAL_ES_FORMAT_COMPARE_FLAG_EXTRADATA: u32 = 16;
pub const MMAL_ES_FORMAT_COMPARE_FLAG_VIDEO_RESOLUTION: u32 = 256;
pub const MMAL_ES_FORMAT_COMPARE_FLAG_VIDEO_CROPPING: u32 = 512;
pub const MMAL_ES_FORMAT_COMPARE_FLAG_VIDEO_FRAME_RATE: u32 = 1024;
pub const MMAL_ES_FORMAT_COMPARE_FLAG_VIDEO_ASPECT_RATIO: u32 = 2048;
pub const MMAL_ES_FORMAT_COMPARE_FLAG_VIDEO_COLOR_SPACE: u32 = 4096;
pub const MMAL_ES_FORMAT_COMPARE_FLAG_ES_OTHER: u32 = 268435456;
pub const MMAL_BUFFER_HEADER_FLAG_EOS: u32 = 1;
pub const MMAL_BUFFER_HEADER_FLAG_FRAME_START: u32 = 2;
pub const MMAL_BUFFER_HEADER_FLAG_FRAME_END: u32 = 4;
pub const MMAL_BUFFER_HEADER_FLAG_FRAME: u32 = 6;
pub const MMAL_BUFFER_HEADER_FLAG_KEYFRAME: u32 = 8;
pub const MMAL_BUFFER_HEADER_FLAG_DISCONTINUITY: u32 = 16;
pub const MMAL_BUFFER_HEADER_FLAG_CONFIG: u32 = 32;
pub const MMAL_BUFFER_HEADER_FLAG_ENCRYPTED: u32 = 64;
pub const MMAL_BUFFER_HEADER_FLAG_CODECSIDEINFO: u32 = 128;
pub const MMAL_BUFFER_HEADER_FLAGS_SNAPSHOT: u32 = 256;
pub const MMAL_BUFFER_HEADER_FLAG_CORRUPTED: u32 = 512;
pub const MMAL_BUFFER_HEADER_FLAG_TRANSMISSION_FAILED: u32 = 1024;
pub const MMAL_BUFFER_HEADER_FLAG_DECODEONLY: u32 = 2048;
pub const MMAL_BUFFER_HEADER_FLAG_NAL_END: u32 = 4096;
pub const MMAL_BUFFER_HEADER_FLAG_USER0: u32 = 268435456;
pub const MMAL_BUFFER_HEADER_FLAG_USER1: u32 = 536870912;
pub const MMAL_BUFFER_HEADER_FLAG_USER2: u32 = 1073741824;
pub const MMAL_BUFFER_HEADER_FLAG_USER3: u32 = 2147483648;
pub const MMAL_BUFFER_HEADER_FLAG_FORMAT_SPECIFIC_START_BIT: u32 = 16;
pub const MMAL_BUFFER_HEADER_FLAG_FORMAT_SPECIFIC_START: u32 = 65536;
pub const MMAL_BUFFER_HEADER_VIDEO_FLAG_INTERLACED: u32 = 65536;
pub const MMAL_BUFFER_HEADER_VIDEO_FLAG_TOP_FIELD_FIRST: u32 = 131072;
pub const MMAL_BUFFER_HEADER_VIDEO_FLAG_DISPLAY_EXTERNAL: u32 = 524288;
pub const MMAL_BUFFER_HEADER_VIDEO_FLAG_PROTECTED: u32 = 1048576;
pub const MMAL_BUFFER_HEADER_VIDEO_FLAG_COLUMN_LOG2_SHIFT: u32 = 24;
pub const MMAL_BUFFER_HEADER_VIDEO_FLAG_COLUMN_LOG2_MASK: u32 = 251658240;
pub const MMAL_PARAMETER_GROUP_COMMON: u32 = 0;
pub const MMAL_PARAMETER_GROUP_CAMERA: u32 = 65536;
pub const MMAL_PARAMETER_GROUP_VIDEO: u32 = 131072;
pub const MMAL_PARAMETER_GROUP_AUDIO: u32 = 196608;
pub const MMAL_PARAMETER_GROUP_CLOCK: u32 = 262144;
pub const MMAL_PARAMETER_GROUP_MIRACAST: u32 = 327680;
pub const MMAL_PARAM_SEEK_FLAG_PRECISE: u32 = 1;
pub const MMAL_PARAM_SEEK_FLAG_FORWARD: u32 = 2;
pub const MMAL_MAX_IMAGEFX_PARAMETERS: u32 = 6;
pub const MMAL_PARAMETER_CAMERA_INFO_MAX_CAMERAS: u32 = 4;
pub const MMAL_PARAMETER_CAMERA_INFO_MAX_FLASHES: u32 = 2;
pub const MMAL_PARAMETER_CAMERA_INFO_MAX_STR_LEN: u32 = 16;
pub const MMAL_CAMERA_ANNOTATE_MAX_TEXT_LEN: u32 = 32;
pub const MMAL_CAMERA_ANNOTATE_MAX_TEXT_LEN_V2: u32 = 256;
pub const MMAL_CAMERA_ANNOTATE_MAX_TEXT_LEN_V3: u32 = 256;
pub const MMAL_CAMERA_ANNOTATE_MAX_TEXT_LEN_V4: u32 = 256;
pub const MMAL_CLOCK_EVENT_INVALID: u32 = 0;
pub const MMAL_FIXED_16_16_ONE: u32 = 65536;
pub const MMAL_PORT_CAPABILITY_PASSTHROUGH: u32 = 1;
pub const MMAL_PORT_CAPABILITY_ALLOCATION: u32 = 2;
pub const MMAL_PORT_CAPABILITY_SUPPORTS_EVENT_FORMAT_CHANGE: u32 = 4;
pub const MMAL_VERSION_MAJOR: u32 = 0;
pub const MMAL_VERSION_MINOR: u32 = 1;
pub const MMAL_VERSION: u32 = 1;
pub const MMAL_COMPONENT_DEFAULT_CONTAINER_READER: &'static [u8; 17usize] = b"container_reader\0";
pub const MMAL_COMPONENT_DEFAULT_CONTAINER_WRITER: &'static [u8; 17usize] = b"container_writer\0";
pub const MMAL_COMPONENT_DEFAULT_VIDEO_DECODER: &'static [u8; 20usize] = b"vc.ril.video_decode\0";
pub const MMAL_COMPONENT_DEFAULT_VIDEO_ENCODER: &'static [u8; 20usize] = b"vc.ril.video_encode\0";
pub const MMAL_COMPONENT_DEFAULT_VIDEO_RENDERER: &'static [u8; 20usize] = b"vc.ril.video_render\0";
pub const MMAL_COMPONENT_DEFAULT_IMAGE_DECODER: &'static [u8; 20usize] = b"vc.ril.image_decode\0";
pub const MMAL_COMPONENT_DEFAULT_IMAGE_ENCODER: &'static [u8; 20usize] = b"vc.ril.image_encode\0";
pub const MMAL_COMPONENT_DEFAULT_CAMERA: &'static [u8; 14usize] = b"vc.ril.camera\0";
pub const MMAL_COMPONENT_DEFAULT_VIDEO_CONVERTER: &'static [u8; 17usize] = b"vc.video_convert\0";
pub const MMAL_COMPONENT_DEFAULT_SPLITTER: &'static [u8; 12usize] = b"vc.splitter\0";
pub const MMAL_COMPONENT_DEFAULT_SCHEDULER: &'static [u8; 13usize] = b"vc.scheduler\0";
pub const MMAL_COMPONENT_DEFAULT_VIDEO_INJECTER: &'static [u8; 16usize] = b"vc.video_inject\0";
pub const MMAL_COMPONENT_DEFAULT_VIDEO_SPLITTER: &'static [u8; 22usize] =
    b"vc.ril.video_splitter\0";
pub const MMAL_COMPONENT_DEFAULT_AUDIO_DECODER: &'static [u8; 5usize] = b"none\0";
pub const MMAL_COMPONENT_DEFAULT_AUDIO_RENDERER: &'static [u8; 20usize] = b"vc.ril.audio_render\0";
pub const MMAL_COMPONENT_DEFAULT_MIRACAST: &'static [u8; 12usize] = b"vc.miracast\0";
pub const MMAL_COMPONENT_DEFAULT_CLOCK: &'static [u8; 9usize] = b"vc.clock\0";
pub const MMAL_COMPONENT_DEFAULT_CAMERA_INFO: &'static [u8; 15usize] = b"vc.camera_info\0";
pub const MMAL_CONNECTION_FLAG_TUNNELLING: u32 = 1;
pub const MMAL_CONNECTION_FLAG_ALLOCATION_ON_INPUT: u32 = 2;
pub const MMAL_CONNECTION_FLAG_ALLOCATION_ON_OUTPUT: u32 = 4;
pub const MMAL_CONNECTION_FLAG_KEEP_BUFFER_REQUIREMENTS: u32 = 8;
pub const MMAL_CONNECTION_FLAG_DIRECT: u32 = 16;
pub const MMAL_CONNECTION_FLAG_KEEP_PORT_FORMATS: u32 = 32;
pub const MMAL_DEV_VCHIQ_PATH: &'static [u8; 11usize] = b"/dev/vchiq\0";
pub type __time_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        8usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        4usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_nsec as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_slist {
    pub __next: *mut __pthread_internal_slist,
}
#[test]
fn bindgen_test_layout___pthread_internal_slist() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_slist>(),
        4usize,
        concat!("Size of: ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_slist>(),
        4usize,
        concat!("Alignment of ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_internal_slist>())).__next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_slist),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_slist_t = __pthread_internal_slist;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: pthread_mutex_t___pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 24usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u32; 6usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pthread_mutex_t___pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __kind: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __bindgen_anon_1: pthread_mutex_t___pthread_mutex_s__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t___pthread_mutex_s__bindgen_ty_1 {
    pub __spins: ::std::os::raw::c_int,
    pub __list: __pthread_slist_t,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_pthread_mutex_t___pthread_mutex_s__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<pthread_mutex_t___pthread_mutex_s__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(pthread_mutex_t___pthread_mutex_s__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutex_t___pthread_mutex_s__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(pthread_mutex_t___pthread_mutex_s__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pthread_mutex_t___pthread_mutex_s__bindgen_ty_1>())).__spins
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t___pthread_mutex_s__bindgen_ty_1),
            "::",
            stringify!(__spins)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pthread_mutex_t___pthread_mutex_s__bindgen_ty_1>())).__list
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t___pthread_mutex_s__bindgen_ty_1),
            "::",
            stringify!(__list)
        )
    );
}
impl ::std::fmt::Debug for pthread_mutex_t___pthread_mutex_s__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "pthread_mutex_t___pthread_mutex_s__bindgen_ty_1 {{ union }}"
        )
    }
}
#[test]
fn bindgen_test_layout_pthread_mutex_t___pthread_mutex_s() {
    assert_eq!(
        ::std::mem::size_of::<pthread_mutex_t___pthread_mutex_s>(),
        24usize,
        concat!("Size of: ", stringify!(pthread_mutex_t___pthread_mutex_s))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutex_t___pthread_mutex_s>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(pthread_mutex_t___pthread_mutex_s)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pthread_mutex_t___pthread_mutex_s>())).__lock as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t___pthread_mutex_s),
            "::",
            stringify!(__lock)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pthread_mutex_t___pthread_mutex_s>())).__count as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t___pthread_mutex_s),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pthread_mutex_t___pthread_mutex_s>())).__owner as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t___pthread_mutex_s),
            "::",
            stringify!(__owner)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pthread_mutex_t___pthread_mutex_s>())).__kind as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t___pthread_mutex_s),
            "::",
            stringify!(__kind)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pthread_mutex_t___pthread_mutex_s>())).__nusers as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t___pthread_mutex_s),
            "::",
            stringify!(__nusers)
        )
    );
}
impl ::std::fmt::Debug for pthread_mutex_t___pthread_mutex_s {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! ( f , "pthread_mutex_t___pthread_mutex_s {{ __lock: {:?}, __count: {:?}, __owner: {:?}, __kind: {:?}, __nusers: {:?}, __bindgen_anon_1: {:?} }}" , self . __lock , self . __count , self . __owner , self . __kind , self . __nusers , self . __bindgen_anon_1 )
    }
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_mutex_t>(),
        24usize,
        concat!("Size of: ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutex_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__align)
        )
    );
}
impl ::std::fmt::Debug for pthread_mutex_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "pthread_mutex_t {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: pthread_cond_t__bindgen_ty_1,
    pub __size: [::std::os::raw::c_char; 48usize],
    pub __align: ::std::os::raw::c_longlong,
    _bindgen_union_align: [u64; 6usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_cond_t__bindgen_ty_1 {
    pub __lock: ::std::os::raw::c_int,
    pub __futex: ::std::os::raw::c_uint,
    pub __total_seq: ::std::os::raw::c_ulonglong,
    pub __wakeup_seq: ::std::os::raw::c_ulonglong,
    pub __woken_seq: ::std::os::raw::c_ulonglong,
    pub __mutex: *mut ::std::os::raw::c_void,
    pub __nwaiters: ::std::os::raw::c_uint,
    pub __broadcast_seq: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_pthread_cond_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<pthread_cond_t__bindgen_ty_1>(),
        48usize,
        concat!("Size of: ", stringify!(pthread_cond_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_cond_t__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_cond_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pthread_cond_t__bindgen_ty_1>())).__lock as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t__bindgen_ty_1),
            "::",
            stringify!(__lock)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pthread_cond_t__bindgen_ty_1>())).__futex as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t__bindgen_ty_1),
            "::",
            stringify!(__futex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pthread_cond_t__bindgen_ty_1>())).__total_seq as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t__bindgen_ty_1),
            "::",
            stringify!(__total_seq)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pthread_cond_t__bindgen_ty_1>())).__wakeup_seq as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t__bindgen_ty_1),
            "::",
            stringify!(__wakeup_seq)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pthread_cond_t__bindgen_ty_1>())).__woken_seq as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t__bindgen_ty_1),
            "::",
            stringify!(__woken_seq)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pthread_cond_t__bindgen_ty_1>())).__mutex as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t__bindgen_ty_1),
            "::",
            stringify!(__mutex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pthread_cond_t__bindgen_ty_1>())).__nwaiters as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t__bindgen_ty_1),
            "::",
            stringify!(__nwaiters)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pthread_cond_t__bindgen_ty_1>())).__broadcast_seq as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t__bindgen_ty_1),
            "::",
            stringify!(__broadcast_seq)
        )
    );
}
#[test]
fn bindgen_test_layout_pthread_cond_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__align)
        )
    );
}
impl ::std::fmt::Debug for pthread_cond_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "pthread_cond_t {{ union }}")
    }
}
pub type pthread_once_t = ::std::os::raw::c_int;
extern "C" {
    pub fn vcos_pthreads_logging_assert(
        file: *const ::std::os::raw::c_char,
        func: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_uint,
        fmt: *const ::std::os::raw::c_char,
        ...
    );
}
#[doc = " Thread entry point. Returns a void* for consistency"]
#[doc = " with pthreads."]
pub type VCOS_THREAD_ENTRY_FN_T = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
>;
pub const VCOS_STATUS_T_VCOS_SUCCESS: VCOS_STATUS_T = 0;
pub const VCOS_STATUS_T_VCOS_EAGAIN: VCOS_STATUS_T = 1;
pub const VCOS_STATUS_T_VCOS_ENOENT: VCOS_STATUS_T = 2;
pub const VCOS_STATUS_T_VCOS_ENOSPC: VCOS_STATUS_T = 3;
pub const VCOS_STATUS_T_VCOS_EINVAL: VCOS_STATUS_T = 4;
pub const VCOS_STATUS_T_VCOS_EACCESS: VCOS_STATUS_T = 5;
pub const VCOS_STATUS_T_VCOS_ENOMEM: VCOS_STATUS_T = 6;
pub const VCOS_STATUS_T_VCOS_ENOSYS: VCOS_STATUS_T = 7;
pub const VCOS_STATUS_T_VCOS_EEXIST: VCOS_STATUS_T = 8;
pub const VCOS_STATUS_T_VCOS_ENXIO: VCOS_STATUS_T = 9;
pub const VCOS_STATUS_T_VCOS_EINTR: VCOS_STATUS_T = 10;
pub type VCOS_STATUS_T = u32;
extern "C" {
    pub fn vcos_verify_bkpts_enabled() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vcos_verify_bkpts_enable(enable: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vcos_abort();
}
extern "C" {
    #[doc = " Print out a backtrace, on supported platforms."]
    pub fn vcos_backtrace_self();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sem_t {
    pub __size: [::std::os::raw::c_char; 16usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u32; 4usize],
}
#[test]
fn bindgen_test_layout_sem_t() {
    assert_eq!(
        ::std::mem::size_of::<sem_t>(),
        16usize,
        concat!("Size of: ", stringify!(sem_t))
    );
    assert_eq!(
        ::std::mem::align_of::<sem_t>(),
        4usize,
        concat!("Alignment of ", stringify!(sem_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sem_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sem_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sem_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sem_t),
            "::",
            stringify!(__align)
        )
    );
}
impl ::std::fmt::Debug for sem_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "sem_t {{ union }}")
    }
}
pub type VCOS_SEMAPHORE_T = sem_t;
pub type VCOS_UNSIGNED = u32;
pub type VCOS_OPTION = u32;
pub type VCOS_ONCE_T = pthread_once_t;
pub type VCOS_MUTEX_T = pthread_mutex_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct VCOS_TIMER_T {
    #[doc = "< id of the timer thread"]
    pub thread: pthread_t,
    #[doc = "< lock protecting all other members of the struct"]
    pub lock: pthread_mutex_t,
    #[doc = "< cond. var. for informing the timer thread about changes"]
    pub settings_changed: pthread_cond_t,
    #[doc = "< non-zero if the timer thread is requested to quit"]
    pub quit: ::std::os::raw::c_int,
    #[doc = "< absolute time of next expiration, or 0 if disarmed"]
    pub expires: timespec,
    #[doc = "< the expiration routine provided by the user of the timer"]
    pub orig_expiration_routine:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    #[doc = "< the context for exp. routine provided by the user"]
    pub orig_context: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_VCOS_TIMER_T() {
    assert_eq!(
        ::std::mem::size_of::<VCOS_TIMER_T>(),
        104usize,
        concat!("Size of: ", stringify!(VCOS_TIMER_T))
    );
    assert_eq!(
        ::std::mem::align_of::<VCOS_TIMER_T>(),
        8usize,
        concat!("Alignment of ", stringify!(VCOS_TIMER_T))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_TIMER_T>())).thread as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_TIMER_T),
            "::",
            stringify!(thread)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_TIMER_T>())).lock as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_TIMER_T),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_TIMER_T>())).settings_changed as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_TIMER_T),
            "::",
            stringify!(settings_changed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_TIMER_T>())).quit as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_TIMER_T),
            "::",
            stringify!(quit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_TIMER_T>())).expires as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_TIMER_T),
            "::",
            stringify!(expires)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VCOS_TIMER_T>())).orig_expiration_routine as *const _ as usize
        },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_TIMER_T),
            "::",
            stringify!(orig_expiration_routine)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_TIMER_T>())).orig_context as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_TIMER_T),
            "::",
            stringify!(orig_context)
        )
    );
}
impl ::std::fmt::Debug for VCOS_TIMER_T {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! ( f , "VCOS_TIMER_T {{ thread: {:?}, lock: {:?}, settings_changed: {:?}, quit: {:?}, expires: {:?}, orig_expiration_routine: {:?}, orig_context: {:?} }}" , self . thread , self . lock , self . settings_changed , self . quit , self . expires , self . orig_expiration_routine , self . orig_context )
    }
}
#[doc = " Thread attribute structure. Don't use pthread_attr directly, as"]
#[doc = " the calls can fail, and inits must match deletes."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VCOS_THREAD_ATTR_T {
    pub ta_stackaddr: *mut ::std::os::raw::c_void,
    pub ta_stacksz: VCOS_UNSIGNED,
    pub ta_priority: VCOS_UNSIGNED,
    pub ta_affinity: VCOS_UNSIGNED,
    pub ta_timeslice: VCOS_UNSIGNED,
    pub legacy: VCOS_UNSIGNED,
}
#[test]
fn bindgen_test_layout_VCOS_THREAD_ATTR_T() {
    assert_eq!(
        ::std::mem::size_of::<VCOS_THREAD_ATTR_T>(),
        24usize,
        concat!("Size of: ", stringify!(VCOS_THREAD_ATTR_T))
    );
    assert_eq!(
        ::std::mem::align_of::<VCOS_THREAD_ATTR_T>(),
        4usize,
        concat!("Alignment of ", stringify!(VCOS_THREAD_ATTR_T))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_THREAD_ATTR_T>())).ta_stackaddr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_THREAD_ATTR_T),
            "::",
            stringify!(ta_stackaddr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_THREAD_ATTR_T>())).ta_stacksz as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_THREAD_ATTR_T),
            "::",
            stringify!(ta_stacksz)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_THREAD_ATTR_T>())).ta_priority as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_THREAD_ATTR_T),
            "::",
            stringify!(ta_priority)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_THREAD_ATTR_T>())).ta_affinity as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_THREAD_ATTR_T),
            "::",
            stringify!(ta_affinity)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_THREAD_ATTR_T>())).ta_timeslice as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_THREAD_ATTR_T),
            "::",
            stringify!(ta_timeslice)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_THREAD_ATTR_T>())).legacy as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_THREAD_ATTR_T),
            "::",
            stringify!(legacy)
        )
    );
}
#[doc = " Called at thread exit."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VCOS_THREAD_EXIT_T {
    pub pfn: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub cxt: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_VCOS_THREAD_EXIT_T() {
    assert_eq!(
        ::std::mem::size_of::<VCOS_THREAD_EXIT_T>(),
        8usize,
        concat!("Size of: ", stringify!(VCOS_THREAD_EXIT_T))
    );
    assert_eq!(
        ::std::mem::align_of::<VCOS_THREAD_EXIT_T>(),
        4usize,
        concat!("Alignment of ", stringify!(VCOS_THREAD_EXIT_T))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_THREAD_EXIT_T>())).pfn as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_THREAD_EXIT_T),
            "::",
            stringify!(pfn)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_THREAD_EXIT_T>())).cxt as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_THREAD_EXIT_T),
            "::",
            stringify!(cxt)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct VCOS_THREAD_T {
    #[doc = "< The thread itself"]
    pub thread: pthread_t,
    #[doc = "< The thread entry point"]
    pub entry: VCOS_THREAD_ENTRY_FN_T,
    #[doc = "< The argument to be passed to entry"]
    pub arg: *mut ::std::os::raw::c_void,
    #[doc = "< For support event groups and similar - a per thread semaphore"]
    pub suspend: VCOS_SEMAPHORE_T,
    pub task_timer: VCOS_TIMER_T,
    #[doc = "< non-zero if the task timer has already been created"]
    pub task_timer_created: ::std::os::raw::c_int,
    pub orig_task_timer_expiration_routine:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub orig_task_timer_context: *mut ::std::os::raw::c_void,
    pub legacy: VCOS_UNSIGNED,
    #[doc = "< Record the name of this thread, for diagnostics"]
    pub name: [::std::os::raw::c_char; 16usize],
    #[doc = "< Dummy thread created for non-vcos created threads"]
    pub dummy: VCOS_UNSIGNED,
    #[doc = " Callback invoked at thread exit time"]
    pub at_exit: [VCOS_THREAD_EXIT_T; 4usize],
}
#[test]
fn bindgen_test_layout_VCOS_THREAD_T() {
    assert_eq!(
        ::std::mem::size_of::<VCOS_THREAD_T>(),
        208usize,
        concat!("Size of: ", stringify!(VCOS_THREAD_T))
    );
    assert_eq!(
        ::std::mem::align_of::<VCOS_THREAD_T>(),
        8usize,
        concat!("Alignment of ", stringify!(VCOS_THREAD_T))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_THREAD_T>())).thread as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_THREAD_T),
            "::",
            stringify!(thread)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_THREAD_T>())).entry as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_THREAD_T),
            "::",
            stringify!(entry)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_THREAD_T>())).arg as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_THREAD_T),
            "::",
            stringify!(arg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_THREAD_T>())).suspend as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_THREAD_T),
            "::",
            stringify!(suspend)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_THREAD_T>())).task_timer as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_THREAD_T),
            "::",
            stringify!(task_timer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VCOS_THREAD_T>())).task_timer_created as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_THREAD_T),
            "::",
            stringify!(task_timer_created)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VCOS_THREAD_T>())).orig_task_timer_expiration_routine as *const _
                as usize
        },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_THREAD_T),
            "::",
            stringify!(orig_task_timer_expiration_routine)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VCOS_THREAD_T>())).orig_task_timer_context as *const _ as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_THREAD_T),
            "::",
            stringify!(orig_task_timer_context)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_THREAD_T>())).legacy as *const _ as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_THREAD_T),
            "::",
            stringify!(legacy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_THREAD_T>())).name as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_THREAD_T),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_THREAD_T>())).dummy as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_THREAD_T),
            "::",
            stringify!(dummy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_THREAD_T>())).at_exit as *const _ as usize },
        172usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_THREAD_T),
            "::",
            stringify!(at_exit)
        )
    );
}
impl ::std::fmt::Debug for VCOS_THREAD_T {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! ( f , "VCOS_THREAD_T {{ thread: {:?}, entry: {:?}, arg: {:?}, suspend: {:?}, task_timer: {:?}, task_timer_created: {:?}, orig_task_timer_expiration_routine: {:?}, orig_task_timer_context: {:?}, legacy: {:?}, name: {:?}, dummy: {:?}, at_exit: {:?} }}" , self . thread , self . entry , self . arg , self . suspend , self . task_timer , self . task_timer_created , self . orig_task_timer_expiration_routine , self . orig_task_timer_context , self . legacy , self . name , self . dummy , self . at_exit )
    }
}
#[doc = " \\file"]
#[doc = ""]
#[doc = " This provides event flags (as per Nucleus Event Groups) based on a"]
#[doc = " mutex, a semaphore (per waiting thread) and a timer (per waiting"]
#[doc = " thread)."]
#[doc = ""]
#[doc = " The data structure is a 32 bit unsigned int (the current set of"]
#[doc = " flags) and a linked list of clients waiting to be 'satisfied'."]
#[doc = ""]
#[doc = " The mutex merely locks access to the data structure. If a client"]
#[doc = " calls vcos_event_flags_get() and the requested bits are not already"]
#[doc = " present, it then sleeps on its per-thread semaphore after adding"]
#[doc = " this semaphore to the queue waiting. It also sets up a timer."]
#[doc = ""]
#[doc = " The per-thread semaphore and timer are actually stored in the"]
#[doc = " thread context (joinable thread). In future it may become necessary"]
#[doc = " to support non-VCOS threads by using thread local storage to"]
#[doc = " create these objects and associate them with the thread."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VCOS_EVENT_WAITER_T {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct VCOS_EVENT_FLAGS_T {
    #[doc = "< Events currently set"]
    pub events: VCOS_UNSIGNED,
    #[doc = "< Serialize access"]
    pub lock: VCOS_MUTEX_T,
    pub waiters: VCOS_EVENT_FLAGS_T__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VCOS_EVENT_FLAGS_T__bindgen_ty_1 {
    #[doc = "< List of threads waiting"]
    pub head: *mut VCOS_EVENT_WAITER_T,
    #[doc = "< List of threads waiting"]
    pub tail: *mut VCOS_EVENT_WAITER_T,
}
#[test]
fn bindgen_test_layout_VCOS_EVENT_FLAGS_T__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<VCOS_EVENT_FLAGS_T__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(VCOS_EVENT_FLAGS_T__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<VCOS_EVENT_FLAGS_T__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(VCOS_EVENT_FLAGS_T__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VCOS_EVENT_FLAGS_T__bindgen_ty_1>())).head as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_EVENT_FLAGS_T__bindgen_ty_1),
            "::",
            stringify!(head)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VCOS_EVENT_FLAGS_T__bindgen_ty_1>())).tail as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_EVENT_FLAGS_T__bindgen_ty_1),
            "::",
            stringify!(tail)
        )
    );
}
#[test]
fn bindgen_test_layout_VCOS_EVENT_FLAGS_T() {
    assert_eq!(
        ::std::mem::size_of::<VCOS_EVENT_FLAGS_T>(),
        36usize,
        concat!("Size of: ", stringify!(VCOS_EVENT_FLAGS_T))
    );
    assert_eq!(
        ::std::mem::align_of::<VCOS_EVENT_FLAGS_T>(),
        4usize,
        concat!("Alignment of ", stringify!(VCOS_EVENT_FLAGS_T))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_EVENT_FLAGS_T>())).events as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_EVENT_FLAGS_T),
            "::",
            stringify!(events)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_EVENT_FLAGS_T>())).lock as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_EVENT_FLAGS_T),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_EVENT_FLAGS_T>())).waiters as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_EVENT_FLAGS_T),
            "::",
            stringify!(waiters)
        )
    );
}
impl ::std::fmt::Debug for VCOS_EVENT_FLAGS_T {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "VCOS_EVENT_FLAGS_T {{ events: {:?}, lock: {:?}, waiters: {:?} }}",
            self.events, self.lock, self.waiters
        )
    }
}
extern "C" {
    pub fn vcos_generic_event_flags_create(
        flags: *mut VCOS_EVENT_FLAGS_T,
        name: *const ::std::os::raw::c_char,
    ) -> VCOS_STATUS_T;
}
extern "C" {
    pub fn vcos_generic_event_flags_set(
        flags: *mut VCOS_EVENT_FLAGS_T,
        events: VCOS_UNSIGNED,
        op: VCOS_OPTION,
    );
}
extern "C" {
    pub fn vcos_generic_event_flags_delete(arg1: *mut VCOS_EVENT_FLAGS_T);
}
extern "C" {
    pub fn vcos_generic_event_flags_get(
        flags: *mut VCOS_EVENT_FLAGS_T,
        requested_events: VCOS_UNSIGNED,
        op: VCOS_OPTION,
        suspend: VCOS_UNSIGNED,
        retrieved_events: *mut VCOS_UNSIGNED,
    ) -> VCOS_STATUS_T;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct VCOS_BLOCKPOOL_HEADER_TAG {
    pub owner: VCOS_BLOCKPOOL_HEADER_TAG__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union VCOS_BLOCKPOOL_HEADER_TAG__bindgen_ty_1 {
    pub next: *mut VCOS_BLOCKPOOL_HEADER_TAG,
    pub subpool: *mut VCOS_BLOCKPOOL_SUBPOOL_TAG,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_VCOS_BLOCKPOOL_HEADER_TAG__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<VCOS_BLOCKPOOL_HEADER_TAG__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(VCOS_BLOCKPOOL_HEADER_TAG__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VCOS_BLOCKPOOL_HEADER_TAG__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(VCOS_BLOCKPOOL_HEADER_TAG__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VCOS_BLOCKPOOL_HEADER_TAG__bindgen_ty_1>())).next as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_BLOCKPOOL_HEADER_TAG__bindgen_ty_1),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VCOS_BLOCKPOOL_HEADER_TAG__bindgen_ty_1>())).subpool as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_BLOCKPOOL_HEADER_TAG__bindgen_ty_1),
            "::",
            stringify!(subpool)
        )
    );
}
impl ::std::fmt::Debug for VCOS_BLOCKPOOL_HEADER_TAG__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "VCOS_BLOCKPOOL_HEADER_TAG__bindgen_ty_1 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout_VCOS_BLOCKPOOL_HEADER_TAG() {
    assert_eq!(
        ::std::mem::size_of::<VCOS_BLOCKPOOL_HEADER_TAG>(),
        4usize,
        concat!("Size of: ", stringify!(VCOS_BLOCKPOOL_HEADER_TAG))
    );
    assert_eq!(
        ::std::mem::align_of::<VCOS_BLOCKPOOL_HEADER_TAG>(),
        4usize,
        concat!("Alignment of ", stringify!(VCOS_BLOCKPOOL_HEADER_TAG))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_BLOCKPOOL_HEADER_TAG>())).owner as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_BLOCKPOOL_HEADER_TAG),
            "::",
            stringify!(owner)
        )
    );
}
impl ::std::fmt::Debug for VCOS_BLOCKPOOL_HEADER_TAG {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "VCOS_BLOCKPOOL_HEADER_TAG {{ owner: {:?} }}", self.owner)
    }
}
pub type VCOS_BLOCKPOOL_HEADER_T = VCOS_BLOCKPOOL_HEADER_TAG;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VCOS_BLOCKPOOL_SUBPOOL_TAG {
    #[doc = " VCOS_BLOCKPOOL_SUBPOOL_MAGIC"]
    pub magic: u32,
    pub free_list: *mut VCOS_BLOCKPOOL_HEADER_T,
    pub mem: *mut ::std::os::raw::c_void,
    pub start: *mut ::std::os::raw::c_void,
    pub end: *mut ::std::os::raw::c_void,
    #[doc = " The number of blocks in this sub-pool"]
    pub num_blocks: VCOS_UNSIGNED,
    #[doc = " Current number of available blocks in this sub-pool"]
    pub available_blocks: VCOS_UNSIGNED,
    #[doc = " Pointers to the pool that owns this sub-pool"]
    pub owner: *mut VCOS_BLOCKPOOL_TAG,
    #[doc = " Define properties such as memory ownership"]
    pub flags: u32,
}
#[test]
fn bindgen_test_layout_VCOS_BLOCKPOOL_SUBPOOL_TAG() {
    assert_eq!(
        ::std::mem::size_of::<VCOS_BLOCKPOOL_SUBPOOL_TAG>(),
        36usize,
        concat!("Size of: ", stringify!(VCOS_BLOCKPOOL_SUBPOOL_TAG))
    );
    assert_eq!(
        ::std::mem::align_of::<VCOS_BLOCKPOOL_SUBPOOL_TAG>(),
        4usize,
        concat!("Alignment of ", stringify!(VCOS_BLOCKPOOL_SUBPOOL_TAG))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VCOS_BLOCKPOOL_SUBPOOL_TAG>())).magic as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_BLOCKPOOL_SUBPOOL_TAG),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VCOS_BLOCKPOOL_SUBPOOL_TAG>())).free_list as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_BLOCKPOOL_SUBPOOL_TAG),
            "::",
            stringify!(free_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_BLOCKPOOL_SUBPOOL_TAG>())).mem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_BLOCKPOOL_SUBPOOL_TAG),
            "::",
            stringify!(mem)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VCOS_BLOCKPOOL_SUBPOOL_TAG>())).start as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_BLOCKPOOL_SUBPOOL_TAG),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_BLOCKPOOL_SUBPOOL_TAG>())).end as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_BLOCKPOOL_SUBPOOL_TAG),
            "::",
            stringify!(end)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VCOS_BLOCKPOOL_SUBPOOL_TAG>())).num_blocks as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_BLOCKPOOL_SUBPOOL_TAG),
            "::",
            stringify!(num_blocks)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VCOS_BLOCKPOOL_SUBPOOL_TAG>())).available_blocks as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_BLOCKPOOL_SUBPOOL_TAG),
            "::",
            stringify!(available_blocks)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VCOS_BLOCKPOOL_SUBPOOL_TAG>())).owner as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_BLOCKPOOL_SUBPOOL_TAG),
            "::",
            stringify!(owner)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VCOS_BLOCKPOOL_SUBPOOL_TAG>())).flags as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_BLOCKPOOL_SUBPOOL_TAG),
            "::",
            stringify!(flags)
        )
    );
}
pub type VCOS_BLOCKPOOL_SUBPOOL_T = VCOS_BLOCKPOOL_SUBPOOL_TAG;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct VCOS_BLOCKPOOL_TAG {
    #[doc = " VCOS_BLOCKPOOL_MAGIC"]
    pub magic: u32,
    #[doc = " Thread safety for Alloc, Free, Delete, Stats"]
    pub mutex: VCOS_MUTEX_T,
    #[doc = " Alignment of block data pointers"]
    pub align: VCOS_UNSIGNED,
    #[doc = " Flags for future use e.g. cache options"]
    pub flags: VCOS_UNSIGNED,
    #[doc = " The size of the block data"]
    pub block_data_size: usize,
    #[doc = " Block size inc overheads"]
    pub block_size: usize,
    #[doc = " Name for debugging"]
    pub name: *const ::std::os::raw::c_char,
    pub num_subpools: VCOS_UNSIGNED,
    #[doc = " Number of blocks in each dynamically allocated subpool"]
    pub num_extension_blocks: VCOS_UNSIGNED,
    #[doc = " Array of subpools. Subpool zero is is not deleted until the pool is"]
    #[doc = " destroed. If the index of the pool is < num_subpools and"]
    #[doc = " subpool[index.mem] is null then the subpool entry is valid but"]
    #[doc = " \"not currently allocated\""]
    pub subpools: [VCOS_BLOCKPOOL_SUBPOOL_T; 8usize],
}
#[test]
fn bindgen_test_layout_VCOS_BLOCKPOOL_TAG() {
    assert_eq!(
        ::std::mem::size_of::<VCOS_BLOCKPOOL_TAG>(),
        344usize,
        concat!("Size of: ", stringify!(VCOS_BLOCKPOOL_TAG))
    );
    assert_eq!(
        ::std::mem::align_of::<VCOS_BLOCKPOOL_TAG>(),
        4usize,
        concat!("Alignment of ", stringify!(VCOS_BLOCKPOOL_TAG))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_BLOCKPOOL_TAG>())).magic as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_BLOCKPOOL_TAG),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_BLOCKPOOL_TAG>())).mutex as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_BLOCKPOOL_TAG),
            "::",
            stringify!(mutex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_BLOCKPOOL_TAG>())).align as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_BLOCKPOOL_TAG),
            "::",
            stringify!(align)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_BLOCKPOOL_TAG>())).flags as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_BLOCKPOOL_TAG),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VCOS_BLOCKPOOL_TAG>())).block_data_size as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_BLOCKPOOL_TAG),
            "::",
            stringify!(block_data_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_BLOCKPOOL_TAG>())).block_size as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_BLOCKPOOL_TAG),
            "::",
            stringify!(block_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_BLOCKPOOL_TAG>())).name as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_BLOCKPOOL_TAG),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_BLOCKPOOL_TAG>())).num_subpools as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_BLOCKPOOL_TAG),
            "::",
            stringify!(num_subpools)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VCOS_BLOCKPOOL_TAG>())).num_extension_blocks as *const _ as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_BLOCKPOOL_TAG),
            "::",
            stringify!(num_extension_blocks)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_BLOCKPOOL_TAG>())).subpools as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_BLOCKPOOL_TAG),
            "::",
            stringify!(subpools)
        )
    );
}
impl ::std::fmt::Debug for VCOS_BLOCKPOOL_TAG {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! ( f , "VCOS_BLOCKPOOL_TAG {{ magic: {:?}, mutex: {:?}, align: {:?}, flags: {:?}, block_data_size: {:?}, block_size: {:?}, name: {:?}, num_subpools: {:?}, num_extension_blocks: {:?}, subpools: {:?} }}" , self . magic , self . mutex , self . align , self . flags , self . block_data_size , self . block_size , self . name , self . num_subpools , self . num_extension_blocks , self . subpools )
    }
}
pub type VCOS_BLOCKPOOL_T = VCOS_BLOCKPOOL_TAG;
extern "C" {
    pub fn vcos_generic_blockpool_init(
        pool: *mut VCOS_BLOCKPOOL_T,
        num_blocks: VCOS_UNSIGNED,
        block_size: VCOS_UNSIGNED,
        start: *mut ::std::os::raw::c_void,
        pool_size: VCOS_UNSIGNED,
        align: VCOS_UNSIGNED,
        flags: VCOS_UNSIGNED,
        name: *const ::std::os::raw::c_char,
    ) -> VCOS_STATUS_T;
}
extern "C" {
    pub fn vcos_generic_blockpool_create_on_heap(
        pool: *mut VCOS_BLOCKPOOL_T,
        num_blocks: VCOS_UNSIGNED,
        block_size: VCOS_UNSIGNED,
        align: VCOS_UNSIGNED,
        flags: VCOS_UNSIGNED,
        name: *const ::std::os::raw::c_char,
    ) -> VCOS_STATUS_T;
}
extern "C" {
    pub fn vcos_generic_blockpool_extend(
        pool: *mut VCOS_BLOCKPOOL_T,
        num_extensions: VCOS_UNSIGNED,
        num_blocks: VCOS_UNSIGNED,
    ) -> VCOS_STATUS_T;
}
extern "C" {
    pub fn vcos_generic_blockpool_alloc(pool: *mut VCOS_BLOCKPOOL_T)
        -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn vcos_generic_blockpool_calloc(
        pool: *mut VCOS_BLOCKPOOL_T,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn vcos_generic_blockpool_free(block: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn vcos_generic_blockpool_available_count(pool: *mut VCOS_BLOCKPOOL_T) -> VCOS_UNSIGNED;
}
extern "C" {
    pub fn vcos_generic_blockpool_used_count(pool: *mut VCOS_BLOCKPOOL_T) -> VCOS_UNSIGNED;
}
extern "C" {
    pub fn vcos_generic_blockpool_delete(pool: *mut VCOS_BLOCKPOOL_T);
}
extern "C" {
    pub fn vcos_generic_blockpool_elem_to_handle(block: *mut ::std::os::raw::c_void) -> u32;
}
extern "C" {
    pub fn vcos_generic_blockpool_elem_from_handle(
        pool: *mut VCOS_BLOCKPOOL_T,
        handle: u32,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn vcos_generic_blockpool_is_valid_elem(
        pool: *mut VCOS_BLOCKPOOL_T,
        block: *const ::std::os::raw::c_void,
    ) -> u32;
}
extern "C" {
    #[doc = " \\file"]
    #[doc = ""]
    #[doc = " Create the vcos malloc API from a regular system malloc/free library."]
    #[doc = ""]
    #[doc = " The API lets callers specify an alignment."]
    #[doc = ""]
    #[doc = " Under VideoCore this is not needed, as we can simply use the rtos_malloc routines."]
    #[doc = " But on host platforms that won't be the case."]
    #[doc = ""]
    pub fn vcos_generic_mem_alloc(
        sz: VCOS_UNSIGNED,
        desc: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn vcos_generic_mem_calloc(
        count: VCOS_UNSIGNED,
        sz: VCOS_UNSIGNED,
        descr: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn vcos_generic_mem_free(ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn vcos_generic_mem_alloc_aligned(
        sz: VCOS_UNSIGNED,
        align: VCOS_UNSIGNED,
        desc: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Convert errno values into the values recognized by vcos"]
    pub fn vcos_pthreads_map_error(error: ::std::os::raw::c_int) -> VCOS_STATUS_T;
}
extern "C" {
    pub fn vcos_pthreads_map_errno() -> VCOS_STATUS_T;
}
extern "C" {
    #[doc = " Register a function to be called when the current thread exits."]
    pub fn vcos_thread_at_exit(
        pfn: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
        cxt: *mut ::std::os::raw::c_void,
    ) -> VCOS_STATUS_T;
}
extern "C" {
    #[doc = " Threads"]
    #[doc = ""]
    pub fn vcos_dummy_thread_create() -> *mut VCOS_THREAD_T;
}
extern "C" {
    pub fn vcos_getmicrosecs64_internal() -> u64;
}
extern "C" {
    #[doc = " Timers"]
    #[doc = ""]
    pub fn vcos_pthreads_timer_create(
        timer: *mut VCOS_TIMER_T,
        name: *const ::std::os::raw::c_char,
        expiration_routine: ::std::option::Option<
            unsafe extern "C" fn(context: *mut ::std::os::raw::c_void),
        >,
        context: *mut ::std::os::raw::c_void,
    ) -> VCOS_STATUS_T;
}
extern "C" {
    pub fn vcos_pthreads_timer_set(timer: *mut VCOS_TIMER_T, delay_ms: VCOS_UNSIGNED);
}
extern "C" {
    pub fn vcos_pthreads_timer_cancel(timer: *mut VCOS_TIMER_T);
}
extern "C" {
    pub fn vcos_pthreads_timer_reset(timer: *mut VCOS_TIMER_T, delay_ms: VCOS_UNSIGNED);
}
extern "C" {
    pub fn vcos_pthreads_timer_delete(timer: *mut VCOS_TIMER_T);
}
#[doc = " \\file"]
#[doc = ""]
#[doc = " Reentrant Mutexes from regular ones."]
#[doc = ""]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct VCOS_REENTRANT_MUTEX_T {
    pub mutex: VCOS_MUTEX_T,
    pub owner: *mut VCOS_THREAD_T,
    pub count: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_VCOS_REENTRANT_MUTEX_T() {
    assert_eq!(
        ::std::mem::size_of::<VCOS_REENTRANT_MUTEX_T>(),
        32usize,
        concat!("Size of: ", stringify!(VCOS_REENTRANT_MUTEX_T))
    );
    assert_eq!(
        ::std::mem::align_of::<VCOS_REENTRANT_MUTEX_T>(),
        4usize,
        concat!("Alignment of ", stringify!(VCOS_REENTRANT_MUTEX_T))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_REENTRANT_MUTEX_T>())).mutex as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_REENTRANT_MUTEX_T),
            "::",
            stringify!(mutex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_REENTRANT_MUTEX_T>())).owner as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_REENTRANT_MUTEX_T),
            "::",
            stringify!(owner)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_REENTRANT_MUTEX_T>())).count as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_REENTRANT_MUTEX_T),
            "::",
            stringify!(count)
        )
    );
}
impl ::std::fmt::Debug for VCOS_REENTRANT_MUTEX_T {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "VCOS_REENTRANT_MUTEX_T {{ mutex: {:?}, owner: {:?}, count: {:?} }}",
            self.mutex, self.owner, self.count
        )
    }
}
extern "C" {
    pub fn vcos_generic_reentrant_mutex_create(
        m: *mut VCOS_REENTRANT_MUTEX_T,
        name: *const ::std::os::raw::c_char,
    ) -> VCOS_STATUS_T;
}
extern "C" {
    pub fn vcos_generic_reentrant_mutex_delete(m: *mut VCOS_REENTRANT_MUTEX_T);
}
extern "C" {
    pub fn vcos_generic_reentrant_mutex_lock(m: *mut VCOS_REENTRANT_MUTEX_T);
}
extern "C" {
    pub fn vcos_generic_reentrant_mutex_unlock(m: *mut VCOS_REENTRANT_MUTEX_T);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VCOS_NAMED_SEMAPHORE_T {
    #[doc = "< There are 'n' named semaphores per 1 actual semaphore"]
    pub actual: *mut VCOS_NAMED_SEMAPHORE_IMPL_T,
    #[doc = "< Pointer to actual underlying semaphore"]
    pub sem: *mut VCOS_SEMAPHORE_T,
}
#[test]
fn bindgen_test_layout_VCOS_NAMED_SEMAPHORE_T() {
    assert_eq!(
        ::std::mem::size_of::<VCOS_NAMED_SEMAPHORE_T>(),
        8usize,
        concat!("Size of: ", stringify!(VCOS_NAMED_SEMAPHORE_T))
    );
    assert_eq!(
        ::std::mem::align_of::<VCOS_NAMED_SEMAPHORE_T>(),
        4usize,
        concat!("Alignment of ", stringify!(VCOS_NAMED_SEMAPHORE_T))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_NAMED_SEMAPHORE_T>())).actual as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_NAMED_SEMAPHORE_T),
            "::",
            stringify!(actual)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_NAMED_SEMAPHORE_T>())).sem as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_NAMED_SEMAPHORE_T),
            "::",
            stringify!(sem)
        )
    );
}
extern "C" {
    pub fn vcos_generic_named_semaphore_create(
        sem: *mut VCOS_NAMED_SEMAPHORE_T,
        name: *const ::std::os::raw::c_char,
        count: VCOS_UNSIGNED,
    ) -> VCOS_STATUS_T;
}
extern "C" {
    #[doc = " \\brief Delete a semaphore, releasing any resources consumed by it."]
    #[doc = ""]
    #[doc = " @param sem Semaphore to wait on"]
    pub fn vcos_named_semaphore_delete(sem: *mut VCOS_NAMED_SEMAPHORE_T);
}
extern "C" {
    #[doc = " vcos initialization. Call this function before using other vcos functions."]
    #[doc = " Calls can be nested within the same process; they are reference counted so"]
    #[doc = " that only a call from uninitialized state has any effect."]
    #[doc = " @note On platforms/toolchains that support it, gcc's constructor attribute or"]
    #[doc = "       similar is used to invoke this function before main() or equivalent."]
    #[doc = " @return Status of initialisation."]
    pub fn vcos_init() -> VCOS_STATUS_T;
}
extern "C" {
    #[doc = " vcos deinitialization. Call this function when vcos is no longer required,"]
    #[doc = " in order to free resources."]
    #[doc = " Calls can be nested within the same process; they are reference counted so"]
    #[doc = " that only a call that decrements the reference count to 0 has any effect."]
    #[doc = " @note On platforms/toolchains that support it, gcc's destructor attribute or"]
    #[doc = "       similar is used to invoke this function after exit() or equivalent."]
    #[doc = " @return Status of initialisation."]
    pub fn vcos_deinit();
}
extern "C" {
    #[doc = " Acquire global lock. This must be available independent of vcos_init()/vcos_deinit()."]
    pub fn vcos_global_lock();
}
extern "C" {
    #[doc = " Release global lock. This must be available independent of vcos_init()/vcos_deinit()."]
    pub fn vcos_global_unlock();
}
extern "C" {
    #[doc = " Pass in the argv/argc arguments passed to main()"]
    pub fn vcos_set_args(argc: ::std::os::raw::c_int, argv: *mut *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Return argc."]
    pub fn vcos_get_argc() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return argv."]
    pub fn vcos_get_argv() -> *mut *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Platform-specific initialisation."]
    #[doc = " VCOS internal function, not part of public API, do not call from outside"]
    #[doc = " vcos. vcos_init()/vcos_deinit() reference count calls, so this function is"]
    #[doc = " only called from an uninitialized state, i.e. there will not be two"]
    #[doc = " consecutive calls to vcos_platform_init() without an intervening call to"]
    #[doc = " vcos_platform_deinit()."]
    #[doc = " This function is called with vcos_global_lock held."]
    #[doc = " @return Status of initialisation."]
    pub fn vcos_platform_init() -> VCOS_STATUS_T;
}
extern "C" {
    #[doc = " Platform-specific de-initialisation."]
    #[doc = " VCOS internal function, not part of public API, do not call from outside"]
    #[doc = " vcos."]
    #[doc = " See vcos_platform_init() re reference counting."]
    #[doc = " This function is called with vcos_global_lock held."]
    pub fn vcos_platform_deinit();
}
extern "C" {
    #[doc = " Report whether or not we have an RTOS at all, and hence the ability to"]
    #[doc = " create threads."]
    pub fn vcos_have_rtos() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Create a thread. It must be cleaned up by calling vcos_thread_join()."]
    #[doc = ""]
    #[doc = " @param thread   Filled in on return with thread"]
    #[doc = " @param name     A name for the thread. May be the empty string."]
    #[doc = " @param attrs    Attributes; default attributes will be used if this is NULL."]
    #[doc = " @param entry    Entry point."]
    #[doc = " @param arg      Argument passed to the entry point."]
    pub fn vcos_thread_create(
        thread: *mut VCOS_THREAD_T,
        name: *const ::std::os::raw::c_char,
        attrs: *mut VCOS_THREAD_ATTR_T,
        entry: VCOS_THREAD_ENTRY_FN_T,
        arg: *mut ::std::os::raw::c_void,
    ) -> VCOS_STATUS_T;
}
extern "C" {
    #[doc = " Exit the thread from within the thread function itself."]
    #[doc = " Resources must still be cleaned up via a call to thread_join()."]
    #[doc = ""]
    #[doc = " The thread can also be terminated by simply exiting the thread function."]
    #[doc = ""]
    #[doc = " @param data Data passed to thread_join. May be NULL."]
    pub fn vcos_thread_exit(data: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " Wait for a thread to terminate and then clean up its resources."]
    #[doc = ""]
    #[doc = " @param thread Thread to wait for"]
    #[doc = " @param pData  Updated to point at data provided in vcos_thread_exit or exit"]
    #[doc = " code of thread function."]
    pub fn vcos_thread_join(thread: *mut VCOS_THREAD_T, pData: *mut *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " \\brief Create a thread using an API similar to the one \"traditionally\""]
    #[doc = " used under Nucleus."]
    #[doc = ""]
    #[doc = " This creates a thread which must be cleaned up by calling vcos_thread_join()."]
    #[doc = " The thread cannot be simply terminated (as in Nucleus and ThreadX) as thread"]
    #[doc = " termination is not universally supported."]
    #[doc = ""]
    #[doc = " @param thread       Filled in with thread instance"]
    #[doc = " @param name         An optional name for the thread. NULL or \"\" may be used (but"]
    #[doc = "                     a name will aid in debugging)."]
    #[doc = " @param entry        Entry point"]
    #[doc = " @param arg          A single argument passed to the entry point function"]
    #[doc = " @param stack        Pointer to stack address"]
    #[doc = " @param stacksz      Size of stack in bytes"]
    #[doc = " @param priaff       Priority of task, between VCOS_PRI_LOW and VCOS_PRI_HIGH, ORed with the CPU affinity"]
    #[doc = " @param autostart    If non-zero the thread will start immediately."]
    #[doc = " @param timeslice    Timeslice (system ticks) for this thread."]
    #[doc = ""]
    #[doc = " @sa vcos_thread_terminate vcos_thread_delete"]
    pub fn vcos_thread_create_classic(
        thread: *mut VCOS_THREAD_T,
        name: *const ::std::os::raw::c_char,
        entry: ::std::option::Option<
            unsafe extern "C" fn(arg: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
        >,
        arg: *mut ::std::os::raw::c_void,
        stack: *mut ::std::os::raw::c_void,
        stacksz: VCOS_UNSIGNED,
        priaff: VCOS_UNSIGNED,
        timeslice: VCOS_UNSIGNED,
        autostart: VCOS_UNSIGNED,
    ) -> VCOS_STATUS_T;
}
extern "C" {
    #[doc = " Return the name of the given thread."]
    pub fn vcos_thread_get_name(thread: *const VCOS_THREAD_T) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn vcos_kmalloc(
        size: VCOS_UNSIGNED,
        description: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn vcos_kcalloc(
        num: VCOS_UNSIGNED,
        size: VCOS_UNSIGNED,
        description: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn vcos_kfree(ptr: *mut ::std::os::raw::c_void);
}
pub type __gnuc_va_list = __builtin_va_list;
pub type va_list = __gnuc_va_list;
pub const VCOS_LOG_LEVEL_T_VCOS_LOG_UNINITIALIZED: VCOS_LOG_LEVEL_T = 0;
pub const VCOS_LOG_LEVEL_T_VCOS_LOG_NEVER: VCOS_LOG_LEVEL_T = 1;
pub const VCOS_LOG_LEVEL_T_VCOS_LOG_ERROR: VCOS_LOG_LEVEL_T = 2;
pub const VCOS_LOG_LEVEL_T_VCOS_LOG_WARN: VCOS_LOG_LEVEL_T = 3;
pub const VCOS_LOG_LEVEL_T_VCOS_LOG_INFO: VCOS_LOG_LEVEL_T = 4;
pub const VCOS_LOG_LEVEL_T_VCOS_LOG_TRACE: VCOS_LOG_LEVEL_T = 5;
#[doc = " Logging levels"]
pub type VCOS_LOG_LEVEL_T = u32;
#[doc = " A registered logging category."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VCOS_LOG_CAT_T {
    #[doc = "< Which levels are enabled for this category"]
    pub level: VCOS_LOG_LEVEL_T,
    #[doc = "< Name for this category."]
    pub name: *const ::std::os::raw::c_char,
    pub next: *mut VCOS_LOG_CAT_T,
    pub flags: VCOS_LOG_CAT_T__bindgen_ty_1,
    pub refcount: ::std::os::raw::c_uint,
    #[doc = "< platform specific data"]
    pub platform_data: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct VCOS_LOG_CAT_T__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_VCOS_LOG_CAT_T__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<VCOS_LOG_CAT_T__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(VCOS_LOG_CAT_T__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<VCOS_LOG_CAT_T__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(VCOS_LOG_CAT_T__bindgen_ty_1))
    );
}
impl VCOS_LOG_CAT_T__bindgen_ty_1 {
    #[inline]
    pub fn want_prefix(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_want_prefix(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        want_prefix: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let want_prefix: u32 = unsafe { ::std::mem::transmute(want_prefix) };
            want_prefix as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_VCOS_LOG_CAT_T() {
    assert_eq!(
        ::std::mem::size_of::<VCOS_LOG_CAT_T>(),
        24usize,
        concat!("Size of: ", stringify!(VCOS_LOG_CAT_T))
    );
    assert_eq!(
        ::std::mem::align_of::<VCOS_LOG_CAT_T>(),
        4usize,
        concat!("Alignment of ", stringify!(VCOS_LOG_CAT_T))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_LOG_CAT_T>())).level as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_LOG_CAT_T),
            "::",
            stringify!(level)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_LOG_CAT_T>())).name as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_LOG_CAT_T),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_LOG_CAT_T>())).next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_LOG_CAT_T),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_LOG_CAT_T>())).flags as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_LOG_CAT_T),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_LOG_CAT_T>())).refcount as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_LOG_CAT_T),
            "::",
            stringify!(refcount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_LOG_CAT_T>())).platform_data as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_LOG_CAT_T),
            "::",
            stringify!(platform_data)
        )
    );
}
pub type VCOS_VLOG_IMPL_FUNC_T = ::std::option::Option<
    unsafe extern "C" fn(
        cat: *const VCOS_LOG_CAT_T,
        _level: VCOS_LOG_LEVEL_T,
        fmt: *const ::std::os::raw::c_char,
        args: va_list,
    ),
>;
extern "C" {
    #[doc = " Convert a VCOS_LOG_LEVEL_T into a printable string."]
    #[doc = " The platform needs to implement this function."]
    pub fn vcos_log_level_to_string(level: VCOS_LOG_LEVEL_T) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Convert a string into a VCOS_LOG_LEVEL_T"]
    #[doc = " The platform needs to implement this function."]
    pub fn vcos_string_to_log_level(
        str: *const ::std::os::raw::c_char,
        level: *mut VCOS_LOG_LEVEL_T,
    ) -> VCOS_STATUS_T;
}
extern "C" {
    #[doc = " Log a message. Basic API. Normal code should not use this."]
    #[doc = " The platform needs to implement this function."]
    pub fn vcos_log_impl(
        cat: *const VCOS_LOG_CAT_T,
        _level: VCOS_LOG_LEVEL_T,
        fmt: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    #[doc = " Log a message using a varargs parameter list. Normal code should"]
    #[doc = " not use this."]
    pub fn vcos_vlog_impl(
        cat: *const VCOS_LOG_CAT_T,
        _level: VCOS_LOG_LEVEL_T,
        fmt: *const ::std::os::raw::c_char,
        args: va_list,
    );
}
extern "C" {
    #[doc = " Set the function which does the actual logging output."]
    #[doc = "  Passing in NULL causes the default logging function to be"]
    #[doc = "  used."]
    pub fn vcos_set_vlog_impl(vlog_impl_func: VCOS_VLOG_IMPL_FUNC_T);
}
extern "C" {
    #[doc = " The default logging function, which is provided by each"]
    #[doc = " platform."]
    pub fn vcos_vlog_default_impl(
        cat: *const VCOS_LOG_CAT_T,
        _level: VCOS_LOG_LEVEL_T,
        fmt: *const ::std::os::raw::c_char,
        args: va_list,
    );
}
extern "C" {
    pub fn vcos_logging_init();
}
extern "C" {
    #[doc = " Register a logging category."]
    #[doc = ""]
    #[doc = " @param name the name of this category."]
    #[doc = " @param category the category to register."]
    pub fn vcos_log_register(name: *const ::std::os::raw::c_char, category: *mut VCOS_LOG_CAT_T);
}
extern "C" {
    #[doc = " Unregister a logging category."]
    pub fn vcos_log_unregister(category: *mut VCOS_LOG_CAT_T);
}
extern "C" {
    #[doc = " Return a default logging category, for people too lazy to create their own."]
    #[doc = ""]
    #[doc = " Using the default category will be slow (there's an extra function"]
    #[doc = " call overhead). Don't do this in normal code."]
    pub fn vcos_log_get_default_category() -> *const VCOS_LOG_CAT_T;
}
extern "C" {
    pub fn vcos_set_log_options(opt: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Set the logging levels for many categories at once."]
    #[doc = ""]
    #[doc = " Set lots of categorys from a string cat:lev,cat:lev This can"]
    #[doc = " be used at startup time to set a bunch of category levels from"]
    #[doc = " a single string.  Used with C(vcos_logging_level)"]
    pub fn vcos_log_set_level_all(levels: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn vcos_log_dump_mem_impl(
        cat: *const VCOS_LOG_CAT_T,
        label: *const ::std::os::raw::c_char,
        addr: u32,
        voidMem: *const ::std::os::raw::c_void,
        numBytes: usize,
    );
}
pub type VCOS_CMD_T = VCOS_CMD_S;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VCOS_CMD_PARAM_T {
    pub argc: ::std::os::raw::c_int,
    pub argv: *mut *mut ::std::os::raw::c_char,
    pub argv_orig: *mut *mut ::std::os::raw::c_char,
    pub cmd_entry: *mut VCOS_CMD_T,
    pub cmd_parent_entry: *mut VCOS_CMD_T,
    pub use_log: ::std::os::raw::c_int,
    pub result_size: usize,
    pub result_ptr: *mut ::std::os::raw::c_char,
    pub result_buf: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_VCOS_CMD_PARAM_T() {
    assert_eq!(
        ::std::mem::size_of::<VCOS_CMD_PARAM_T>(),
        36usize,
        concat!("Size of: ", stringify!(VCOS_CMD_PARAM_T))
    );
    assert_eq!(
        ::std::mem::align_of::<VCOS_CMD_PARAM_T>(),
        4usize,
        concat!("Alignment of ", stringify!(VCOS_CMD_PARAM_T))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_CMD_PARAM_T>())).argc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_CMD_PARAM_T),
            "::",
            stringify!(argc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_CMD_PARAM_T>())).argv as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_CMD_PARAM_T),
            "::",
            stringify!(argv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_CMD_PARAM_T>())).argv_orig as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_CMD_PARAM_T),
            "::",
            stringify!(argv_orig)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_CMD_PARAM_T>())).cmd_entry as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_CMD_PARAM_T),
            "::",
            stringify!(cmd_entry)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VCOS_CMD_PARAM_T>())).cmd_parent_entry as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_CMD_PARAM_T),
            "::",
            stringify!(cmd_parent_entry)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_CMD_PARAM_T>())).use_log as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_CMD_PARAM_T),
            "::",
            stringify!(use_log)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_CMD_PARAM_T>())).result_size as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_CMD_PARAM_T),
            "::",
            stringify!(result_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_CMD_PARAM_T>())).result_ptr as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_CMD_PARAM_T),
            "::",
            stringify!(result_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_CMD_PARAM_T>())).result_buf as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_CMD_PARAM_T),
            "::",
            stringify!(result_buf)
        )
    );
}
pub type VCOS_CMD_FUNC_T =
    ::std::option::Option<unsafe extern "C" fn(param: *mut VCOS_CMD_PARAM_T) -> VCOS_STATUS_T>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VCOS_CMD_S {
    pub name: *const ::std::os::raw::c_char,
    pub args: *const ::std::os::raw::c_char,
    pub cmd_fn: VCOS_CMD_FUNC_T,
    pub sub_cmd_entry: *mut VCOS_CMD_T,
    pub descr: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_VCOS_CMD_S() {
    assert_eq!(
        ::std::mem::size_of::<VCOS_CMD_S>(),
        20usize,
        concat!("Size of: ", stringify!(VCOS_CMD_S))
    );
    assert_eq!(
        ::std::mem::align_of::<VCOS_CMD_S>(),
        4usize,
        concat!("Alignment of ", stringify!(VCOS_CMD_S))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_CMD_S>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_CMD_S),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_CMD_S>())).args as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_CMD_S),
            "::",
            stringify!(args)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_CMD_S>())).cmd_fn as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_CMD_S),
            "::",
            stringify!(cmd_fn)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_CMD_S>())).sub_cmd_entry as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_CMD_S),
            "::",
            stringify!(sub_cmd_entry)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_CMD_S>())).descr as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_CMD_S),
            "::",
            stringify!(descr)
        )
    );
}
extern "C" {
    pub fn vcos_cmd_error(param: *mut VCOS_CMD_PARAM_T, fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn vcos_cmd_printf(param: *mut VCOS_CMD_PARAM_T, fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn vcos_cmd_vprintf(
        param: *mut VCOS_CMD_PARAM_T,
        fmt: *const ::std::os::raw::c_char,
        args: va_list,
    );
}
extern "C" {
    pub fn vcos_cmd_always_log_output(log_category: *mut VCOS_LOG_CAT_T);
}
extern "C" {
    pub fn vcos_cmd_usage(param: *mut VCOS_CMD_PARAM_T);
}
extern "C" {
    pub fn vcos_cmd_register(cmd_entry: *mut VCOS_CMD_T) -> VCOS_STATUS_T;
}
extern "C" {
    pub fn vcos_cmd_register_multiple(cmd_entry: *mut VCOS_CMD_T) -> VCOS_STATUS_T;
}
extern "C" {
    pub fn vcos_cmd_execute(
        argc: ::std::os::raw::c_int,
        argv: *mut *mut ::std::os::raw::c_char,
        result_size: usize,
        result_buf: *mut ::std::os::raw::c_char,
    ) -> VCOS_STATUS_T;
}
extern "C" {
    pub fn vcos_cmd_shutdown();
}
extern "C" {
    pub fn vcos_log_assert_cmd(param: *mut VCOS_CMD_PARAM_T) -> VCOS_STATUS_T;
}
extern "C" {
    pub fn vcos_log_set_cmd(param: *mut VCOS_CMD_PARAM_T) -> VCOS_STATUS_T;
}
extern "C" {
    pub fn vcos_log_status_cmd(param: *mut VCOS_CMD_PARAM_T) -> VCOS_STATUS_T;
}
extern "C" {
    pub fn vcos_log_test_cmd(param: *mut VCOS_CMD_PARAM_T) -> VCOS_STATUS_T;
}
extern "C" {
    pub fn vcos_vsnprintf(
        buf: *mut ::std::os::raw::c_char,
        buflen: usize,
        fmt: *const ::std::os::raw::c_char,
        ap: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vcos_snprintf(
        buf: *mut ::std::os::raw::c_char,
        buflen: usize,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Like vsnprintf, except it places the output at the specified offset."]
    #[doc = " Output is truncated to fit in buflen bytes, and is guaranteed to be NUL-terminated."]
    #[doc = " Returns the string length before/without truncation."]
    pub fn vcos_safe_vsprintf(
        buf: *mut ::std::os::raw::c_char,
        buflen: usize,
        offset: usize,
        fmt: *const ::std::os::raw::c_char,
        ap: va_list,
    ) -> usize;
}
extern "C" {
    #[doc = " Like snprintf, except it places the output at the specified offset."]
    #[doc = " Output is truncated to fit in buflen bytes, and is guaranteed to be NUL-terminated."]
    #[doc = " Returns the string length before/without truncation."]
    pub fn vcos_safe_sprintf(
        buf: *mut ::std::os::raw::c_char,
        buflen: usize,
        offset: usize,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> usize;
}
extern "C" {
    #[doc = " Copies string src to dst at the specified offset."]
    #[doc = " Output is truncated to fit in dstlen bytes, i.e. the string is at most"]
    #[doc = " (buflen - 1) characters long. Unlike strncpy, exactly one NUL is written"]
    #[doc = " to dst, which is always NUL-terminated."]
    #[doc = " Returns the string length before/without truncation."]
    pub fn vcos_safe_strcpy(
        dst: *mut ::std::os::raw::c_char,
        src: *const ::std::os::raw::c_char,
        dstlen: usize,
        offset: usize,
    ) -> usize;
}
extern "C" {
    #[doc = " Initialize thread attribute struct. This call does not allocate memory,"]
    #[doc = " and so cannot fail."]
    #[doc = ""]
    pub fn vcos_thread_attr_init(attrs: *mut VCOS_THREAD_ATTR_T);
}
extern "C" {
    #[doc = " Perform timer subsystem initialization. This function is not needed"]
    #[doc = " on non-Windows platforms but is still present so that it can be"]
    #[doc = " called. On Windows it is needed because vcos_init() gets called"]
    #[doc = " from DLL initialization where it is not possible to create a"]
    #[doc = " time queue (deadlock occurs if you try)."]
    #[doc = ""]
    #[doc = " @return VCOS_SUCCESS on success. VCOS_EEXIST if this has already been called"]
    #[doc = " once. VCOS_ENOMEM if resource allocation failed."]
    pub fn vcos_timer_init() -> VCOS_STATUS_T;
}
extern "C" {
    #[doc = " \\file vcos_once.h"]
    #[doc = ""]
    #[doc = " Ensure something is called only once."]
    #[doc = ""]
    #[doc = " Initialize once_control to VCOS_ONCE_INIT. The first"]
    #[doc = " time this is called, the init_routine will be called. Thereafter"]
    #[doc = " it won't."]
    #[doc = ""]
    #[doc = " \\sa pthread_once()"]
    #[doc = ""]
    pub fn vcos_once(
        once_control: *mut VCOS_ONCE_T,
        init_routine: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> VCOS_STATUS_T;
}
pub type MMAL_BOOL_T = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_CORE_STATISTICS_T {
    #[doc = "< Total buffer count on this port"]
    pub buffer_count: u32,
    #[doc = "< Time (us) of first buffer seen on this port"]
    pub first_buffer_time: u32,
    #[doc = "< Time (us) of most recently buffer on this port"]
    pub last_buffer_time: u32,
    #[doc = "< Max delay (us) between buffers, ignoring first few frames"]
    pub max_delay: u32,
}
#[test]
fn bindgen_test_layout_MMAL_CORE_STATISTICS_T() {
    assert_eq!(
        ::std::mem::size_of::<MMAL_CORE_STATISTICS_T>(),
        16usize,
        concat!("Size of: ", stringify!(MMAL_CORE_STATISTICS_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_CORE_STATISTICS_T>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_CORE_STATISTICS_T))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_CORE_STATISTICS_T>())).buffer_count as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_CORE_STATISTICS_T),
            "::",
            stringify!(buffer_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_CORE_STATISTICS_T>())).first_buffer_time as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_CORE_STATISTICS_T),
            "::",
            stringify!(first_buffer_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_CORE_STATISTICS_T>())).last_buffer_time as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_CORE_STATISTICS_T),
            "::",
            stringify!(last_buffer_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_CORE_STATISTICS_T>())).max_delay as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_CORE_STATISTICS_T),
            "::",
            stringify!(max_delay)
        )
    );
}
#[doc = " Statistics collected by the core on all ports, if enabled in the build."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_CORE_PORT_STATISTICS_T {
    pub rx: MMAL_CORE_STATISTICS_T,
    pub tx: MMAL_CORE_STATISTICS_T,
}
#[test]
fn bindgen_test_layout_MMAL_CORE_PORT_STATISTICS_T() {
    assert_eq!(
        ::std::mem::size_of::<MMAL_CORE_PORT_STATISTICS_T>(),
        32usize,
        concat!("Size of: ", stringify!(MMAL_CORE_PORT_STATISTICS_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_CORE_PORT_STATISTICS_T>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_CORE_PORT_STATISTICS_T))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_CORE_PORT_STATISTICS_T>())).rx as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_CORE_PORT_STATISTICS_T),
            "::",
            stringify!(rx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_CORE_PORT_STATISTICS_T>())).tx as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_CORE_PORT_STATISTICS_T),
            "::",
            stringify!(tx)
        )
    );
}
#[doc = " Unsigned 16.16 fixed point value, also known as Q16.16"]
pub type MMAL_FIXED_16_16_T = u32;
pub mod MMAL_STATUS_T {
    #[doc = " Status return codes from the API."]
    #[doc = ""]
    #[doc = " \\internal Please try to keep this similar to the standard POSIX codes"]
    #[doc = " rather than making up new ones!"]
    pub type Type = u32;
    #[doc = "< Success"]
    pub const MMAL_SUCCESS: Type = 0;
    #[doc = "< Out of memory"]
    pub const MMAL_ENOMEM: Type = 1;
    #[doc = "< Out of resources (other than memory)"]
    pub const MMAL_ENOSPC: Type = 2;
    #[doc = "< Argument is invalid"]
    pub const MMAL_EINVAL: Type = 3;
    #[doc = "< Function not implemented"]
    pub const MMAL_ENOSYS: Type = 4;
    #[doc = "< No such file or directory"]
    pub const MMAL_ENOENT: Type = 5;
    #[doc = "< No such device or address"]
    pub const MMAL_ENXIO: Type = 6;
    #[doc = "< I/O error"]
    pub const MMAL_EIO: Type = 7;
    #[doc = "< Illegal seek"]
    pub const MMAL_ESPIPE: Type = 8;
    #[doc = "< Data is corrupt \\attention FIXME: not POSIX"]
    pub const MMAL_ECORRUPT: Type = 9;
    #[doc = "< Component is not ready \\attention FIXME: not POSIX"]
    pub const MMAL_ENOTREADY: Type = 10;
    #[doc = "< Component is not configured \\attention FIXME: not POSIX"]
    pub const MMAL_ECONFIG: Type = 11;
    #[doc = "< Port is already connected"]
    pub const MMAL_EISCONN: Type = 12;
    #[doc = "< Port is disconnected"]
    pub const MMAL_ENOTCONN: Type = 13;
    #[doc = "< Resource temporarily unavailable. Try again later"]
    pub const MMAL_EAGAIN: Type = 14;
    #[doc = "< Bad address"]
    pub const MMAL_EFAULT: Type = 15;
    #[doc = "< Force to 32 bit"]
    pub const MMAL_STATUS_MAX: Type = 2147483647;
}
#[doc = " Describes a rectangle"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_RECT_T {
    #[doc = "< x coordinate (from left)"]
    pub x: i32,
    #[doc = "< y coordinate (from top)"]
    pub y: i32,
    #[doc = "< width"]
    pub width: i32,
    #[doc = "< height"]
    pub height: i32,
}
#[test]
fn bindgen_test_layout_MMAL_RECT_T() {
    assert_eq!(
        ::std::mem::size_of::<MMAL_RECT_T>(),
        16usize,
        concat!("Size of: ", stringify!(MMAL_RECT_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_RECT_T>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_RECT_T))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_RECT_T>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_RECT_T),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_RECT_T>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_RECT_T),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_RECT_T>())).width as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_RECT_T),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_RECT_T>())).height as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_RECT_T),
            "::",
            stringify!(height)
        )
    );
}
#[doc = " Describes a rational number"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_RATIONAL_T {
    #[doc = "< Numerator"]
    pub num: i32,
    #[doc = "< Denominator"]
    pub den: i32,
}
#[test]
fn bindgen_test_layout_MMAL_RATIONAL_T() {
    assert_eq!(
        ::std::mem::size_of::<MMAL_RATIONAL_T>(),
        8usize,
        concat!("Size of: ", stringify!(MMAL_RATIONAL_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_RATIONAL_T>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_RATIONAL_T))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_RATIONAL_T>())).num as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_RATIONAL_T),
            "::",
            stringify!(num)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_RATIONAL_T>())).den as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_RATIONAL_T),
            "::",
            stringify!(den)
        )
    );
}
#[doc = " Four Character Code type"]
pub type MMAL_FOURCC_T = u32;
#[doc = "< Unknown elementary stream type"]
pub const MMAL_ES_TYPE_T_MMAL_ES_TYPE_UNKNOWN: MMAL_ES_TYPE_T = 0;
#[doc = "< Elementary stream of control commands"]
pub const MMAL_ES_TYPE_T_MMAL_ES_TYPE_CONTROL: MMAL_ES_TYPE_T = 1;
#[doc = "< Audio elementary stream"]
pub const MMAL_ES_TYPE_T_MMAL_ES_TYPE_AUDIO: MMAL_ES_TYPE_T = 2;
#[doc = "< Video elementary stream"]
pub const MMAL_ES_TYPE_T_MMAL_ES_TYPE_VIDEO: MMAL_ES_TYPE_T = 3;
#[doc = "< Sub-picture elementary stream (e.g. subtitles, overlays)"]
pub const MMAL_ES_TYPE_T_MMAL_ES_TYPE_SUBPICTURE: MMAL_ES_TYPE_T = 4;
#[doc = " Enumeration of the different types of elementary streams."]
#[doc = " This divides elementary streams into 4 big categories, plus an invalid type."]
pub type MMAL_ES_TYPE_T = u32;
#[doc = " Definition of a video format."]
#[doc = " This describes the properties specific to a video stream"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_VIDEO_FORMAT_T {
    #[doc = "< Width of frame in pixels"]
    pub width: u32,
    #[doc = "< Height of frame in rows of pixels"]
    pub height: u32,
    #[doc = "< Visible region of the frame"]
    pub crop: MMAL_RECT_T,
    #[doc = "< Frame rate"]
    pub frame_rate: MMAL_RATIONAL_T,
    #[doc = "< Pixel aspect ratio"]
    pub par: MMAL_RATIONAL_T,
    #[doc = "< FourCC specifying the color space of the"]
    #[doc = " video stream. See the \\ref MmalColorSpace"]
    #[doc = " \"pre-defined color spaces\" for some examples."]
    pub color_space: MMAL_FOURCC_T,
}
#[test]
fn bindgen_test_layout_MMAL_VIDEO_FORMAT_T() {
    assert_eq!(
        ::std::mem::size_of::<MMAL_VIDEO_FORMAT_T>(),
        44usize,
        concat!("Size of: ", stringify!(MMAL_VIDEO_FORMAT_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_VIDEO_FORMAT_T>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_VIDEO_FORMAT_T))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_VIDEO_FORMAT_T>())).width as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_VIDEO_FORMAT_T),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_VIDEO_FORMAT_T>())).height as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_VIDEO_FORMAT_T),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_VIDEO_FORMAT_T>())).crop as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_VIDEO_FORMAT_T),
            "::",
            stringify!(crop)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_VIDEO_FORMAT_T>())).frame_rate as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_VIDEO_FORMAT_T),
            "::",
            stringify!(frame_rate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_VIDEO_FORMAT_T>())).par as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_VIDEO_FORMAT_T),
            "::",
            stringify!(par)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_VIDEO_FORMAT_T>())).color_space as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_VIDEO_FORMAT_T),
            "::",
            stringify!(color_space)
        )
    );
}
#[doc = " Definition of an audio format."]
#[doc = " This describes the properties specific to an audio stream"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_AUDIO_FORMAT_T {
    #[doc = "< Number of audio channels"]
    pub channels: u32,
    #[doc = "< Sample rate"]
    pub sample_rate: u32,
    #[doc = "< Bits per sample"]
    pub bits_per_sample: u32,
    #[doc = "< Size of a block of data"]
    pub block_align: u32,
}
#[test]
fn bindgen_test_layout_MMAL_AUDIO_FORMAT_T() {
    assert_eq!(
        ::std::mem::size_of::<MMAL_AUDIO_FORMAT_T>(),
        16usize,
        concat!("Size of: ", stringify!(MMAL_AUDIO_FORMAT_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_AUDIO_FORMAT_T>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_AUDIO_FORMAT_T))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_AUDIO_FORMAT_T>())).channels as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_AUDIO_FORMAT_T),
            "::",
            stringify!(channels)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_AUDIO_FORMAT_T>())).sample_rate as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_AUDIO_FORMAT_T),
            "::",
            stringify!(sample_rate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_AUDIO_FORMAT_T>())).bits_per_sample as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_AUDIO_FORMAT_T),
            "::",
            stringify!(bits_per_sample)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_AUDIO_FORMAT_T>())).block_align as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_AUDIO_FORMAT_T),
            "::",
            stringify!(block_align)
        )
    );
}
#[doc = " Definition of a subpicture format."]
#[doc = " This describes the properties specific to a subpicture stream"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_SUBPICTURE_FORMAT_T {
    #[doc = "< Width offset to the start of the subpicture"]
    pub x_offset: u32,
    #[doc = "< Height offset to the start of the subpicture"]
    pub y_offset: u32,
}
#[test]
fn bindgen_test_layout_MMAL_SUBPICTURE_FORMAT_T() {
    assert_eq!(
        ::std::mem::size_of::<MMAL_SUBPICTURE_FORMAT_T>(),
        8usize,
        concat!("Size of: ", stringify!(MMAL_SUBPICTURE_FORMAT_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_SUBPICTURE_FORMAT_T>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_SUBPICTURE_FORMAT_T))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_SUBPICTURE_FORMAT_T>())).x_offset as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_SUBPICTURE_FORMAT_T),
            "::",
            stringify!(x_offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_SUBPICTURE_FORMAT_T>())).y_offset as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_SUBPICTURE_FORMAT_T),
            "::",
            stringify!(y_offset)
        )
    );
}
#[doc = " Definition of the type specific format."]
#[doc = " This describes the type specific information of the elementary stream."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union MMAL_ES_SPECIFIC_FORMAT_T {
    #[doc = "< Audio specific information"]
    pub audio: MMAL_AUDIO_FORMAT_T,
    #[doc = "< Video specific information"]
    pub video: MMAL_VIDEO_FORMAT_T,
    #[doc = "< Subpicture specific information"]
    pub subpicture: MMAL_SUBPICTURE_FORMAT_T,
    _bindgen_union_align: [u32; 11usize],
}
#[test]
fn bindgen_test_layout_MMAL_ES_SPECIFIC_FORMAT_T() {
    assert_eq!(
        ::std::mem::size_of::<MMAL_ES_SPECIFIC_FORMAT_T>(),
        44usize,
        concat!("Size of: ", stringify!(MMAL_ES_SPECIFIC_FORMAT_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_ES_SPECIFIC_FORMAT_T>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_ES_SPECIFIC_FORMAT_T))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_ES_SPECIFIC_FORMAT_T>())).audio as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_ES_SPECIFIC_FORMAT_T),
            "::",
            stringify!(audio)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_ES_SPECIFIC_FORMAT_T>())).video as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_ES_SPECIFIC_FORMAT_T),
            "::",
            stringify!(video)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_ES_SPECIFIC_FORMAT_T>())).subpicture as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_ES_SPECIFIC_FORMAT_T),
            "::",
            stringify!(subpicture)
        )
    );
}
impl ::std::fmt::Debug for MMAL_ES_SPECIFIC_FORMAT_T {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "MMAL_ES_SPECIFIC_FORMAT_T {{ union }}")
    }
}
#[doc = " Definition of an elementary stream format"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_ES_FORMAT_T {
    #[doc = "< Type of the elementary stream"]
    pub type_: MMAL_ES_TYPE_T,
    #[doc = "< FourCC specifying the encoding of the elementary stream."]
    #[doc = " See the \\ref MmalEncodings \"pre-defined encodings\" for some"]
    #[doc = " examples."]
    pub encoding: MMAL_FOURCC_T,
    #[doc = "< FourCC specifying the specific encoding variant of"]
    #[doc = " the elementary stream. See the \\ref MmalEncodingVariants"]
    #[doc = " \"pre-defined encoding variants\" for some examples."]
    pub encoding_variant: MMAL_FOURCC_T,
    #[doc = "< Type specific information for the elementary stream"]
    pub es: *mut MMAL_ES_SPECIFIC_FORMAT_T,
    #[doc = "< Bitrate in bits per second"]
    pub bitrate: u32,
    #[doc = "< Flags describing properties of the elementary stream."]
    #[doc = " See \\ref elementarystreamflags \"Elementary stream flags\"."]
    pub flags: u32,
    #[doc = "< Size of the codec specific data"]
    pub extradata_size: u32,
    #[doc = "< Codec specific data"]
    pub extradata: *mut u8,
}
#[test]
fn bindgen_test_layout_MMAL_ES_FORMAT_T() {
    assert_eq!(
        ::std::mem::size_of::<MMAL_ES_FORMAT_T>(),
        32usize,
        concat!("Size of: ", stringify!(MMAL_ES_FORMAT_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_ES_FORMAT_T>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_ES_FORMAT_T))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_ES_FORMAT_T>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_ES_FORMAT_T),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_ES_FORMAT_T>())).encoding as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_ES_FORMAT_T),
            "::",
            stringify!(encoding)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_ES_FORMAT_T>())).encoding_variant as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_ES_FORMAT_T),
            "::",
            stringify!(encoding_variant)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_ES_FORMAT_T>())).es as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_ES_FORMAT_T),
            "::",
            stringify!(es)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_ES_FORMAT_T>())).bitrate as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_ES_FORMAT_T),
            "::",
            stringify!(bitrate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_ES_FORMAT_T>())).flags as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_ES_FORMAT_T),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_ES_FORMAT_T>())).extradata_size as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_ES_FORMAT_T),
            "::",
            stringify!(extradata_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_ES_FORMAT_T>())).extradata as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_ES_FORMAT_T),
            "::",
            stringify!(extradata)
        )
    );
}
extern "C" {
    #[doc = " Allocate and initialise a \\ref MMAL_ES_FORMAT_T structure."]
    #[doc = ""]
    #[doc = " @return a \\ref MMAL_ES_FORMAT_T structure"]
    pub fn mmal_format_alloc() -> *mut MMAL_ES_FORMAT_T;
}
extern "C" {
    #[doc = " Free a \\ref MMAL_ES_FORMAT_T structure allocated by \\ref mmal_format_alloc."]
    #[doc = ""]
    #[doc = " @param format the \\ref MMAL_ES_FORMAT_T structure to free"]
    pub fn mmal_format_free(format: *mut MMAL_ES_FORMAT_T);
}
extern "C" {
    #[doc = " Allocate the extradata buffer in \\ref MMAL_ES_FORMAT_T."]
    #[doc = " This buffer will be freed automatically when the format is destroyed or"]
    #[doc = " another allocation is done."]
    #[doc = ""]
    #[doc = " @param format format structure for which the extradata buffer will be allocated"]
    #[doc = " @param size size of the extradata buffer to allocate"]
    #[doc = " @return MMAL_SUCCESS on success"]
    pub fn mmal_format_extradata_alloc(
        format: *mut MMAL_ES_FORMAT_T,
        size: ::std::os::raw::c_uint,
    ) -> MMAL_STATUS_T::Type;
}
extern "C" {
    #[doc = " Shallow copy a format structure."]
    #[doc = " It is worth noting that the extradata buffer will not be copied in the new format."]
    #[doc = ""]
    #[doc = " @param format_dest destination \\ref MMAL_ES_FORMAT_T for the copy"]
    #[doc = " @param format_src source \\ref MMAL_ES_FORMAT_T for the copy"]
    pub fn mmal_format_copy(format_dest: *mut MMAL_ES_FORMAT_T, format_src: *mut MMAL_ES_FORMAT_T);
}
extern "C" {
    #[doc = " Fully copy a format structure, including the extradata buffer."]
    #[doc = ""]
    #[doc = " @param format_dest destination \\ref MMAL_ES_FORMAT_T for the copy"]
    #[doc = " @param format_src source \\ref MMAL_ES_FORMAT_T for the copy"]
    #[doc = " @return MMAL_SUCCESS on success"]
    pub fn mmal_format_full_copy(
        format_dest: *mut MMAL_ES_FORMAT_T,
        format_src: *mut MMAL_ES_FORMAT_T,
    ) -> MMAL_STATUS_T::Type;
}
extern "C" {
    #[doc = " Compare 2 format structures and returns a set of flags describing the differences."]
    #[doc = " The result will be zero if the structures are the same, or a combination of"]
    #[doc = " one or more of the \\ref comparisonflags \"Comparison flags\" if different."]
    #[doc = ""]
    #[doc = " @param format_1 first \\ref MMAL_ES_FORMAT_T to compare"]
    #[doc = " @param format_2 second \\ref MMAL_ES_FORMAT_T to compare"]
    #[doc = " @return set of flags describing the differences"]
    pub fn mmal_format_compare(
        format_1: *mut MMAL_ES_FORMAT_T,
        format_2: *mut MMAL_ES_FORMAT_T,
    ) -> u32;
}
#[doc = " Specific data associated with video frames"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_BUFFER_HEADER_VIDEO_SPECIFIC_T {
    #[doc = "< Number of planes composing the video frame"]
    pub planes: u32,
    #[doc = "< Offsets to the different planes. These must point within the"]
    #[doc = "payload buffer"]
    pub offset: [u32; 4usize],
    #[doc = "< Pitch (size in bytes of a line of a plane) of the different"]
    #[doc = "planes"]
    pub pitch: [u32; 4usize],
    #[doc = "< Flags describing video specific properties of a buffer header"]
    #[doc = "(see \\ref videobufferheaderflags \"Video buffer header flags\")"]
    pub flags: u32,
}
#[test]
fn bindgen_test_layout_MMAL_BUFFER_HEADER_VIDEO_SPECIFIC_T() {
    assert_eq!(
        ::std::mem::size_of::<MMAL_BUFFER_HEADER_VIDEO_SPECIFIC_T>(),
        40usize,
        concat!("Size of: ", stringify!(MMAL_BUFFER_HEADER_VIDEO_SPECIFIC_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_BUFFER_HEADER_VIDEO_SPECIFIC_T>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(MMAL_BUFFER_HEADER_VIDEO_SPECIFIC_T)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_BUFFER_HEADER_VIDEO_SPECIFIC_T>())).planes as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_BUFFER_HEADER_VIDEO_SPECIFIC_T),
            "::",
            stringify!(planes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_BUFFER_HEADER_VIDEO_SPECIFIC_T>())).offset as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_BUFFER_HEADER_VIDEO_SPECIFIC_T),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_BUFFER_HEADER_VIDEO_SPECIFIC_T>())).pitch as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_BUFFER_HEADER_VIDEO_SPECIFIC_T),
            "::",
            stringify!(pitch)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_BUFFER_HEADER_VIDEO_SPECIFIC_T>())).flags as *const _
                as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_BUFFER_HEADER_VIDEO_SPECIFIC_T),
            "::",
            stringify!(flags)
        )
    );
}
#[doc = " Type specific data that's associated with a payload buffer"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union MMAL_BUFFER_HEADER_TYPE_SPECIFIC_T {
    #[doc = " Specific data associated with video frames"]
    pub video: MMAL_BUFFER_HEADER_VIDEO_SPECIFIC_T,
    _bindgen_union_align: [u32; 10usize],
}
#[test]
fn bindgen_test_layout_MMAL_BUFFER_HEADER_TYPE_SPECIFIC_T() {
    assert_eq!(
        ::std::mem::size_of::<MMAL_BUFFER_HEADER_TYPE_SPECIFIC_T>(),
        40usize,
        concat!("Size of: ", stringify!(MMAL_BUFFER_HEADER_TYPE_SPECIFIC_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_BUFFER_HEADER_TYPE_SPECIFIC_T>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(MMAL_BUFFER_HEADER_TYPE_SPECIFIC_T)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_BUFFER_HEADER_TYPE_SPECIFIC_T>())).video as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_BUFFER_HEADER_TYPE_SPECIFIC_T),
            "::",
            stringify!(video)
        )
    );
}
impl ::std::fmt::Debug for MMAL_BUFFER_HEADER_TYPE_SPECIFIC_T {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "MMAL_BUFFER_HEADER_TYPE_SPECIFIC_T {{ union }}")
    }
}
#[doc = " Definition of the buffer header structure."]
#[doc = " A buffer header does not directly carry the data to be passed to a component but instead"]
#[doc = " it references the actual data using a pointer (and an associated length)."]
#[doc = " It also contains an internal area which can be used to store command to be associated"]
#[doc = " with the external data."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_BUFFER_HEADER_T {
    #[doc = "< Used to link several buffer headers together"]
    pub next: *mut MMAL_BUFFER_HEADER_T,
    #[doc = "< Data private to the framework"]
    pub priv_: *mut MMAL_BUFFER_HEADER_PRIVATE_T,
    #[doc = "< Defines what the buffer header contains. This is a FourCC"]
    #[doc = "with 0 as a special value meaning stream data"]
    pub cmd: u32,
    #[doc = "< Pointer to the start of the payload buffer (should not be"]
    #[doc = "changed by component)"]
    pub data: *mut u8,
    #[doc = "< Allocated size in bytes of payload buffer"]
    pub alloc_size: u32,
    #[doc = "< Number of bytes currently used in the payload buffer (starting"]
    #[doc = "from offset)"]
    pub length: u32,
    #[doc = "< Offset in bytes to the start of valid data in the payload buffer"]
    pub offset: u32,
    #[doc = "< Flags describing properties of a buffer header (see"]
    #[doc = "\\ref bufferheaderflags \"Buffer header flags\")"]
    pub flags: u32,
    #[doc = "< Presentation timestamp in microseconds. \\ref MMAL_TIME_UNKNOWN"]
    #[doc = "is used when the pts is unknown."]
    pub pts: i64,
    #[doc = "< Decode timestamp in microseconds (dts = pts, except in the case"]
    #[doc = "of video streams with B frames). \\ref MMAL_TIME_UNKNOWN"]
    #[doc = "is used when the dts is unknown."]
    pub dts: i64,
    #[doc = " Type specific data that's associated with a payload buffer"]
    pub type_: *mut MMAL_BUFFER_HEADER_TYPE_SPECIFIC_T,
    #[doc = "< Field reserved for use by the client"]
    pub user_data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_MMAL_BUFFER_HEADER_T() {
    assert_eq!(
        ::std::mem::size_of::<MMAL_BUFFER_HEADER_T>(),
        56usize,
        concat!("Size of: ", stringify!(MMAL_BUFFER_HEADER_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_BUFFER_HEADER_T>(),
        8usize,
        concat!("Alignment of ", stringify!(MMAL_BUFFER_HEADER_T))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_BUFFER_HEADER_T>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_BUFFER_HEADER_T),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_BUFFER_HEADER_T>())).priv_ as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_BUFFER_HEADER_T),
            "::",
            stringify!(priv_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_BUFFER_HEADER_T>())).cmd as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_BUFFER_HEADER_T),
            "::",
            stringify!(cmd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_BUFFER_HEADER_T>())).data as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_BUFFER_HEADER_T),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_BUFFER_HEADER_T>())).alloc_size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_BUFFER_HEADER_T),
            "::",
            stringify!(alloc_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_BUFFER_HEADER_T>())).length as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_BUFFER_HEADER_T),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_BUFFER_HEADER_T>())).offset as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_BUFFER_HEADER_T),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_BUFFER_HEADER_T>())).flags as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_BUFFER_HEADER_T),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_BUFFER_HEADER_T>())).pts as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_BUFFER_HEADER_T),
            "::",
            stringify!(pts)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_BUFFER_HEADER_T>())).dts as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_BUFFER_HEADER_T),
            "::",
            stringify!(dts)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_BUFFER_HEADER_T>())).type_ as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_BUFFER_HEADER_T),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_BUFFER_HEADER_T>())).user_data as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_BUFFER_HEADER_T),
            "::",
            stringify!(user_data)
        )
    );
}
extern "C" {
    #[doc = " Acquire a buffer header."]
    #[doc = " Acquiring a buffer header increases a reference counter on it and makes sure that the"]
    #[doc = " buffer header won't be recycled until all the references to it are gone."]
    #[doc = " This is useful for instance if a component needs to return a buffer header but still needs"]
    #[doc = " access to it for some internal processing (e.g. reference frames in video codecs)."]
    #[doc = ""]
    #[doc = " @param header buffer header to acquire"]
    pub fn mmal_buffer_header_acquire(header: *mut MMAL_BUFFER_HEADER_T);
}
extern "C" {
    #[doc = " Reset a buffer header."]
    #[doc = " Resets all header variables to default values."]
    #[doc = ""]
    #[doc = " @param header buffer header to reset"]
    pub fn mmal_buffer_header_reset(header: *mut MMAL_BUFFER_HEADER_T);
}
extern "C" {
    #[doc = " Release a buffer header."]
    #[doc = " Releasing a buffer header will decrease its reference counter and when no more references"]
    #[doc = " are left, the buffer header will be recycled by calling its 'release' callback function."]
    #[doc = ""]
    #[doc = " If a pre-release callback is set (\\ref MMAL_BH_PRE_RELEASE_CB_T), this will be invoked"]
    #[doc = " before calling the buffer's release callback and potentially postpone buffer recycling."]
    #[doc = " Once pre-release is complete the buffer header is recycled with"]
    #[doc = " \\ref mmal_buffer_header_release_continue."]
    #[doc = ""]
    #[doc = " @param header buffer header to release"]
    pub fn mmal_buffer_header_release(header: *mut MMAL_BUFFER_HEADER_T);
}
extern "C" {
    #[doc = " Continue the buffer header release process."]
    #[doc = " This should be called to complete buffer header recycling once all pre-release activity"]
    #[doc = " has been completed."]
    #[doc = ""]
    #[doc = " @param header buffer header to release"]
    pub fn mmal_buffer_header_release_continue(header: *mut MMAL_BUFFER_HEADER_T);
}
#[doc = " Buffer header pre-release callback."]
#[doc = " The callback is invoked just before a buffer is released back into a"]
#[doc = " pool. This is used by clients who need to trigger additional actions"]
#[doc = " before the buffer can finally be released (e.g. wait for a bulk transfer"]
#[doc = " to complete)."]
#[doc = ""]
#[doc = " The callback should return TRUE if the buffer release need to be post-poned."]
#[doc = ""]
#[doc = " @param header   buffer header about to be released"]
#[doc = " @param userdata user-specific data"]
#[doc = ""]
#[doc = " @return TRUE if the buffer should not be released"]
pub type MMAL_BH_PRE_RELEASE_CB_T = ::std::option::Option<
    unsafe extern "C" fn(
        header: *mut MMAL_BUFFER_HEADER_T,
        userdata: *mut ::std::os::raw::c_void,
    ) -> MMAL_BOOL_T,
>;
extern "C" {
    #[doc = " Set a buffer header pre-release callback."]
    #[doc = " If the callback is NULL, the buffer will be released back into the pool"]
    #[doc = " immediately as usual."]
    #[doc = ""]
    #[doc = " @param header   buffer header to associate callback with"]
    #[doc = " @param cb       pre-release callback to invoke"]
    #[doc = " @param userdata user-specific data"]
    pub fn mmal_buffer_header_pre_release_cb_set(
        header: *mut MMAL_BUFFER_HEADER_T,
        cb: MMAL_BH_PRE_RELEASE_CB_T,
        userdata: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Replicate a buffer header into another one."]
    #[doc = " Replicating a buffer header will not only do an exact copy of all the public fields of the"]
    #[doc = " buffer header (including data and alloc_size), but it will also acquire a reference to the"]
    #[doc = " source buffer header which will only be released once the replicate has been released."]
    #[doc = ""]
    #[doc = " @param dest buffer header into which to replicate"]
    #[doc = " @param src buffer header to use as the source for the replication"]
    #[doc = " @return MMAL_SUCCESS on success"]
    pub fn mmal_buffer_header_replicate(
        dest: *mut MMAL_BUFFER_HEADER_T,
        src: *mut MMAL_BUFFER_HEADER_T,
    ) -> MMAL_STATUS_T::Type;
}
extern "C" {
    #[doc = " Lock the data buffer contained in the buffer header in memory."]
    #[doc = " This call does nothing on all platforms except VideoCore where it is needed to pin a"]
    #[doc = " buffer in memory before any access to it."]
    #[doc = ""]
    #[doc = " @param header buffer header to lock"]
    pub fn mmal_buffer_header_mem_lock(header: *mut MMAL_BUFFER_HEADER_T) -> MMAL_STATUS_T::Type;
}
extern "C" {
    #[doc = " Unlock the data buffer contained in the buffer header."]
    #[doc = " This call does nothing on all platforms except VideoCore where it is needed to un-pin a"]
    #[doc = " buffer in memory after any access to it."]
    #[doc = ""]
    #[doc = " @param header buffer header to unlock"]
    pub fn mmal_buffer_header_mem_unlock(header: *mut MMAL_BUFFER_HEADER_T);
}
#[doc = "< Never a valid parameter ID"]
pub const MMAL_PARAMETER_UNUSED: _bindgen_ty_25 = 0;
#[doc = "< Takes a MMAL_PARAMETER_ENCODING_T"]
pub const MMAL_PARAMETER_SUPPORTED_ENCODINGS: _bindgen_ty_25 = 1;
#[doc = "< Takes a MMAL_PARAMETER_URI_T"]
pub const MMAL_PARAMETER_URI: _bindgen_ty_25 = 2;
#[doc = "< Takes a MMAL_PARAMETER_CHANGE_EVENT_REQUEST_T"]
pub const MMAL_PARAMETER_CHANGE_EVENT_REQUEST: _bindgen_ty_25 = 3;
#[doc = "< Takes a MMAL_PARAMETER_BOOLEAN_T"]
pub const MMAL_PARAMETER_ZERO_COPY: _bindgen_ty_25 = 4;
#[doc = "< Takes a MMAL_PARAMETER_BUFFER_REQUIREMENTS_T"]
pub const MMAL_PARAMETER_BUFFER_REQUIREMENTS: _bindgen_ty_25 = 5;
#[doc = "< Takes a MMAL_PARAMETER_STATISTICS_T"]
pub const MMAL_PARAMETER_STATISTICS: _bindgen_ty_25 = 6;
#[doc = "< Takes a MMAL_PARAMETER_CORE_STATISTICS_T"]
pub const MMAL_PARAMETER_CORE_STATISTICS: _bindgen_ty_25 = 7;
#[doc = "< Takes a MMAL_PARAMETER_MEM_USAGE_T"]
pub const MMAL_PARAMETER_MEM_USAGE: _bindgen_ty_25 = 8;
#[doc = "< Takes a MMAL_PARAMETER_UINT32_T"]
pub const MMAL_PARAMETER_BUFFER_FLAG_FILTER: _bindgen_ty_25 = 9;
#[doc = "< Takes a MMAL_PARAMETER_SEEK_T"]
pub const MMAL_PARAMETER_SEEK: _bindgen_ty_25 = 10;
#[doc = "< Takes a MMAL_PARAMETER_BOOLEAN_T"]
pub const MMAL_PARAMETER_POWERMON_ENABLE: _bindgen_ty_25 = 11;
#[doc = "< Takes a MMAL_PARAMETER_LOGGING_T"]
pub const MMAL_PARAMETER_LOGGING: _bindgen_ty_25 = 12;
#[doc = "< Takes a MMAL_PARAMETER_UINT64_T"]
pub const MMAL_PARAMETER_SYSTEM_TIME: _bindgen_ty_25 = 13;
#[doc = "< Takes a MMAL_PARAMETER_BOOLEAN_T"]
pub const MMAL_PARAMETER_NO_IMAGE_PADDING: _bindgen_ty_25 = 14;
#[doc = "< Takes a MMAL_PARAMETER_BOOLEAN_T"]
pub const MMAL_PARAMETER_LOCKSTEP_ENABLE: _bindgen_ty_25 = 15;
#[doc = " Common MMAL parameter IDs."]
pub type _bindgen_ty_25 = u32;
#[doc = " Parameter header type. All parameter structures need to begin with this type."]
#[doc = " The \\ref id field must be set to a parameter ID, such as one of those listed on"]
#[doc = " the \\ref MMAL_PARAMETER_IDS \"Pre-defined MMAL parameter IDs\" page."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_HEADER_T {
    #[doc = "< Parameter ID."]
    pub id: u32,
    #[doc = "< Size in bytes of the parameter (including the header)"]
    pub size: u32,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_HEADER_T() {
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_HEADER_T>(),
        8usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_HEADER_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_HEADER_T>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_PARAMETER_HEADER_T))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_PARAMETER_HEADER_T>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_HEADER_T),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_PARAMETER_HEADER_T>())).size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_HEADER_T),
            "::",
            stringify!(size)
        )
    );
}
#[doc = " Change event request parameter type."]
#[doc = " This is used to control whether a \\ref MMAL_EVENT_PARAMETER_CHANGED_T event"]
#[doc = " is issued should a given parameter change."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_CHANGE_EVENT_REQUEST_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    #[doc = "< ID of parameter that may change, see \\ref MMAL_PARAMETER_IDS"]
    pub change_id: u32,
    #[doc = "< True if the event is enabled, false if disabled"]
    pub enable: MMAL_BOOL_T,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_CHANGE_EVENT_REQUEST_T() {
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_CHANGE_EVENT_REQUEST_T>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(MMAL_PARAMETER_CHANGE_EVENT_REQUEST_T)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_CHANGE_EVENT_REQUEST_T>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(MMAL_PARAMETER_CHANGE_EVENT_REQUEST_T)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CHANGE_EVENT_REQUEST_T>())).hdr as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CHANGE_EVENT_REQUEST_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CHANGE_EVENT_REQUEST_T>())).change_id as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CHANGE_EVENT_REQUEST_T),
            "::",
            stringify!(change_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CHANGE_EVENT_REQUEST_T>())).enable as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CHANGE_EVENT_REQUEST_T),
            "::",
            stringify!(enable)
        )
    );
}
#[doc = " Buffer requirements parameter."]
#[doc = " This is mainly used to increase the requirements of a component."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_BUFFER_REQUIREMENTS_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    #[doc = "< Minimum number of buffers the port requires"]
    pub buffer_num_min: u32,
    #[doc = "< Minimum size of buffers the port requires"]
    pub buffer_size_min: u32,
    #[doc = "< Minimum alignment requirement for the buffers."]
    #[doc = "A value of zero means no special alignment requirements."]
    pub buffer_alignment_min: u32,
    #[doc = "< Number of buffers the port recommends for optimal performance."]
    #[doc = "A value of zero means no special recommendation."]
    pub buffer_num_recommended: u32,
    #[doc = "< Size of buffers the port recommends for optimal performance."]
    #[doc = "A value of zero means no special recommendation."]
    pub buffer_size_recommended: u32,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_BUFFER_REQUIREMENTS_T() {
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_BUFFER_REQUIREMENTS_T>(),
        28usize,
        concat!(
            "Size of: ",
            stringify!(MMAL_PARAMETER_BUFFER_REQUIREMENTS_T)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_BUFFER_REQUIREMENTS_T>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(MMAL_PARAMETER_BUFFER_REQUIREMENTS_T)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_BUFFER_REQUIREMENTS_T>())).hdr as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_BUFFER_REQUIREMENTS_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_BUFFER_REQUIREMENTS_T>())).buffer_num_min
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_BUFFER_REQUIREMENTS_T),
            "::",
            stringify!(buffer_num_min)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_BUFFER_REQUIREMENTS_T>())).buffer_size_min
                as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_BUFFER_REQUIREMENTS_T),
            "::",
            stringify!(buffer_size_min)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_BUFFER_REQUIREMENTS_T>())).buffer_alignment_min
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_BUFFER_REQUIREMENTS_T),
            "::",
            stringify!(buffer_alignment_min)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_BUFFER_REQUIREMENTS_T>())).buffer_num_recommended
                as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_BUFFER_REQUIREMENTS_T),
            "::",
            stringify!(buffer_num_recommended)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_BUFFER_REQUIREMENTS_T>())).buffer_size_recommended
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_BUFFER_REQUIREMENTS_T),
            "::",
            stringify!(buffer_size_recommended)
        )
    );
}
#[doc = " Seek request parameter type."]
#[doc = " This is used to issue a seek request to a source component."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_SEEK_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    #[doc = "< Offset (in microseconds) to seek to"]
    pub offset: i64,
    #[doc = "< Seeking flags"]
    pub flags: u32,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_SEEK_T() {
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_SEEK_T>(),
        24usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_SEEK_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_SEEK_T>(),
        8usize,
        concat!("Alignment of ", stringify!(MMAL_PARAMETER_SEEK_T))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_PARAMETER_SEEK_T>())).hdr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_SEEK_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_PARAMETER_SEEK_T>())).offset as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_SEEK_T),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_PARAMETER_SEEK_T>())).flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_SEEK_T),
            "::",
            stringify!(flags)
        )
    );
}
#[doc = " Port statistics for debugging/test purposes."]
#[doc = " Ports may support query of this parameter to return statistics for debugging or"]
#[doc = " test purposes. Not all values may be relevant for a given port."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_STATISTICS_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    #[doc = "< Total number of buffers processed"]
    pub buffer_count: u32,
    #[doc = "< Total number of frames processed"]
    pub frame_count: u32,
    #[doc = "< Number of frames without expected PTS based on frame rate"]
    pub frames_skipped: u32,
    #[doc = "< Number of frames discarded"]
    pub frames_discarded: u32,
    #[doc = "< Set if the end of stream has been reached"]
    pub eos_seen: u32,
    #[doc = "< Maximum frame size in bytes"]
    pub maximum_frame_bytes: u32,
    #[doc = "< Total number of bytes processed"]
    pub total_bytes: i64,
    #[doc = "< Number of corrupt macroblocks in the stream"]
    pub corrupt_macroblocks: u32,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_STATISTICS_T() {
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_STATISTICS_T>(),
        48usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_STATISTICS_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_STATISTICS_T>(),
        8usize,
        concat!("Alignment of ", stringify!(MMAL_PARAMETER_STATISTICS_T))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_PARAMETER_STATISTICS_T>())).hdr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_STATISTICS_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_STATISTICS_T>())).buffer_count as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_STATISTICS_T),
            "::",
            stringify!(buffer_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_STATISTICS_T>())).frame_count as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_STATISTICS_T),
            "::",
            stringify!(frame_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_STATISTICS_T>())).frames_skipped as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_STATISTICS_T),
            "::",
            stringify!(frames_skipped)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_STATISTICS_T>())).frames_discarded as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_STATISTICS_T),
            "::",
            stringify!(frames_discarded)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_STATISTICS_T>())).eos_seen as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_STATISTICS_T),
            "::",
            stringify!(eos_seen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_STATISTICS_T>())).maximum_frame_bytes as *const _
                as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_STATISTICS_T),
            "::",
            stringify!(maximum_frame_bytes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_STATISTICS_T>())).total_bytes as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_STATISTICS_T),
            "::",
            stringify!(total_bytes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_STATISTICS_T>())).corrupt_macroblocks as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_STATISTICS_T),
            "::",
            stringify!(corrupt_macroblocks)
        )
    );
}
pub const MMAL_CORE_STATS_DIR_MMAL_CORE_STATS_RX: MMAL_CORE_STATS_DIR = 0;
pub const MMAL_CORE_STATS_DIR_MMAL_CORE_STATS_TX: MMAL_CORE_STATS_DIR = 1;
pub const MMAL_CORE_STATS_DIR_MMAL_CORE_STATS_MAX: MMAL_CORE_STATS_DIR = 2147483647;
pub type MMAL_CORE_STATS_DIR = u32;
#[doc = " MMAL core statistics. These are collected by the core itself."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_CORE_STATISTICS_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    pub dir: MMAL_CORE_STATS_DIR,
    #[doc = "< Reset to zero after reading"]
    pub reset: MMAL_BOOL_T,
    #[doc = "< The statistics"]
    pub stats: MMAL_CORE_STATISTICS_T,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_CORE_STATISTICS_T() {
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_CORE_STATISTICS_T>(),
        32usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_CORE_STATISTICS_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_CORE_STATISTICS_T>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(MMAL_PARAMETER_CORE_STATISTICS_T)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CORE_STATISTICS_T>())).hdr as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CORE_STATISTICS_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CORE_STATISTICS_T>())).dir as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CORE_STATISTICS_T),
            "::",
            stringify!(dir)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CORE_STATISTICS_T>())).reset as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CORE_STATISTICS_T),
            "::",
            stringify!(reset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CORE_STATISTICS_T>())).stats as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CORE_STATISTICS_T),
            "::",
            stringify!(stats)
        )
    );
}
#[doc = " Component memory usage statistics."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_MEM_USAGE_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    pub pool_mem_alloc_size: u32,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_MEM_USAGE_T() {
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_MEM_USAGE_T>(),
        12usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_MEM_USAGE_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_MEM_USAGE_T>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_PARAMETER_MEM_USAGE_T))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_PARAMETER_MEM_USAGE_T>())).hdr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_MEM_USAGE_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_MEM_USAGE_T>())).pool_mem_alloc_size as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_MEM_USAGE_T),
            "::",
            stringify!(pool_mem_alloc_size)
        )
    );
}
#[doc = " Logging control."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_LOGGING_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    #[doc = "< Logging bits to set"]
    pub set: u32,
    #[doc = "< Logging bits to clear"]
    pub clear: u32,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_LOGGING_T() {
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_LOGGING_T>(),
        16usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_LOGGING_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_LOGGING_T>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_PARAMETER_LOGGING_T))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_PARAMETER_LOGGING_T>())).hdr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_LOGGING_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_PARAMETER_LOGGING_T>())).set as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_LOGGING_T),
            "::",
            stringify!(set)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_PARAMETER_LOGGING_T>())).clear as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_LOGGING_T),
            "::",
            stringify!(clear)
        )
    );
}
#[doc = "< Takes a @ref MMAL_PARAMETER_THUMBNAIL_CONFIG_T"]
pub const MMAL_PARAMETER_THUMBNAIL_CONFIGURATION: _bindgen_ty_26 = 65536;
#[doc = "< Unused?"]
pub const MMAL_PARAMETER_CAPTURE_QUALITY: _bindgen_ty_26 = 65537;
#[doc = "< Takes a @ref MMAL_PARAMETER_INT32_T"]
pub const MMAL_PARAMETER_ROTATION: _bindgen_ty_26 = 65538;
#[doc = "< Takes a @ref MMAL_PARAMETER_BOOLEAN_T"]
pub const MMAL_PARAMETER_EXIF_DISABLE: _bindgen_ty_26 = 65539;
#[doc = "< Takes a @ref MMAL_PARAMETER_EXIF_T"]
pub const MMAL_PARAMETER_EXIF: _bindgen_ty_26 = 65540;
#[doc = "< Takes a @ref MMAL_PARAM_AWBMODE_T"]
pub const MMAL_PARAMETER_AWB_MODE: _bindgen_ty_26 = 65541;
#[doc = "< Takes a @ref MMAL_PARAMETER_IMAGEFX_T"]
pub const MMAL_PARAMETER_IMAGE_EFFECT: _bindgen_ty_26 = 65542;
#[doc = "< Takes a @ref MMAL_PARAMETER_COLOURFX_T"]
pub const MMAL_PARAMETER_COLOUR_EFFECT: _bindgen_ty_26 = 65543;
#[doc = "< Takes a @ref MMAL_PARAMETER_FLICKERAVOID_T"]
pub const MMAL_PARAMETER_FLICKER_AVOID: _bindgen_ty_26 = 65544;
#[doc = "< Takes a @ref MMAL_PARAMETER_FLASH_T"]
pub const MMAL_PARAMETER_FLASH: _bindgen_ty_26 = 65545;
#[doc = "< Takes a @ref MMAL_PARAMETER_REDEYE_T"]
pub const MMAL_PARAMETER_REDEYE: _bindgen_ty_26 = 65546;
#[doc = "< Takes a @ref MMAL_PARAMETER_FOCUS_T"]
pub const MMAL_PARAMETER_FOCUS: _bindgen_ty_26 = 65547;
#[doc = "< Unused?"]
pub const MMAL_PARAMETER_FOCAL_LENGTHS: _bindgen_ty_26 = 65548;
#[doc = "< Takes a @ref MMAL_PARAMETER_INT32_T or MMAL_PARAMETER_RATIONAL_T"]
pub const MMAL_PARAMETER_EXPOSURE_COMP: _bindgen_ty_26 = 65549;
#[doc = "< Takes a @ref MMAL_PARAMETER_SCALEFACTOR_T"]
pub const MMAL_PARAMETER_ZOOM: _bindgen_ty_26 = 65550;
#[doc = "< Takes a @ref MMAL_PARAMETER_MIRROR_T"]
pub const MMAL_PARAMETER_MIRROR: _bindgen_ty_26 = 65551;
#[doc = "< Takes a @ref MMAL_PARAMETER_UINT32_T"]
pub const MMAL_PARAMETER_CAMERA_NUM: _bindgen_ty_26 = 65552;
#[doc = "< Takes a @ref MMAL_PARAMETER_BOOLEAN_T"]
pub const MMAL_PARAMETER_CAPTURE: _bindgen_ty_26 = 65553;
#[doc = "< Takes a @ref MMAL_PARAMETER_EXPOSUREMODE_T"]
pub const MMAL_PARAMETER_EXPOSURE_MODE: _bindgen_ty_26 = 65554;
#[doc = "< Takes a @ref MMAL_PARAMETER_EXPOSUREMETERINGMODE_T"]
pub const MMAL_PARAMETER_EXP_METERING_MODE: _bindgen_ty_26 = 65555;
#[doc = "< Takes a @ref MMAL_PARAMETER_FOCUS_STATUS_T"]
pub const MMAL_PARAMETER_FOCUS_STATUS: _bindgen_ty_26 = 65556;
#[doc = "< Takes a @ref MMAL_PARAMETER_CAMERA_CONFIG_T"]
pub const MMAL_PARAMETER_CAMERA_CONFIG: _bindgen_ty_26 = 65557;
#[doc = "< Takes a @ref MMAL_PARAMETER_CAPTURE_STATUS_T"]
pub const MMAL_PARAMETER_CAPTURE_STATUS: _bindgen_ty_26 = 65558;
#[doc = "< Takes a @ref MMAL_PARAMETER_FACE_TRACK_T"]
pub const MMAL_PARAMETER_FACE_TRACK: _bindgen_ty_26 = 65559;
#[doc = "< Takes a @ref MMAL_PARAMETER_BOOLEAN_T"]
pub const MMAL_PARAMETER_DRAW_BOX_FACES_AND_FOCUS: _bindgen_ty_26 = 65560;
#[doc = "< Takes a @ref MMAL_PARAMETER_UINT32_T"]
pub const MMAL_PARAMETER_JPEG_Q_FACTOR: _bindgen_ty_26 = 65561;
#[doc = "< Takes a @ref MMAL_PARAMETER_FRAME_RATE_T"]
pub const MMAL_PARAMETER_FRAME_RATE: _bindgen_ty_26 = 65562;
#[doc = "< Takes a @ref MMAL_PARAMETER_CAMERA_STC_MODE_T"]
pub const MMAL_PARAMETER_USE_STC: _bindgen_ty_26 = 65563;
#[doc = "< Takes a @ref MMAL_PARAMETER_CAMERA_INFO_T"]
pub const MMAL_PARAMETER_CAMERA_INFO: _bindgen_ty_26 = 65564;
#[doc = "< Takes a @ref MMAL_PARAMETER_BOOLEAN_T"]
pub const MMAL_PARAMETER_VIDEO_STABILISATION: _bindgen_ty_26 = 65565;
#[doc = "< Takes a @ref MMAL_PARAMETER_FACE_TRACK_RESULTS_T"]
pub const MMAL_PARAMETER_FACE_TRACK_RESULTS: _bindgen_ty_26 = 65566;
#[doc = "< Takes a @ref MMAL_PARAMETER_BOOLEAN_T"]
pub const MMAL_PARAMETER_ENABLE_RAW_CAPTURE: _bindgen_ty_26 = 65567;
#[doc = "< Takes a @ref MMAL_PARAMETER_URI_T"]
pub const MMAL_PARAMETER_DPF_FILE: _bindgen_ty_26 = 65568;
#[doc = "< Takes a @ref MMAL_PARAMETER_BOOLEAN_T"]
pub const MMAL_PARAMETER_ENABLE_DPF_FILE: _bindgen_ty_26 = 65569;
#[doc = "< Takes a @ref MMAL_PARAMETER_BOOLEAN_T"]
pub const MMAL_PARAMETER_DPF_FAIL_IS_FATAL: _bindgen_ty_26 = 65570;
#[doc = "< Takes a @ref MMAL_PARAMETER_CAPTUREMODE_T"]
pub const MMAL_PARAMETER_CAPTURE_MODE: _bindgen_ty_26 = 65571;
#[doc = "< Takes a @ref MMAL_PARAMETER_FOCUS_REGIONS_T"]
pub const MMAL_PARAMETER_FOCUS_REGIONS: _bindgen_ty_26 = 65572;
#[doc = "< Takes a @ref MMAL_PARAMETER_INPUT_CROP_T"]
pub const MMAL_PARAMETER_INPUT_CROP: _bindgen_ty_26 = 65573;
#[doc = "< Takes a @ref MMAL_PARAMETER_SENSOR_INFORMATION_T"]
pub const MMAL_PARAMETER_SENSOR_INFORMATION: _bindgen_ty_26 = 65574;
#[doc = "< Takes a @ref MMAL_PARAMETER_FLASH_SELECT_T"]
pub const MMAL_PARAMETER_FLASH_SELECT: _bindgen_ty_26 = 65575;
#[doc = "< Takes a @ref MMAL_PARAMETER_FIELD_OF_VIEW_T"]
pub const MMAL_PARAMETER_FIELD_OF_VIEW: _bindgen_ty_26 = 65576;
#[doc = "< Takes a @ref MMAL_PARAMETER_BOOLEAN_T"]
pub const MMAL_PARAMETER_HIGH_DYNAMIC_RANGE: _bindgen_ty_26 = 65577;
#[doc = "< Takes a @ref MMAL_PARAMETER_DRC_T"]
pub const MMAL_PARAMETER_DYNAMIC_RANGE_COMPRESSION: _bindgen_ty_26 = 65578;
#[doc = "< Takes a @ref MMAL_PARAMETER_ALGORITHM_CONTROL_T"]
pub const MMAL_PARAMETER_ALGORITHM_CONTROL: _bindgen_ty_26 = 65579;
#[doc = "< Takes a @ref MMAL_PARAMETER_RATIONAL_T"]
pub const MMAL_PARAMETER_SHARPNESS: _bindgen_ty_26 = 65580;
#[doc = "< Takes a @ref MMAL_PARAMETER_RATIONAL_T"]
pub const MMAL_PARAMETER_CONTRAST: _bindgen_ty_26 = 65581;
#[doc = "< Takes a @ref MMAL_PARAMETER_RATIONAL_T"]
pub const MMAL_PARAMETER_BRIGHTNESS: _bindgen_ty_26 = 65582;
#[doc = "< Takes a @ref MMAL_PARAMETER_RATIONAL_T"]
pub const MMAL_PARAMETER_SATURATION: _bindgen_ty_26 = 65583;
#[doc = "< Takes a @ref MMAL_PARAMETER_UINT32_T"]
pub const MMAL_PARAMETER_ISO: _bindgen_ty_26 = 65584;
#[doc = "< Takes a @ref MMAL_PARAMETER_BOOLEAN_T"]
pub const MMAL_PARAMETER_ANTISHAKE: _bindgen_ty_26 = 65585;
#[doc = "< Takes a @ref MMAL_PARAMETER_IMAGEFX_PARAMETERS_T"]
pub const MMAL_PARAMETER_IMAGE_EFFECT_PARAMETERS: _bindgen_ty_26 = 65586;
#[doc = "< Takes a @ref MMAL_PARAMETER_BOOLEAN_T"]
pub const MMAL_PARAMETER_CAMERA_BURST_CAPTURE: _bindgen_ty_26 = 65587;
#[doc = "< Takes a @ref MMAL_PARAMETER_UINT32_T"]
pub const MMAL_PARAMETER_CAMERA_MIN_ISO: _bindgen_ty_26 = 65588;
#[doc = "< Takes a @ref MMAL_PARAMETER_CAMERA_USE_CASE_T"]
pub const MMAL_PARAMETER_CAMERA_USE_CASE: _bindgen_ty_26 = 65589;
#[doc = "< Takes a @ref MMAL_PARAMETER_BOOLEAN_T"]
pub const MMAL_PARAMETER_CAPTURE_STATS_PASS: _bindgen_ty_26 = 65590;
#[doc = "< Takes a @ref MMAL_PARAMETER_UINT32_T"]
pub const MMAL_PARAMETER_CAMERA_CUSTOM_SENSOR_CONFIG: _bindgen_ty_26 = 65591;
#[doc = "< Takes a @ref MMAL_PARAMETER_BOOLEAN_T"]
pub const MMAL_PARAMETER_ENABLE_REGISTER_FILE: _bindgen_ty_26 = 65592;
#[doc = "< Takes a @ref MMAL_PARAMETER_BOOLEAN_T"]
pub const MMAL_PARAMETER_REGISTER_FAIL_IS_FATAL: _bindgen_ty_26 = 65593;
#[doc = "< Takes a @ref MMAL_PARAMETER_CONFIGFILE_T"]
pub const MMAL_PARAMETER_CONFIGFILE_REGISTERS: _bindgen_ty_26 = 65594;
#[doc = "< Takes a @ref MMAL_PARAMETER_CONFIGFILE_CHUNK_T"]
pub const MMAL_PARAMETER_CONFIGFILE_CHUNK_REGISTERS: _bindgen_ty_26 = 65595;
#[doc = "< Takes a @ref MMAL_PARAMETER_BOOLEAN_T"]
pub const MMAL_PARAMETER_JPEG_ATTACH_LOG: _bindgen_ty_26 = 65596;
#[doc = "< Takes a @ref MMAL_PARAMETER_ZEROSHUTTERLAG_T"]
pub const MMAL_PARAMETER_ZERO_SHUTTER_LAG: _bindgen_ty_26 = 65597;
#[doc = "< Takes a @ref MMAL_PARAMETER_FPS_RANGE_T"]
pub const MMAL_PARAMETER_FPS_RANGE: _bindgen_ty_26 = 65598;
#[doc = "< Takes a @ref MMAL_PARAMETER_INT32_T"]
pub const MMAL_PARAMETER_CAPTURE_EXPOSURE_COMP: _bindgen_ty_26 = 65599;
#[doc = "< Takes a @ref MMAL_PARAMETER_BOOLEAN_T"]
pub const MMAL_PARAMETER_SW_SHARPEN_DISABLE: _bindgen_ty_26 = 65600;
#[doc = "< Takes a @ref MMAL_PARAMETER_BOOLEAN_T"]
pub const MMAL_PARAMETER_FLASH_REQUIRED: _bindgen_ty_26 = 65601;
#[doc = "< Takes a @ref MMAL_PARAMETER_BOOLEAN_T"]
pub const MMAL_PARAMETER_SW_SATURATION_DISABLE: _bindgen_ty_26 = 65602;
#[doc = "< Takes a @ref MMAL_PARAMETER_UINT32_T"]
pub const MMAL_PARAMETER_SHUTTER_SPEED: _bindgen_ty_26 = 65603;
#[doc = "< Takes a @ref MMAL_PARAMETER_AWB_GAINS_T"]
pub const MMAL_PARAMETER_CUSTOM_AWB_GAINS: _bindgen_ty_26 = 65604;
#[doc = "< Takes a @ref MMAL_PARAMETER_CAMERA_SETTINGS_T"]
pub const MMAL_PARAMETER_CAMERA_SETTINGS: _bindgen_ty_26 = 65605;
#[doc = "< Takes a @ref MMAL_PARAMETER_PRIVACY_INDICATOR_T"]
pub const MMAL_PARAMETER_PRIVACY_INDICATOR: _bindgen_ty_26 = 65606;
#[doc = "< Takes a @ref MMAL_PARAMETER_BOOLEAN_T"]
pub const MMAL_PARAMETER_VIDEO_DENOISE: _bindgen_ty_26 = 65607;
#[doc = "< Takes a @ref MMAL_PARAMETER_BOOLEAN_T"]
pub const MMAL_PARAMETER_STILLS_DENOISE: _bindgen_ty_26 = 65608;
#[doc = "< Takes a @ref MMAL_PARAMETER_CAMERA_ANNOTATE_T"]
pub const MMAL_PARAMETER_ANNOTATE: _bindgen_ty_26 = 65609;
#[doc = "< Takes a @ref MMAL_PARAMETER_STEREOSCOPIC_MODE_T"]
pub const MMAL_PARAMETER_STEREOSCOPIC_MODE: _bindgen_ty_26 = 65610;
#[doc = "< Takes a @ref MMAL_PARAMETER_CAMERA_INTERFACE_T"]
pub const MMAL_PARAMETER_CAMERA_INTERFACE: _bindgen_ty_26 = 65611;
#[doc = "< Takes a @ref MMAL_PARAMETER_CAMERA_CLOCKING_MODE_T"]
pub const MMAL_PARAMETER_CAMERA_CLOCKING_MODE: _bindgen_ty_26 = 65612;
#[doc = "< Takes a @ref MMAL_PARAMETER_CAMERA_RX_CONFIG_T"]
pub const MMAL_PARAMETER_CAMERA_RX_CONFIG: _bindgen_ty_26 = 65613;
#[doc = "< Takes a @ref MMAL_PARAMETER_CAMERA_RX_TIMING_T"]
pub const MMAL_PARAMETER_CAMERA_RX_TIMING: _bindgen_ty_26 = 65614;
#[doc = "< Takes a @ref MMAL_PARAMETER_UINT32_T"]
pub const MMAL_PARAMETER_DPF_CONFIG: _bindgen_ty_26 = 65615;
#[doc = "< Takes a @ref MMAL_PARAMETER_UINT32_T"]
pub const MMAL_PARAMETER_JPEG_RESTART_INTERVAL: _bindgen_ty_26 = 65616;
#[doc = "< Takes a @ref MMAL_PARAMETER_UINT32_T"]
pub const MMAL_PARAMETER_CAMERA_ISP_BLOCK_OVERRIDE: _bindgen_ty_26 = 65617;
#[doc = "< Takes a @ref MMAL_PARAMETER_LENS_SHADING_T"]
pub const MMAL_PARAMETER_LENS_SHADING_OVERRIDE: _bindgen_ty_26 = 65618;
#[doc = "< Takes a @ref MMAL_PARAMETER_UINT32_T"]
pub const MMAL_PARAMETER_BLACK_LEVEL: _bindgen_ty_26 = 65619;
#[doc = "< Takes a @ref MMAL_PARAMETER_RESIZE_T"]
pub const MMAL_PARAMETER_RESIZE_PARAMS: _bindgen_ty_26 = 65620;
#[doc = "< Takes a @ref MMAL_PARAMETER_CROP_T"]
pub const MMAL_PARAMETER_CROP: _bindgen_ty_26 = 65621;
#[doc = "< Takes a @ref MMAL_PARAMETER_INT32_T"]
pub const MMAL_PARAMETER_OUTPUT_SHIFT: _bindgen_ty_26 = 65622;
#[doc = "< Takes a @ref MMAL_PARAMETER_INT32_T"]
pub const MMAL_PARAMETER_CCM_SHIFT: _bindgen_ty_26 = 65623;
#[doc = "< Takes a @ref MMAL_PARAMETER_CUSTOM_CCM_T"]
pub const MMAL_PARAMETER_CUSTOM_CCM: _bindgen_ty_26 = 65624;
#[doc = "< Takes a @ref MMAL_PARAMETER_RATIONAL_T"]
pub const MMAL_PARAMETER_ANALOG_GAIN: _bindgen_ty_26 = 65625;
#[doc = "< Takes a @ref MMAL_PARAMETER_RATIONAL_T"]
pub const MMAL_PARAMETER_DIGITAL_GAIN: _bindgen_ty_26 = 65626;
#[doc = " Camera-specific MMAL parameter IDs."]
#[doc = " @ingroup MMAL_PARAMETER_IDS"]
pub type _bindgen_ty_26 = u32;
#[doc = " Thumbnail configuration parameter type"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_THUMBNAIL_CONFIG_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    #[doc = "< Enable generation of thumbnails during still capture"]
    pub enable: u32,
    #[doc = "< Desired width of the thumbnail"]
    pub width: u32,
    #[doc = "< Desired height of the thumbnail"]
    pub height: u32,
    #[doc = "< Desired compression quality of the thumbnail"]
    pub quality: u32,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_THUMBNAIL_CONFIG_T() {
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_THUMBNAIL_CONFIG_T>(),
        24usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_THUMBNAIL_CONFIG_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_THUMBNAIL_CONFIG_T>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(MMAL_PARAMETER_THUMBNAIL_CONFIG_T)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_THUMBNAIL_CONFIG_T>())).hdr as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_THUMBNAIL_CONFIG_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_THUMBNAIL_CONFIG_T>())).enable as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_THUMBNAIL_CONFIG_T),
            "::",
            stringify!(enable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_THUMBNAIL_CONFIG_T>())).width as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_THUMBNAIL_CONFIG_T),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_THUMBNAIL_CONFIG_T>())).height as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_THUMBNAIL_CONFIG_T),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_THUMBNAIL_CONFIG_T>())).quality as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_THUMBNAIL_CONFIG_T),
            "::",
            stringify!(quality)
        )
    );
}
#[doc = " EXIF parameter type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_EXIF_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    #[doc = "< If 0, assume key is terminated by '=', otherwise length of key and treat data as binary"]
    pub keylen: u32,
    #[doc = "< Offset within data buffer of the start of the value. If 0, look for a \"key=value\" string"]
    pub value_offset: u32,
    #[doc = "< If 0, assume value is null-terminated, otherwise length of value and treat data as binary"]
    pub valuelen: u32,
    #[doc = "< EXIF key/value string. Variable length"]
    pub data: [u8; 1usize],
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_EXIF_T() {
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_EXIF_T>(),
        24usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_EXIF_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_EXIF_T>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_PARAMETER_EXIF_T))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_PARAMETER_EXIF_T>())).hdr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_EXIF_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_PARAMETER_EXIF_T>())).keylen as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_EXIF_T),
            "::",
            stringify!(keylen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_EXIF_T>())).value_offset as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_EXIF_T),
            "::",
            stringify!(value_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_PARAMETER_EXIF_T>())).valuelen as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_EXIF_T),
            "::",
            stringify!(valuelen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_PARAMETER_EXIF_T>())).data as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_EXIF_T),
            "::",
            stringify!(data)
        )
    );
}
pub const MMAL_PARAM_EXPOSUREMODE_T_MMAL_PARAM_EXPOSUREMODE_OFF: MMAL_PARAM_EXPOSUREMODE_T = 0;
pub const MMAL_PARAM_EXPOSUREMODE_T_MMAL_PARAM_EXPOSUREMODE_AUTO: MMAL_PARAM_EXPOSUREMODE_T = 1;
pub const MMAL_PARAM_EXPOSUREMODE_T_MMAL_PARAM_EXPOSUREMODE_NIGHT: MMAL_PARAM_EXPOSUREMODE_T = 2;
pub const MMAL_PARAM_EXPOSUREMODE_T_MMAL_PARAM_EXPOSUREMODE_NIGHTPREVIEW:
    MMAL_PARAM_EXPOSUREMODE_T = 3;
pub const MMAL_PARAM_EXPOSUREMODE_T_MMAL_PARAM_EXPOSUREMODE_BACKLIGHT: MMAL_PARAM_EXPOSUREMODE_T =
    4;
pub const MMAL_PARAM_EXPOSUREMODE_T_MMAL_PARAM_EXPOSUREMODE_SPOTLIGHT: MMAL_PARAM_EXPOSUREMODE_T =
    5;
pub const MMAL_PARAM_EXPOSUREMODE_T_MMAL_PARAM_EXPOSUREMODE_SPORTS: MMAL_PARAM_EXPOSUREMODE_T = 6;
pub const MMAL_PARAM_EXPOSUREMODE_T_MMAL_PARAM_EXPOSUREMODE_SNOW: MMAL_PARAM_EXPOSUREMODE_T = 7;
pub const MMAL_PARAM_EXPOSUREMODE_T_MMAL_PARAM_EXPOSUREMODE_BEACH: MMAL_PARAM_EXPOSUREMODE_T = 8;
pub const MMAL_PARAM_EXPOSUREMODE_T_MMAL_PARAM_EXPOSUREMODE_VERYLONG: MMAL_PARAM_EXPOSUREMODE_T = 9;
pub const MMAL_PARAM_EXPOSUREMODE_T_MMAL_PARAM_EXPOSUREMODE_FIXEDFPS: MMAL_PARAM_EXPOSUREMODE_T =
    10;
pub const MMAL_PARAM_EXPOSUREMODE_T_MMAL_PARAM_EXPOSUREMODE_ANTISHAKE: MMAL_PARAM_EXPOSUREMODE_T =
    11;
pub const MMAL_PARAM_EXPOSUREMODE_T_MMAL_PARAM_EXPOSUREMODE_FIREWORKS: MMAL_PARAM_EXPOSUREMODE_T =
    12;
pub const MMAL_PARAM_EXPOSUREMODE_T_MMAL_PARAM_EXPOSUREMODE_MAX: MMAL_PARAM_EXPOSUREMODE_T =
    2147483647;
#[doc = " Exposure modes."]
pub type MMAL_PARAM_EXPOSUREMODE_T = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_EXPOSUREMODE_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    #[doc = "< exposure mode"]
    pub value: MMAL_PARAM_EXPOSUREMODE_T,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_EXPOSUREMODE_T() {
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_EXPOSUREMODE_T>(),
        12usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_EXPOSUREMODE_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_EXPOSUREMODE_T>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_PARAMETER_EXPOSUREMODE_T))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_EXPOSUREMODE_T>())).hdr as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_EXPOSUREMODE_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_EXPOSUREMODE_T>())).value as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_EXPOSUREMODE_T),
            "::",
            stringify!(value)
        )
    );
}
pub const MMAL_PARAM_EXPOSUREMETERINGMODE_T_MMAL_PARAM_EXPOSUREMETERINGMODE_AVERAGE:
    MMAL_PARAM_EXPOSUREMETERINGMODE_T = 0;
pub const MMAL_PARAM_EXPOSUREMETERINGMODE_T_MMAL_PARAM_EXPOSUREMETERINGMODE_SPOT:
    MMAL_PARAM_EXPOSUREMETERINGMODE_T = 1;
pub const MMAL_PARAM_EXPOSUREMETERINGMODE_T_MMAL_PARAM_EXPOSUREMETERINGMODE_BACKLIT:
    MMAL_PARAM_EXPOSUREMETERINGMODE_T = 2;
pub const MMAL_PARAM_EXPOSUREMETERINGMODE_T_MMAL_PARAM_EXPOSUREMETERINGMODE_MATRIX:
    MMAL_PARAM_EXPOSUREMETERINGMODE_T = 3;
pub const MMAL_PARAM_EXPOSUREMETERINGMODE_T_MMAL_PARAM_EXPOSUREMETERINGMODE_MAX:
    MMAL_PARAM_EXPOSUREMETERINGMODE_T = 2147483647;
pub type MMAL_PARAM_EXPOSUREMETERINGMODE_T = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_EXPOSUREMETERINGMODE_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    #[doc = "< metering mode"]
    pub value: MMAL_PARAM_EXPOSUREMETERINGMODE_T,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_EXPOSUREMETERINGMODE_T() {
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_EXPOSUREMETERINGMODE_T>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(MMAL_PARAMETER_EXPOSUREMETERINGMODE_T)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_EXPOSUREMETERINGMODE_T>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(MMAL_PARAMETER_EXPOSUREMETERINGMODE_T)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_EXPOSUREMETERINGMODE_T>())).hdr as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_EXPOSUREMETERINGMODE_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_EXPOSUREMETERINGMODE_T>())).value as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_EXPOSUREMETERINGMODE_T),
            "::",
            stringify!(value)
        )
    );
}
pub const MMAL_PARAM_AWBMODE_T_MMAL_PARAM_AWBMODE_OFF: MMAL_PARAM_AWBMODE_T = 0;
pub const MMAL_PARAM_AWBMODE_T_MMAL_PARAM_AWBMODE_AUTO: MMAL_PARAM_AWBMODE_T = 1;
pub const MMAL_PARAM_AWBMODE_T_MMAL_PARAM_AWBMODE_SUNLIGHT: MMAL_PARAM_AWBMODE_T = 2;
pub const MMAL_PARAM_AWBMODE_T_MMAL_PARAM_AWBMODE_CLOUDY: MMAL_PARAM_AWBMODE_T = 3;
pub const MMAL_PARAM_AWBMODE_T_MMAL_PARAM_AWBMODE_SHADE: MMAL_PARAM_AWBMODE_T = 4;
pub const MMAL_PARAM_AWBMODE_T_MMAL_PARAM_AWBMODE_TUNGSTEN: MMAL_PARAM_AWBMODE_T = 5;
pub const MMAL_PARAM_AWBMODE_T_MMAL_PARAM_AWBMODE_FLUORESCENT: MMAL_PARAM_AWBMODE_T = 6;
pub const MMAL_PARAM_AWBMODE_T_MMAL_PARAM_AWBMODE_INCANDESCENT: MMAL_PARAM_AWBMODE_T = 7;
pub const MMAL_PARAM_AWBMODE_T_MMAL_PARAM_AWBMODE_FLASH: MMAL_PARAM_AWBMODE_T = 8;
pub const MMAL_PARAM_AWBMODE_T_MMAL_PARAM_AWBMODE_HORIZON: MMAL_PARAM_AWBMODE_T = 9;
pub const MMAL_PARAM_AWBMODE_T_MMAL_PARAM_AWBMODE_GREYWORLD: MMAL_PARAM_AWBMODE_T = 10;
pub const MMAL_PARAM_AWBMODE_T_MMAL_PARAM_AWBMODE_MAX: MMAL_PARAM_AWBMODE_T = 2147483647;
#[doc = " AWB parameter modes."]
pub type MMAL_PARAM_AWBMODE_T = u32;
#[doc = " AWB parameter type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_AWBMODE_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    #[doc = "< AWB mode"]
    pub value: MMAL_PARAM_AWBMODE_T,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_AWBMODE_T() {
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_AWBMODE_T>(),
        12usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_AWBMODE_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_AWBMODE_T>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_PARAMETER_AWBMODE_T))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_PARAMETER_AWBMODE_T>())).hdr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_AWBMODE_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_PARAMETER_AWBMODE_T>())).value as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_AWBMODE_T),
            "::",
            stringify!(value)
        )
    );
}
pub const MMAL_PARAM_IMAGEFX_T_MMAL_PARAM_IMAGEFX_NONE: MMAL_PARAM_IMAGEFX_T = 0;
pub const MMAL_PARAM_IMAGEFX_T_MMAL_PARAM_IMAGEFX_NEGATIVE: MMAL_PARAM_IMAGEFX_T = 1;
pub const MMAL_PARAM_IMAGEFX_T_MMAL_PARAM_IMAGEFX_SOLARIZE: MMAL_PARAM_IMAGEFX_T = 2;
pub const MMAL_PARAM_IMAGEFX_T_MMAL_PARAM_IMAGEFX_POSTERIZE: MMAL_PARAM_IMAGEFX_T = 3;
pub const MMAL_PARAM_IMAGEFX_T_MMAL_PARAM_IMAGEFX_WHITEBOARD: MMAL_PARAM_IMAGEFX_T = 4;
pub const MMAL_PARAM_IMAGEFX_T_MMAL_PARAM_IMAGEFX_BLACKBOARD: MMAL_PARAM_IMAGEFX_T = 5;
pub const MMAL_PARAM_IMAGEFX_T_MMAL_PARAM_IMAGEFX_SKETCH: MMAL_PARAM_IMAGEFX_T = 6;
pub const MMAL_PARAM_IMAGEFX_T_MMAL_PARAM_IMAGEFX_DENOISE: MMAL_PARAM_IMAGEFX_T = 7;
pub const MMAL_PARAM_IMAGEFX_T_MMAL_PARAM_IMAGEFX_EMBOSS: MMAL_PARAM_IMAGEFX_T = 8;
pub const MMAL_PARAM_IMAGEFX_T_MMAL_PARAM_IMAGEFX_OILPAINT: MMAL_PARAM_IMAGEFX_T = 9;
pub const MMAL_PARAM_IMAGEFX_T_MMAL_PARAM_IMAGEFX_HATCH: MMAL_PARAM_IMAGEFX_T = 10;
pub const MMAL_PARAM_IMAGEFX_T_MMAL_PARAM_IMAGEFX_GPEN: MMAL_PARAM_IMAGEFX_T = 11;
pub const MMAL_PARAM_IMAGEFX_T_MMAL_PARAM_IMAGEFX_PASTEL: MMAL_PARAM_IMAGEFX_T = 12;
pub const MMAL_PARAM_IMAGEFX_T_MMAL_PARAM_IMAGEFX_WATERCOLOUR: MMAL_PARAM_IMAGEFX_T = 13;
pub const MMAL_PARAM_IMAGEFX_T_MMAL_PARAM_IMAGEFX_FILM: MMAL_PARAM_IMAGEFX_T = 14;
pub const MMAL_PARAM_IMAGEFX_T_MMAL_PARAM_IMAGEFX_BLUR: MMAL_PARAM_IMAGEFX_T = 15;
pub const MMAL_PARAM_IMAGEFX_T_MMAL_PARAM_IMAGEFX_SATURATION: MMAL_PARAM_IMAGEFX_T = 16;
pub const MMAL_PARAM_IMAGEFX_T_MMAL_PARAM_IMAGEFX_COLOURSWAP: MMAL_PARAM_IMAGEFX_T = 17;
pub const MMAL_PARAM_IMAGEFX_T_MMAL_PARAM_IMAGEFX_WASHEDOUT: MMAL_PARAM_IMAGEFX_T = 18;
pub const MMAL_PARAM_IMAGEFX_T_MMAL_PARAM_IMAGEFX_POSTERISE: MMAL_PARAM_IMAGEFX_T = 19;
pub const MMAL_PARAM_IMAGEFX_T_MMAL_PARAM_IMAGEFX_COLOURPOINT: MMAL_PARAM_IMAGEFX_T = 20;
pub const MMAL_PARAM_IMAGEFX_T_MMAL_PARAM_IMAGEFX_COLOURBALANCE: MMAL_PARAM_IMAGEFX_T = 21;
pub const MMAL_PARAM_IMAGEFX_T_MMAL_PARAM_IMAGEFX_CARTOON: MMAL_PARAM_IMAGEFX_T = 22;
pub const MMAL_PARAM_IMAGEFX_T_MMAL_PARAM_IMAGEFX_DEINTERLACE_DOUBLE: MMAL_PARAM_IMAGEFX_T = 23;
pub const MMAL_PARAM_IMAGEFX_T_MMAL_PARAM_IMAGEFX_DEINTERLACE_ADV: MMAL_PARAM_IMAGEFX_T = 24;
pub const MMAL_PARAM_IMAGEFX_T_MMAL_PARAM_IMAGEFX_DEINTERLACE_FAST: MMAL_PARAM_IMAGEFX_T = 25;
pub const MMAL_PARAM_IMAGEFX_T_MMAL_PARAM_IMAGEFX_MAX: MMAL_PARAM_IMAGEFX_T = 2147483647;
#[doc = " Image effect"]
pub type MMAL_PARAM_IMAGEFX_T = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_IMAGEFX_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    #[doc = "< Image effect mode"]
    pub value: MMAL_PARAM_IMAGEFX_T,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_IMAGEFX_T() {
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_IMAGEFX_T>(),
        12usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_IMAGEFX_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_IMAGEFX_T>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_PARAMETER_IMAGEFX_T))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_PARAMETER_IMAGEFX_T>())).hdr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_IMAGEFX_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_PARAMETER_IMAGEFX_T>())).value as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_IMAGEFX_T),
            "::",
            stringify!(value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_IMAGEFX_PARAMETERS_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    #[doc = "< Image effect mode"]
    pub effect: MMAL_PARAM_IMAGEFX_T,
    #[doc = "< Number of used elements in"]
    pub num_effect_params: u32,
    #[doc = "< Array of parameters"]
    pub effect_parameter: [u32; 6usize],
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_IMAGEFX_PARAMETERS_T() {
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_IMAGEFX_PARAMETERS_T>(),
        40usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_IMAGEFX_PARAMETERS_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_IMAGEFX_PARAMETERS_T>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(MMAL_PARAMETER_IMAGEFX_PARAMETERS_T)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_IMAGEFX_PARAMETERS_T>())).hdr as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_IMAGEFX_PARAMETERS_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_IMAGEFX_PARAMETERS_T>())).effect as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_IMAGEFX_PARAMETERS_T),
            "::",
            stringify!(effect)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_IMAGEFX_PARAMETERS_T>())).num_effect_params
                as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_IMAGEFX_PARAMETERS_T),
            "::",
            stringify!(num_effect_params)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_IMAGEFX_PARAMETERS_T>())).effect_parameter
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_IMAGEFX_PARAMETERS_T),
            "::",
            stringify!(effect_parameter)
        )
    );
}
#[doc = " Colour effect parameter type"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_COLOURFX_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    pub enable: i32,
    pub u: u32,
    pub v: u32,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_COLOURFX_T() {
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_COLOURFX_T>(),
        20usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_COLOURFX_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_COLOURFX_T>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_PARAMETER_COLOURFX_T))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_PARAMETER_COLOURFX_T>())).hdr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_COLOURFX_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_COLOURFX_T>())).enable as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_COLOURFX_T),
            "::",
            stringify!(enable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_PARAMETER_COLOURFX_T>())).u as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_COLOURFX_T),
            "::",
            stringify!(u)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_PARAMETER_COLOURFX_T>())).v as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_COLOURFX_T),
            "::",
            stringify!(v)
        )
    );
}
#[doc = "< Frames do not have STCs, as needed in OpenMAX/IL"]
pub const MMAL_CAMERA_STC_MODE_T_MMAL_PARAM_STC_MODE_OFF: MMAL_CAMERA_STC_MODE_T = 0;
#[doc = "< Use raw clock STC, needed for true pause/resume support"]
pub const MMAL_CAMERA_STC_MODE_T_MMAL_PARAM_STC_MODE_RAW: MMAL_CAMERA_STC_MODE_T = 1;
#[doc = "< Start the STC from the start of capture, only for quick demo code"]
pub const MMAL_CAMERA_STC_MODE_T_MMAL_PARAM_STC_MODE_COOKED: MMAL_CAMERA_STC_MODE_T = 2;
pub const MMAL_CAMERA_STC_MODE_T_MMAL_PARAM_STC_MODE_MAX: MMAL_CAMERA_STC_MODE_T = 2147483647;
pub type MMAL_CAMERA_STC_MODE_T = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_CAMERA_STC_MODE_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    pub value: MMAL_CAMERA_STC_MODE_T,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_CAMERA_STC_MODE_T() {
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_CAMERA_STC_MODE_T>(),
        12usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_CAMERA_STC_MODE_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_CAMERA_STC_MODE_T>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(MMAL_PARAMETER_CAMERA_STC_MODE_T)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CAMERA_STC_MODE_T>())).hdr as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_STC_MODE_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CAMERA_STC_MODE_T>())).value as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_STC_MODE_T),
            "::",
            stringify!(value)
        )
    );
}
pub const MMAL_PARAM_FLICKERAVOID_T_MMAL_PARAM_FLICKERAVOID_OFF: MMAL_PARAM_FLICKERAVOID_T = 0;
pub const MMAL_PARAM_FLICKERAVOID_T_MMAL_PARAM_FLICKERAVOID_AUTO: MMAL_PARAM_FLICKERAVOID_T = 1;
pub const MMAL_PARAM_FLICKERAVOID_T_MMAL_PARAM_FLICKERAVOID_50HZ: MMAL_PARAM_FLICKERAVOID_T = 2;
pub const MMAL_PARAM_FLICKERAVOID_T_MMAL_PARAM_FLICKERAVOID_60HZ: MMAL_PARAM_FLICKERAVOID_T = 3;
pub const MMAL_PARAM_FLICKERAVOID_T_MMAL_PARAM_FLICKERAVOID_MAX: MMAL_PARAM_FLICKERAVOID_T =
    2147483647;
pub type MMAL_PARAM_FLICKERAVOID_T = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_FLICKERAVOID_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    #[doc = "< Flicker avoidance mode"]
    pub value: MMAL_PARAM_FLICKERAVOID_T,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_FLICKERAVOID_T() {
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_FLICKERAVOID_T>(),
        12usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_FLICKERAVOID_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_FLICKERAVOID_T>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_PARAMETER_FLICKERAVOID_T))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_FLICKERAVOID_T>())).hdr as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_FLICKERAVOID_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_FLICKERAVOID_T>())).value as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_FLICKERAVOID_T),
            "::",
            stringify!(value)
        )
    );
}
pub const MMAL_PARAM_FLASH_T_MMAL_PARAM_FLASH_OFF: MMAL_PARAM_FLASH_T = 0;
pub const MMAL_PARAM_FLASH_T_MMAL_PARAM_FLASH_AUTO: MMAL_PARAM_FLASH_T = 1;
pub const MMAL_PARAM_FLASH_T_MMAL_PARAM_FLASH_ON: MMAL_PARAM_FLASH_T = 2;
pub const MMAL_PARAM_FLASH_T_MMAL_PARAM_FLASH_REDEYE: MMAL_PARAM_FLASH_T = 3;
pub const MMAL_PARAM_FLASH_T_MMAL_PARAM_FLASH_FILLIN: MMAL_PARAM_FLASH_T = 4;
pub const MMAL_PARAM_FLASH_T_MMAL_PARAM_FLASH_TORCH: MMAL_PARAM_FLASH_T = 5;
pub const MMAL_PARAM_FLASH_T_MMAL_PARAM_FLASH_MAX: MMAL_PARAM_FLASH_T = 2147483647;
pub type MMAL_PARAM_FLASH_T = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_FLASH_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    #[doc = "< Flash mode"]
    pub value: MMAL_PARAM_FLASH_T,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_FLASH_T() {
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_FLASH_T>(),
        12usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_FLASH_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_FLASH_T>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_PARAMETER_FLASH_T))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_PARAMETER_FLASH_T>())).hdr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_FLASH_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_PARAMETER_FLASH_T>())).value as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_FLASH_T),
            "::",
            stringify!(value)
        )
    );
}
pub const MMAL_PARAM_REDEYE_T_MMAL_PARAM_REDEYE_OFF: MMAL_PARAM_REDEYE_T = 0;
pub const MMAL_PARAM_REDEYE_T_MMAL_PARAM_REDEYE_ON: MMAL_PARAM_REDEYE_T = 1;
pub const MMAL_PARAM_REDEYE_T_MMAL_PARAM_REDEYE_SIMPLE: MMAL_PARAM_REDEYE_T = 2;
pub const MMAL_PARAM_REDEYE_T_MMAL_PARAM_REDEYE_MAX: MMAL_PARAM_REDEYE_T = 2147483647;
pub type MMAL_PARAM_REDEYE_T = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_REDEYE_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    #[doc = "< Red eye reduction mode"]
    pub value: MMAL_PARAM_REDEYE_T,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_REDEYE_T() {
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_REDEYE_T>(),
        12usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_REDEYE_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_REDEYE_T>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_PARAMETER_REDEYE_T))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_PARAMETER_REDEYE_T>())).hdr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_REDEYE_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_PARAMETER_REDEYE_T>())).value as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_REDEYE_T),
            "::",
            stringify!(value)
        )
    );
}
pub const MMAL_PARAM_FOCUS_T_MMAL_PARAM_FOCUS_AUTO: MMAL_PARAM_FOCUS_T = 0;
pub const MMAL_PARAM_FOCUS_T_MMAL_PARAM_FOCUS_AUTO_NEAR: MMAL_PARAM_FOCUS_T = 1;
pub const MMAL_PARAM_FOCUS_T_MMAL_PARAM_FOCUS_AUTO_MACRO: MMAL_PARAM_FOCUS_T = 2;
pub const MMAL_PARAM_FOCUS_T_MMAL_PARAM_FOCUS_CAF: MMAL_PARAM_FOCUS_T = 3;
pub const MMAL_PARAM_FOCUS_T_MMAL_PARAM_FOCUS_CAF_NEAR: MMAL_PARAM_FOCUS_T = 4;
pub const MMAL_PARAM_FOCUS_T_MMAL_PARAM_FOCUS_FIXED_INFINITY: MMAL_PARAM_FOCUS_T = 5;
pub const MMAL_PARAM_FOCUS_T_MMAL_PARAM_FOCUS_FIXED_HYPERFOCAL: MMAL_PARAM_FOCUS_T = 6;
pub const MMAL_PARAM_FOCUS_T_MMAL_PARAM_FOCUS_FIXED_NEAR: MMAL_PARAM_FOCUS_T = 7;
pub const MMAL_PARAM_FOCUS_T_MMAL_PARAM_FOCUS_FIXED_MACRO: MMAL_PARAM_FOCUS_T = 8;
pub const MMAL_PARAM_FOCUS_T_MMAL_PARAM_FOCUS_EDOF: MMAL_PARAM_FOCUS_T = 9;
pub const MMAL_PARAM_FOCUS_T_MMAL_PARAM_FOCUS_CAF_MACRO: MMAL_PARAM_FOCUS_T = 10;
pub const MMAL_PARAM_FOCUS_T_MMAL_PARAM_FOCUS_CAF_FAST: MMAL_PARAM_FOCUS_T = 11;
pub const MMAL_PARAM_FOCUS_T_MMAL_PARAM_FOCUS_CAF_NEAR_FAST: MMAL_PARAM_FOCUS_T = 12;
pub const MMAL_PARAM_FOCUS_T_MMAL_PARAM_FOCUS_CAF_MACRO_FAST: MMAL_PARAM_FOCUS_T = 13;
pub const MMAL_PARAM_FOCUS_T_MMAL_PARAM_FOCUS_FIXED_CURRENT: MMAL_PARAM_FOCUS_T = 14;
pub const MMAL_PARAM_FOCUS_T_MMAL_PARAM_FOCUS_MAX: MMAL_PARAM_FOCUS_T = 2147483647;
pub type MMAL_PARAM_FOCUS_T = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_FOCUS_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    #[doc = "< Focus mode"]
    pub value: MMAL_PARAM_FOCUS_T,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_FOCUS_T() {
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_FOCUS_T>(),
        12usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_FOCUS_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_FOCUS_T>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_PARAMETER_FOCUS_T))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_PARAMETER_FOCUS_T>())).hdr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_FOCUS_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_PARAMETER_FOCUS_T>())).value as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_FOCUS_T),
            "::",
            stringify!(value)
        )
    );
}
pub const MMAL_PARAM_CAPTURE_STATUS_T_MMAL_PARAM_CAPTURE_STATUS_NOT_CAPTURING:
    MMAL_PARAM_CAPTURE_STATUS_T = 0;
pub const MMAL_PARAM_CAPTURE_STATUS_T_MMAL_PARAM_CAPTURE_STATUS_CAPTURE_STARTED:
    MMAL_PARAM_CAPTURE_STATUS_T = 1;
pub const MMAL_PARAM_CAPTURE_STATUS_T_MMAL_PARAM_CAPTURE_STATUS_CAPTURE_ENDED:
    MMAL_PARAM_CAPTURE_STATUS_T = 2;
pub const MMAL_PARAM_CAPTURE_STATUS_T_MMAL_PARAM_CAPTURE_STATUS_MAX: MMAL_PARAM_CAPTURE_STATUS_T =
    2147483647;
pub type MMAL_PARAM_CAPTURE_STATUS_T = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_CAPTURE_STATUS_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    #[doc = "< Capture status"]
    pub status: MMAL_PARAM_CAPTURE_STATUS_T,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_CAPTURE_STATUS_T() {
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_CAPTURE_STATUS_T>(),
        12usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_CAPTURE_STATUS_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_CAPTURE_STATUS_T>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_PARAMETER_CAPTURE_STATUS_T))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CAPTURE_STATUS_T>())).hdr as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAPTURE_STATUS_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CAPTURE_STATUS_T>())).status as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAPTURE_STATUS_T),
            "::",
            stringify!(status)
        )
    );
}
pub const MMAL_PARAM_FOCUS_STATUS_T_MMAL_PARAM_FOCUS_STATUS_OFF: MMAL_PARAM_FOCUS_STATUS_T = 0;
pub const MMAL_PARAM_FOCUS_STATUS_T_MMAL_PARAM_FOCUS_STATUS_REQUEST: MMAL_PARAM_FOCUS_STATUS_T = 1;
pub const MMAL_PARAM_FOCUS_STATUS_T_MMAL_PARAM_FOCUS_STATUS_REACHED: MMAL_PARAM_FOCUS_STATUS_T = 2;
pub const MMAL_PARAM_FOCUS_STATUS_T_MMAL_PARAM_FOCUS_STATUS_UNABLE_TO_REACH:
    MMAL_PARAM_FOCUS_STATUS_T = 3;
pub const MMAL_PARAM_FOCUS_STATUS_T_MMAL_PARAM_FOCUS_STATUS_LOST: MMAL_PARAM_FOCUS_STATUS_T = 4;
pub const MMAL_PARAM_FOCUS_STATUS_T_MMAL_PARAM_FOCUS_STATUS_CAF_MOVING: MMAL_PARAM_FOCUS_STATUS_T =
    5;
pub const MMAL_PARAM_FOCUS_STATUS_T_MMAL_PARAM_FOCUS_STATUS_CAF_SUCCESS: MMAL_PARAM_FOCUS_STATUS_T =
    6;
pub const MMAL_PARAM_FOCUS_STATUS_T_MMAL_PARAM_FOCUS_STATUS_CAF_FAILED: MMAL_PARAM_FOCUS_STATUS_T =
    7;
pub const MMAL_PARAM_FOCUS_STATUS_T_MMAL_PARAM_FOCUS_STATUS_MANUAL_MOVING:
    MMAL_PARAM_FOCUS_STATUS_T = 8;
pub const MMAL_PARAM_FOCUS_STATUS_T_MMAL_PARAM_FOCUS_STATUS_MANUAL_REACHED:
    MMAL_PARAM_FOCUS_STATUS_T = 9;
pub const MMAL_PARAM_FOCUS_STATUS_T_MMAL_PARAM_FOCUS_STATUS_CAF_WATCHING:
    MMAL_PARAM_FOCUS_STATUS_T = 10;
pub const MMAL_PARAM_FOCUS_STATUS_T_MMAL_PARAM_FOCUS_STATUS_CAF_SCENE_CHANGED:
    MMAL_PARAM_FOCUS_STATUS_T = 11;
pub const MMAL_PARAM_FOCUS_STATUS_T_MMAL_PARAM_FOCUS_STATUS_MAX: MMAL_PARAM_FOCUS_STATUS_T =
    2147483647;
pub type MMAL_PARAM_FOCUS_STATUS_T = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_FOCUS_STATUS_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    #[doc = "< Focus status"]
    pub status: MMAL_PARAM_FOCUS_STATUS_T,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_FOCUS_STATUS_T() {
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_FOCUS_STATUS_T>(),
        12usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_FOCUS_STATUS_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_FOCUS_STATUS_T>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_PARAMETER_FOCUS_STATUS_T))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_FOCUS_STATUS_T>())).hdr as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_FOCUS_STATUS_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_FOCUS_STATUS_T>())).status as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_FOCUS_STATUS_T),
            "::",
            stringify!(status)
        )
    );
}
#[doc = "< Disables face detection"]
pub const MMAL_PARAM_FACE_TRACK_MODE_T_MMAL_PARAM_FACE_DETECT_NONE: MMAL_PARAM_FACE_TRACK_MODE_T =
    0;
#[doc = "< Enables face detection"]
pub const MMAL_PARAM_FACE_TRACK_MODE_T_MMAL_PARAM_FACE_DETECT_ON: MMAL_PARAM_FACE_TRACK_MODE_T = 1;
pub const MMAL_PARAM_FACE_TRACK_MODE_T_MMAL_PARAM_FACE_DETECT_MAX: MMAL_PARAM_FACE_TRACK_MODE_T =
    2147483647;
pub type MMAL_PARAM_FACE_TRACK_MODE_T = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_FACE_TRACK_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    pub mode: MMAL_PARAM_FACE_TRACK_MODE_T,
    pub maxRegions: u32,
    pub frames: u32,
    pub quality: u32,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_FACE_TRACK_T() {
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_FACE_TRACK_T>(),
        24usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_FACE_TRACK_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_FACE_TRACK_T>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_PARAMETER_FACE_TRACK_T))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_PARAMETER_FACE_TRACK_T>())).hdr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_FACE_TRACK_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_FACE_TRACK_T>())).mode as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_FACE_TRACK_T),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_FACE_TRACK_T>())).maxRegions as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_FACE_TRACK_T),
            "::",
            stringify!(maxRegions)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_FACE_TRACK_T>())).frames as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_FACE_TRACK_T),
            "::",
            stringify!(frames)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_FACE_TRACK_T>())).quality as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_FACE_TRACK_T),
            "::",
            stringify!(quality)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_FACE_TRACK_FACE_T {
    #[doc = "< Face ID. Should remain the same whilst the face is detected to remain in the scene"]
    pub face_id: i32,
    #[doc = "< Confidence of the face detection. Range 1-100 (1=unsure, 100=positive)."]
    pub score: i32,
    #[doc = "< Rectangle around the whole face"]
    pub face_rect: MMAL_RECT_T,
    #[doc = "< Rectangle around the eyes ([0] = left eye, [1] = right eye)"]
    pub eye_rect: [MMAL_RECT_T; 2usize],
    #[doc = "< Rectangle around the mouth"]
    pub mouth_rect: MMAL_RECT_T,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_FACE_TRACK_FACE_T() {
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_FACE_TRACK_FACE_T>(),
        72usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_FACE_TRACK_FACE_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_FACE_TRACK_FACE_T>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(MMAL_PARAMETER_FACE_TRACK_FACE_T)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_FACE_TRACK_FACE_T>())).face_id as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_FACE_TRACK_FACE_T),
            "::",
            stringify!(face_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_FACE_TRACK_FACE_T>())).score as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_FACE_TRACK_FACE_T),
            "::",
            stringify!(score)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_FACE_TRACK_FACE_T>())).face_rect as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_FACE_TRACK_FACE_T),
            "::",
            stringify!(face_rect)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_FACE_TRACK_FACE_T>())).eye_rect as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_FACE_TRACK_FACE_T),
            "::",
            stringify!(eye_rect)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_FACE_TRACK_FACE_T>())).mouth_rect as *const _
                as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_FACE_TRACK_FACE_T),
            "::",
            stringify!(mouth_rect)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_FACE_TRACK_RESULTS_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    #[doc = "< Number of faces detected"]
    pub num_faces: u32,
    #[doc = "< Width of the frame on which the faces were detected (allows scaling)"]
    pub frame_width: u32,
    #[doc = "< Height of the frame on which the faces were detected (allows scaling)"]
    pub frame_height: u32,
    #[doc = "< Face information (variable length array"]
    pub faces: [MMAL_PARAMETER_FACE_TRACK_FACE_T; 1usize],
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_FACE_TRACK_RESULTS_T() {
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_FACE_TRACK_RESULTS_T>(),
        92usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_FACE_TRACK_RESULTS_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_FACE_TRACK_RESULTS_T>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(MMAL_PARAMETER_FACE_TRACK_RESULTS_T)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_FACE_TRACK_RESULTS_T>())).hdr as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_FACE_TRACK_RESULTS_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_FACE_TRACK_RESULTS_T>())).num_faces as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_FACE_TRACK_RESULTS_T),
            "::",
            stringify!(num_faces)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_FACE_TRACK_RESULTS_T>())).frame_width as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_FACE_TRACK_RESULTS_T),
            "::",
            stringify!(frame_width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_FACE_TRACK_RESULTS_T>())).frame_height as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_FACE_TRACK_RESULTS_T),
            "::",
            stringify!(frame_height)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_FACE_TRACK_RESULTS_T>())).faces as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_FACE_TRACK_RESULTS_T),
            "::",
            stringify!(faces)
        )
    );
}
pub mod MMAL_PARAMETER_CAMERA_CONFIG_TIMESTAMP_MODE_T {
    pub type Type = u32;
    #[doc = "< Always timestamp frames as 0"]
    pub const MMAL_PARAM_TIMESTAMP_MODE_ZERO: Type = 0;
    #[doc = "< Use the raw STC value for the frame timestamp"]
    pub const MMAL_PARAM_TIMESTAMP_MODE_RAW_STC: Type = 1;
    #[doc = "< Use the STC timestamp but subtract the timestamp"]
    #[doc = " of the first frame sent to give a zero based timestamp."]
    pub const MMAL_PARAM_TIMESTAMP_MODE_RESET_STC: Type = 2;
    pub const MMAL_PARAM_TIMESTAMP_MODE_MAX: Type = 2147483647;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_CAMERA_CONFIG_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    #[doc = "< Max size of stills capture"]
    pub max_stills_w: u32,
    pub max_stills_h: u32,
    #[doc = "< Allow YUV422 stills capture"]
    pub stills_yuv422: u32,
    #[doc = "< Continuous or one shot stills captures."]
    pub one_shot_stills: u32,
    #[doc = "< Max size of the preview or video capture frames"]
    pub max_preview_video_w: u32,
    pub max_preview_video_h: u32,
    pub num_preview_video_frames: u32,
    #[doc = "< Sets the height of the circular buffer for stills capture."]
    pub stills_capture_circular_buffer_height: u32,
    #[doc = "< Allows preview/encode to resume as fast as possible after the stills input frame"]
    #[doc = " has been received, and then processes the still frame in the background"]
    #[doc = " whilst preview/encode has resumed."]
    #[doc = " Actual mode is controlled by MMAL_PARAMETER_CAPTURE_MODE."]
    pub fast_preview_resume: u32,
    pub use_stc_timestamp: MMAL_PARAMETER_CAMERA_CONFIG_TIMESTAMP_MODE_T::Type,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_CAMERA_CONFIG_T() {
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_CAMERA_CONFIG_T>(),
        48usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_CAMERA_CONFIG_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_CAMERA_CONFIG_T>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_PARAMETER_CAMERA_CONFIG_T))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CAMERA_CONFIG_T>())).hdr as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_CONFIG_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CAMERA_CONFIG_T>())).max_stills_w as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_CONFIG_T),
            "::",
            stringify!(max_stills_w)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CAMERA_CONFIG_T>())).max_stills_h as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_CONFIG_T),
            "::",
            stringify!(max_stills_h)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CAMERA_CONFIG_T>())).stills_yuv422 as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_CONFIG_T),
            "::",
            stringify!(stills_yuv422)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CAMERA_CONFIG_T>())).one_shot_stills as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_CONFIG_T),
            "::",
            stringify!(one_shot_stills)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CAMERA_CONFIG_T>())).max_preview_video_w
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_CONFIG_T),
            "::",
            stringify!(max_preview_video_w)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CAMERA_CONFIG_T>())).max_preview_video_h
                as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_CONFIG_T),
            "::",
            stringify!(max_preview_video_h)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CAMERA_CONFIG_T>())).num_preview_video_frames
                as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_CONFIG_T),
            "::",
            stringify!(num_preview_video_frames)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CAMERA_CONFIG_T>()))
                .stills_capture_circular_buffer_height as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_CONFIG_T),
            "::",
            stringify!(stills_capture_circular_buffer_height)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CAMERA_CONFIG_T>())).fast_preview_resume
                as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_CONFIG_T),
            "::",
            stringify!(fast_preview_resume)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CAMERA_CONFIG_T>())).use_stc_timestamp as *const _
                as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_CONFIG_T),
            "::",
            stringify!(use_stc_timestamp)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_CAMERA_INFO_CAMERA_T {
    pub port_id: u32,
    pub max_width: u32,
    pub max_height: u32,
    pub lens_present: MMAL_BOOL_T,
    pub camera_name: [::std::os::raw::c_char; 16usize],
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_CAMERA_INFO_CAMERA_T() {
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_CAMERA_INFO_CAMERA_T>(),
        32usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_CAMERA_INFO_CAMERA_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_CAMERA_INFO_CAMERA_T>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(MMAL_PARAMETER_CAMERA_INFO_CAMERA_T)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CAMERA_INFO_CAMERA_T>())).port_id as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_INFO_CAMERA_T),
            "::",
            stringify!(port_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CAMERA_INFO_CAMERA_T>())).max_width as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_INFO_CAMERA_T),
            "::",
            stringify!(max_width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CAMERA_INFO_CAMERA_T>())).max_height as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_INFO_CAMERA_T),
            "::",
            stringify!(max_height)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CAMERA_INFO_CAMERA_T>())).lens_present as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_INFO_CAMERA_T),
            "::",
            stringify!(lens_present)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CAMERA_INFO_CAMERA_T>())).camera_name as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_INFO_CAMERA_T),
            "::",
            stringify!(camera_name)
        )
    );
}
pub const MMAL_PARAMETER_CAMERA_INFO_FLASH_TYPE_T_MMAL_PARAMETER_CAMERA_INFO_FLASH_TYPE_XENON:
    MMAL_PARAMETER_CAMERA_INFO_FLASH_TYPE_T = 0;
pub const MMAL_PARAMETER_CAMERA_INFO_FLASH_TYPE_T_MMAL_PARAMETER_CAMERA_INFO_FLASH_TYPE_LED:
    MMAL_PARAMETER_CAMERA_INFO_FLASH_TYPE_T = 1;
pub const MMAL_PARAMETER_CAMERA_INFO_FLASH_TYPE_T_MMAL_PARAMETER_CAMERA_INFO_FLASH_TYPE_OTHER:
    MMAL_PARAMETER_CAMERA_INFO_FLASH_TYPE_T = 2;
pub const MMAL_PARAMETER_CAMERA_INFO_FLASH_TYPE_T_MMAL_PARAMETER_CAMERA_INFO_FLASH_TYPE_MAX:
    MMAL_PARAMETER_CAMERA_INFO_FLASH_TYPE_T = 2147483647;
pub type MMAL_PARAMETER_CAMERA_INFO_FLASH_TYPE_T = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_CAMERA_INFO_FLASH_T {
    pub flash_type: MMAL_PARAMETER_CAMERA_INFO_FLASH_TYPE_T,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_CAMERA_INFO_FLASH_T() {
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_CAMERA_INFO_FLASH_T>(),
        4usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_CAMERA_INFO_FLASH_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_CAMERA_INFO_FLASH_T>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(MMAL_PARAMETER_CAMERA_INFO_FLASH_T)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CAMERA_INFO_FLASH_T>())).flash_type as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_INFO_FLASH_T),
            "::",
            stringify!(flash_type)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_CAMERA_INFO_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    pub num_cameras: u32,
    pub num_flashes: u32,
    pub cameras: [MMAL_PARAMETER_CAMERA_INFO_CAMERA_T; 4usize],
    pub flashes: [MMAL_PARAMETER_CAMERA_INFO_FLASH_T; 2usize],
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_CAMERA_INFO_T() {
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_CAMERA_INFO_T>(),
        152usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_CAMERA_INFO_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_CAMERA_INFO_T>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_PARAMETER_CAMERA_INFO_T))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CAMERA_INFO_T>())).hdr as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_INFO_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CAMERA_INFO_T>())).num_cameras as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_INFO_T),
            "::",
            stringify!(num_cameras)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CAMERA_INFO_T>())).num_flashes as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_INFO_T),
            "::",
            stringify!(num_flashes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CAMERA_INFO_T>())).cameras as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_INFO_T),
            "::",
            stringify!(cameras)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CAMERA_INFO_T>())).flashes as *const _ as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_INFO_T),
            "::",
            stringify!(flashes)
        )
    );
}
#[doc = "< Resumes preview once capture is completed."]
pub const MMAL_PARAMETER_CAPTUREMODE_MODE_T_MMAL_PARAM_CAPTUREMODE_WAIT_FOR_END:
    MMAL_PARAMETER_CAPTUREMODE_MODE_T = 0;
#[doc = "< Resumes preview once capture is completed, and hold the image for subsequent reprocessing."]
pub const MMAL_PARAMETER_CAPTUREMODE_MODE_T_MMAL_PARAM_CAPTUREMODE_WAIT_FOR_END_AND_HOLD:
    MMAL_PARAMETER_CAPTUREMODE_MODE_T = 1;
#[doc = "< Resumes preview as soon as possible once capture frame is received from the sensor."]
#[doc = "   Requires fast_preview_resume to be set via MMAL_PARAMETER_CAMERA_CONFIG."]
pub const MMAL_PARAMETER_CAPTUREMODE_MODE_T_MMAL_PARAM_CAPTUREMODE_RESUME_VF_IMMEDIATELY:
    MMAL_PARAMETER_CAPTUREMODE_MODE_T = 2;
pub type MMAL_PARAMETER_CAPTUREMODE_MODE_T = u32;
#[doc = " Stills capture mode control."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_CAPTUREMODE_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    pub mode: MMAL_PARAMETER_CAPTUREMODE_MODE_T,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_CAPTUREMODE_T() {
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_CAPTUREMODE_T>(),
        12usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_CAPTUREMODE_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_CAPTUREMODE_T>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_PARAMETER_CAPTUREMODE_T))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CAPTUREMODE_T>())).hdr as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAPTUREMODE_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CAPTUREMODE_T>())).mode as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAPTUREMODE_T),
            "::",
            stringify!(mode)
        )
    );
}
#[doc = "< Region defines a generic region"]
pub const MMAL_PARAMETER_FOCUS_REGION_TYPE_T_MMAL_PARAMETER_FOCUS_REGION_TYPE_NORMAL:
    MMAL_PARAMETER_FOCUS_REGION_TYPE_T = 0;
#[doc = "< Region defines a face"]
pub const MMAL_PARAMETER_FOCUS_REGION_TYPE_T_MMAL_PARAMETER_FOCUS_REGION_TYPE_FACE:
    MMAL_PARAMETER_FOCUS_REGION_TYPE_T = 1;
pub const MMAL_PARAMETER_FOCUS_REGION_TYPE_T_MMAL_PARAMETER_FOCUS_REGION_TYPE_MAX:
    MMAL_PARAMETER_FOCUS_REGION_TYPE_T = 2;
pub type MMAL_PARAMETER_FOCUS_REGION_TYPE_T = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_FOCUS_REGION_T {
    #[doc = "< Focus rectangle as 0P16 fixed point values."]
    pub rect: MMAL_RECT_T,
    #[doc = "< Region weighting."]
    pub weight: u32,
    #[doc = "< Mask for multi-stage regions"]
    pub mask: u32,
    #[doc = "< Region type"]
    pub type_: MMAL_PARAMETER_FOCUS_REGION_TYPE_T,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_FOCUS_REGION_T() {
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_FOCUS_REGION_T>(),
        28usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_FOCUS_REGION_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_FOCUS_REGION_T>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_PARAMETER_FOCUS_REGION_T))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_FOCUS_REGION_T>())).rect as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_FOCUS_REGION_T),
            "::",
            stringify!(rect)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_FOCUS_REGION_T>())).weight as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_FOCUS_REGION_T),
            "::",
            stringify!(weight)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_FOCUS_REGION_T>())).mask as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_FOCUS_REGION_T),
            "::",
            stringify!(mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_FOCUS_REGION_T>())).type_ as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_FOCUS_REGION_T),
            "::",
            stringify!(type_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_FOCUS_REGIONS_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    #[doc = "< Number of regions defined"]
    pub num_regions: u32,
    #[doc = "< If region is within tolerance of a face, adopt face rect instead of defined region"]
    pub lock_to_faces: MMAL_BOOL_T,
    #[doc = "< Variable number of regions"]
    pub regions: [MMAL_PARAMETER_FOCUS_REGION_T; 1usize],
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_FOCUS_REGIONS_T() {
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_FOCUS_REGIONS_T>(),
        44usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_FOCUS_REGIONS_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_FOCUS_REGIONS_T>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_PARAMETER_FOCUS_REGIONS_T))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_FOCUS_REGIONS_T>())).hdr as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_FOCUS_REGIONS_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_FOCUS_REGIONS_T>())).num_regions as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_FOCUS_REGIONS_T),
            "::",
            stringify!(num_regions)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_FOCUS_REGIONS_T>())).lock_to_faces as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_FOCUS_REGIONS_T),
            "::",
            stringify!(lock_to_faces)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_FOCUS_REGIONS_T>())).regions as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_FOCUS_REGIONS_T),
            "::",
            stringify!(regions)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_INPUT_CROP_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    #[doc = "< Crop rectangle as 16P16 fixed point values"]
    pub rect: MMAL_RECT_T,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_INPUT_CROP_T() {
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_INPUT_CROP_T>(),
        24usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_INPUT_CROP_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_INPUT_CROP_T>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_PARAMETER_INPUT_CROP_T))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_PARAMETER_INPUT_CROP_T>())).hdr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_INPUT_CROP_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_INPUT_CROP_T>())).rect as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_INPUT_CROP_T),
            "::",
            stringify!(rect)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_SENSOR_INFORMATION_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    #[doc = "< Lens f-number"]
    pub f_number: MMAL_RATIONAL_T,
    #[doc = "< Lens focal length"]
    pub focal_length: MMAL_RATIONAL_T,
    #[doc = "< Sensor reported model id"]
    pub model_id: u32,
    #[doc = "< Sensor reported manufacturer id"]
    pub manufacturer_id: u32,
    #[doc = "< Sensor reported revision"]
    pub revision: u32,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_SENSOR_INFORMATION_T() {
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_SENSOR_INFORMATION_T>(),
        36usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_SENSOR_INFORMATION_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_SENSOR_INFORMATION_T>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(MMAL_PARAMETER_SENSOR_INFORMATION_T)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_SENSOR_INFORMATION_T>())).hdr as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_SENSOR_INFORMATION_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_SENSOR_INFORMATION_T>())).f_number as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_SENSOR_INFORMATION_T),
            "::",
            stringify!(f_number)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_SENSOR_INFORMATION_T>())).focal_length as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_SENSOR_INFORMATION_T),
            "::",
            stringify!(focal_length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_SENSOR_INFORMATION_T>())).model_id as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_SENSOR_INFORMATION_T),
            "::",
            stringify!(model_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_SENSOR_INFORMATION_T>())).manufacturer_id
                as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_SENSOR_INFORMATION_T),
            "::",
            stringify!(manufacturer_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_SENSOR_INFORMATION_T>())).revision as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_SENSOR_INFORMATION_T),
            "::",
            stringify!(revision)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_FLASH_SELECT_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    #[doc = "< Flash type to use"]
    pub flash_type: MMAL_PARAMETER_CAMERA_INFO_FLASH_TYPE_T,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_FLASH_SELECT_T() {
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_FLASH_SELECT_T>(),
        12usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_FLASH_SELECT_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_FLASH_SELECT_T>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_PARAMETER_FLASH_SELECT_T))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_FLASH_SELECT_T>())).hdr as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_FLASH_SELECT_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_FLASH_SELECT_T>())).flash_type as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_FLASH_SELECT_T),
            "::",
            stringify!(flash_type)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_FIELD_OF_VIEW_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    #[doc = "< Horizontal field of view"]
    pub fov_h: MMAL_RATIONAL_T,
    #[doc = "< Vertical field of view"]
    pub fov_v: MMAL_RATIONAL_T,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_FIELD_OF_VIEW_T() {
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_FIELD_OF_VIEW_T>(),
        24usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_FIELD_OF_VIEW_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_FIELD_OF_VIEW_T>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_PARAMETER_FIELD_OF_VIEW_T))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_FIELD_OF_VIEW_T>())).hdr as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_FIELD_OF_VIEW_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_FIELD_OF_VIEW_T>())).fov_h as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_FIELD_OF_VIEW_T),
            "::",
            stringify!(fov_h)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_FIELD_OF_VIEW_T>())).fov_v as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_FIELD_OF_VIEW_T),
            "::",
            stringify!(fov_v)
        )
    );
}
pub const MMAL_PARAMETER_DRC_STRENGTH_T_MMAL_PARAMETER_DRC_STRENGTH_OFF:
    MMAL_PARAMETER_DRC_STRENGTH_T = 0;
pub const MMAL_PARAMETER_DRC_STRENGTH_T_MMAL_PARAMETER_DRC_STRENGTH_LOW:
    MMAL_PARAMETER_DRC_STRENGTH_T = 1;
pub const MMAL_PARAMETER_DRC_STRENGTH_T_MMAL_PARAMETER_DRC_STRENGTH_MEDIUM:
    MMAL_PARAMETER_DRC_STRENGTH_T = 2;
pub const MMAL_PARAMETER_DRC_STRENGTH_T_MMAL_PARAMETER_DRC_STRENGTH_HIGH:
    MMAL_PARAMETER_DRC_STRENGTH_T = 3;
pub const MMAL_PARAMETER_DRC_STRENGTH_T_MMAL_PARAMETER_DRC_STRENGTH_MAX:
    MMAL_PARAMETER_DRC_STRENGTH_T = 2147483647;
pub type MMAL_PARAMETER_DRC_STRENGTH_T = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_DRC_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    #[doc = "< DRC strength"]
    pub strength: MMAL_PARAMETER_DRC_STRENGTH_T,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_DRC_T() {
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_DRC_T>(),
        12usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_DRC_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_DRC_T>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_PARAMETER_DRC_T))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_PARAMETER_DRC_T>())).hdr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_DRC_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_PARAMETER_DRC_T>())).strength as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_DRC_T),
            "::",
            stringify!(strength)
        )
    );
}
pub const MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_T_MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_FACETRACKING : MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_T = 0 ;
pub const MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_T_MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_REDEYE_REDUCTION : MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_T = 1 ;
pub const MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_T_MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_VIDEO_STABILISATION : MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_T = 2 ;
pub const MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_T_MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_WRITE_RAW : MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_T = 3 ;
pub const MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_T_MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_VIDEO_DENOISE : MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_T = 4 ;
pub const MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_T_MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_STILLS_DENOISE : MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_T = 5 ;
pub const MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_T_MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_TEMPORAL_DENOISE : MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_T = 6 ;
pub const MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_T_MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_ANTISHAKE : MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_T = 7 ;
pub const MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_T_MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_IMAGE_EFFECTS : MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_T = 8 ;
pub const MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_T_MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_DYNAMIC_RANGE_COMPRESSION : MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_T = 9 ;
pub const MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_T_MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_FACE_RECOGNITION : MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_T = 10 ;
pub const MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_T_MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_FACE_BEAUTIFICATION : MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_T = 11 ;
pub const MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_T_MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_SCENE_DETECTION : MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_T = 12 ;
pub const MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_T_MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_HIGH_DYNAMIC_RANGE : MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_T = 13 ;
pub const MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_T_MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_MAX : MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_T = 2147483647 ;
pub type MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_T = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_ALGORITHM_CONTROL_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    pub algorithm: MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_T,
    pub enabled: MMAL_BOOL_T,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_ALGORITHM_CONTROL_T() {
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_ALGORITHM_CONTROL_T>(),
        16usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_ALGORITHM_CONTROL_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_ALGORITHM_CONTROL_T>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(MMAL_PARAMETER_ALGORITHM_CONTROL_T)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_ALGORITHM_CONTROL_T>())).hdr as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_ALGORITHM_CONTROL_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_ALGORITHM_CONTROL_T>())).algorithm as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_ALGORITHM_CONTROL_T),
            "::",
            stringify!(algorithm)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_ALGORITHM_CONTROL_T>())).enabled as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_ALGORITHM_CONTROL_T),
            "::",
            stringify!(enabled)
        )
    );
}
#[doc = "< Compromise on behaviour as use case totally unknown"]
pub const MMAL_PARAM_CAMERA_USE_CASE_T_MMAL_PARAM_CAMERA_USE_CASE_UNKNOWN:
    MMAL_PARAM_CAMERA_USE_CASE_T = 0;
#[doc = "< Stills capture use case"]
pub const MMAL_PARAM_CAMERA_USE_CASE_T_MMAL_PARAM_CAMERA_USE_CASE_STILLS_CAPTURE:
    MMAL_PARAM_CAMERA_USE_CASE_T = 1;
#[doc = "< Video encode (camcorder) use case"]
pub const MMAL_PARAM_CAMERA_USE_CASE_T_MMAL_PARAM_CAMERA_USE_CASE_VIDEO_CAPTURE:
    MMAL_PARAM_CAMERA_USE_CASE_T = 2;
pub const MMAL_PARAM_CAMERA_USE_CASE_T_MMAL_PARAM_CAMERA_USE_CASE_MAX:
    MMAL_PARAM_CAMERA_USE_CASE_T = 2147483647;
pub type MMAL_PARAM_CAMERA_USE_CASE_T = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_CAMERA_USE_CASE_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    #[doc = "< Use case"]
    pub use_case: MMAL_PARAM_CAMERA_USE_CASE_T,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_CAMERA_USE_CASE_T() {
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_CAMERA_USE_CASE_T>(),
        12usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_CAMERA_USE_CASE_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_CAMERA_USE_CASE_T>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(MMAL_PARAMETER_CAMERA_USE_CASE_T)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CAMERA_USE_CASE_T>())).hdr as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_USE_CASE_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CAMERA_USE_CASE_T>())).use_case as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_USE_CASE_T),
            "::",
            stringify!(use_case)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_FPS_RANGE_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    #[doc = "< Low end of the permitted framerate range"]
    pub fps_low: MMAL_RATIONAL_T,
    #[doc = "< High end of the permitted framerate range"]
    pub fps_high: MMAL_RATIONAL_T,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_FPS_RANGE_T() {
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_FPS_RANGE_T>(),
        24usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_FPS_RANGE_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_FPS_RANGE_T>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_PARAMETER_FPS_RANGE_T))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_PARAMETER_FPS_RANGE_T>())).hdr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_FPS_RANGE_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_FPS_RANGE_T>())).fps_low as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_FPS_RANGE_T),
            "::",
            stringify!(fps_low)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_FPS_RANGE_T>())).fps_high as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_FPS_RANGE_T),
            "::",
            stringify!(fps_high)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_ZEROSHUTTERLAG_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    #[doc = "< Select zero shutter lag mode from sensor"]
    pub zero_shutter_lag_mode: MMAL_BOOL_T,
    #[doc = "< Activate full zero shutter lag mode and"]
    #[doc = "  use the last preview raw image for the stills capture"]
    pub concurrent_capture: MMAL_BOOL_T,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_ZEROSHUTTERLAG_T() {
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_ZEROSHUTTERLAG_T>(),
        16usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_ZEROSHUTTERLAG_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_ZEROSHUTTERLAG_T>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_PARAMETER_ZEROSHUTTERLAG_T))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_ZEROSHUTTERLAG_T>())).hdr as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_ZEROSHUTTERLAG_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_ZEROSHUTTERLAG_T>())).zero_shutter_lag_mode
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_ZEROSHUTTERLAG_T),
            "::",
            stringify!(zero_shutter_lag_mode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_ZEROSHUTTERLAG_T>())).concurrent_capture
                as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_ZEROSHUTTERLAG_T),
            "::",
            stringify!(concurrent_capture)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_AWB_GAINS_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    #[doc = "< Red gain"]
    pub r_gain: MMAL_RATIONAL_T,
    #[doc = "< Blue gain"]
    pub b_gain: MMAL_RATIONAL_T,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_AWB_GAINS_T() {
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_AWB_GAINS_T>(),
        24usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_AWB_GAINS_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_AWB_GAINS_T>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_PARAMETER_AWB_GAINS_T))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_PARAMETER_AWB_GAINS_T>())).hdr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_AWB_GAINS_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_AWB_GAINS_T>())).r_gain as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_AWB_GAINS_T),
            "::",
            stringify!(r_gain)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_AWB_GAINS_T>())).b_gain as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_AWB_GAINS_T),
            "::",
            stringify!(b_gain)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_CAMERA_SETTINGS_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    pub exposure: u32,
    pub analog_gain: MMAL_RATIONAL_T,
    pub digital_gain: MMAL_RATIONAL_T,
    pub awb_red_gain: MMAL_RATIONAL_T,
    pub awb_blue_gain: MMAL_RATIONAL_T,
    pub focus_position: u32,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_CAMERA_SETTINGS_T() {
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_CAMERA_SETTINGS_T>(),
        48usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_CAMERA_SETTINGS_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_CAMERA_SETTINGS_T>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(MMAL_PARAMETER_CAMERA_SETTINGS_T)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CAMERA_SETTINGS_T>())).hdr as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_SETTINGS_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CAMERA_SETTINGS_T>())).exposure as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_SETTINGS_T),
            "::",
            stringify!(exposure)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CAMERA_SETTINGS_T>())).analog_gain as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_SETTINGS_T),
            "::",
            stringify!(analog_gain)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CAMERA_SETTINGS_T>())).digital_gain as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_SETTINGS_T),
            "::",
            stringify!(digital_gain)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CAMERA_SETTINGS_T>())).awb_red_gain as *const _
                as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_SETTINGS_T),
            "::",
            stringify!(awb_red_gain)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CAMERA_SETTINGS_T>())).awb_blue_gain as *const _
                as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_SETTINGS_T),
            "::",
            stringify!(awb_blue_gain)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CAMERA_SETTINGS_T>())).focus_position as *const _
                as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_SETTINGS_T),
            "::",
            stringify!(focus_position)
        )
    );
}
#[doc = "< Indicator will be off."]
pub const MMAL_PARAM_PRIVACY_INDICATOR_T_MMAL_PARAMETER_PRIVACY_INDICATOR_OFF:
    MMAL_PARAM_PRIVACY_INDICATOR_T = 0;
#[doc = "< Indicator will come on just after a stills capture and"]
#[doc = "   and remain on for 2seconds, or will be on whilst output[1]"]
#[doc = "   is actively producing images."]
pub const MMAL_PARAM_PRIVACY_INDICATOR_T_MMAL_PARAMETER_PRIVACY_INDICATOR_ON:
    MMAL_PARAM_PRIVACY_INDICATOR_T = 1;
#[doc = "< Turns indicator of for 2s independent of capture status."]
#[doc = "   Set this mode repeatedly to keep the indicator on for a"]
#[doc = "   longer period."]
pub const MMAL_PARAM_PRIVACY_INDICATOR_T_MMAL_PARAMETER_PRIVACY_INDICATOR_FORCE_ON:
    MMAL_PARAM_PRIVACY_INDICATOR_T = 2;
pub const MMAL_PARAM_PRIVACY_INDICATOR_T_MMAL_PARAMETER_PRIVACY_INDICATOR_MAX:
    MMAL_PARAM_PRIVACY_INDICATOR_T = 2147483647;
pub type MMAL_PARAM_PRIVACY_INDICATOR_T = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_PRIVACY_INDICATOR_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    pub mode: MMAL_PARAM_PRIVACY_INDICATOR_T,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_PRIVACY_INDICATOR_T() {
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_PRIVACY_INDICATOR_T>(),
        12usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_PRIVACY_INDICATOR_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_PRIVACY_INDICATOR_T>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(MMAL_PARAMETER_PRIVACY_INDICATOR_T)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_PRIVACY_INDICATOR_T>())).hdr as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_PRIVACY_INDICATOR_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_PRIVACY_INDICATOR_T>())).mode as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_PRIVACY_INDICATOR_T),
            "::",
            stringify!(mode)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_CAMERA_ANNOTATE_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    pub enable: MMAL_BOOL_T,
    pub text: [::std::os::raw::c_char; 32usize],
    pub show_shutter: MMAL_BOOL_T,
    pub show_analog_gain: MMAL_BOOL_T,
    pub show_lens: MMAL_BOOL_T,
    pub show_caf: MMAL_BOOL_T,
    pub show_motion: MMAL_BOOL_T,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_CAMERA_ANNOTATE_T() {
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_CAMERA_ANNOTATE_T>(),
        64usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_CAMERA_ANNOTATE_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_CAMERA_ANNOTATE_T>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(MMAL_PARAMETER_CAMERA_ANNOTATE_T)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CAMERA_ANNOTATE_T>())).hdr as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_ANNOTATE_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CAMERA_ANNOTATE_T>())).enable as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_ANNOTATE_T),
            "::",
            stringify!(enable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CAMERA_ANNOTATE_T>())).text as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_ANNOTATE_T),
            "::",
            stringify!(text)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CAMERA_ANNOTATE_T>())).show_shutter as *const _
                as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_ANNOTATE_T),
            "::",
            stringify!(show_shutter)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CAMERA_ANNOTATE_T>())).show_analog_gain
                as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_ANNOTATE_T),
            "::",
            stringify!(show_analog_gain)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CAMERA_ANNOTATE_T>())).show_lens as *const _
                as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_ANNOTATE_T),
            "::",
            stringify!(show_lens)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CAMERA_ANNOTATE_T>())).show_caf as *const _
                as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_ANNOTATE_T),
            "::",
            stringify!(show_caf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CAMERA_ANNOTATE_T>())).show_motion as *const _
                as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_ANNOTATE_T),
            "::",
            stringify!(show_motion)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct MMAL_PARAMETER_CAMERA_ANNOTATE_V2_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    pub enable: MMAL_BOOL_T,
    pub show_shutter: MMAL_BOOL_T,
    pub show_analog_gain: MMAL_BOOL_T,
    pub show_lens: MMAL_BOOL_T,
    pub show_caf: MMAL_BOOL_T,
    pub show_motion: MMAL_BOOL_T,
    pub show_frame_num: MMAL_BOOL_T,
    pub black_text_background: MMAL_BOOL_T,
    pub text: [::std::os::raw::c_char; 256usize],
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_CAMERA_ANNOTATE_V2_T() {
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_CAMERA_ANNOTATE_V2_T>(),
        296usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_CAMERA_ANNOTATE_V2_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_CAMERA_ANNOTATE_V2_T>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(MMAL_PARAMETER_CAMERA_ANNOTATE_V2_T)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CAMERA_ANNOTATE_V2_T>())).hdr as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_ANNOTATE_V2_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CAMERA_ANNOTATE_V2_T>())).enable as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_ANNOTATE_V2_T),
            "::",
            stringify!(enable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CAMERA_ANNOTATE_V2_T>())).show_shutter as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_ANNOTATE_V2_T),
            "::",
            stringify!(show_shutter)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CAMERA_ANNOTATE_V2_T>())).show_analog_gain
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_ANNOTATE_V2_T),
            "::",
            stringify!(show_analog_gain)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CAMERA_ANNOTATE_V2_T>())).show_lens as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_ANNOTATE_V2_T),
            "::",
            stringify!(show_lens)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CAMERA_ANNOTATE_V2_T>())).show_caf as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_ANNOTATE_V2_T),
            "::",
            stringify!(show_caf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CAMERA_ANNOTATE_V2_T>())).show_motion as *const _
                as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_ANNOTATE_V2_T),
            "::",
            stringify!(show_motion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CAMERA_ANNOTATE_V2_T>())).show_frame_num
                as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_ANNOTATE_V2_T),
            "::",
            stringify!(show_frame_num)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CAMERA_ANNOTATE_V2_T>())).black_text_background
                as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_ANNOTATE_V2_T),
            "::",
            stringify!(black_text_background)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CAMERA_ANNOTATE_V2_T>())).text as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_ANNOTATE_V2_T),
            "::",
            stringify!(text)
        )
    );
}
impl ::std::fmt::Debug for MMAL_PARAMETER_CAMERA_ANNOTATE_V2_T {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! ( f , "MMAL_PARAMETER_CAMERA_ANNOTATE_V2_T {{ hdr: {:?}, enable: {:?}, show_shutter: {:?}, show_analog_gain: {:?}, show_lens: {:?}, show_caf: {:?}, show_motion: {:?}, show_frame_num: {:?}, black_text_background: {:?}, text: [{}] }}" , self . hdr , self . enable , self . show_shutter , self . show_analog_gain , self . show_lens , self . show_caf , self . show_motion , self . show_frame_num , self . black_text_background , self . text . iter ( ) . enumerate ( ) . map ( | ( i , v ) | format ! ( "{}{:?}" , if i > 0 { ", " } else { "" } , v ) ) . collect :: < String > ( ) )
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct MMAL_PARAMETER_CAMERA_ANNOTATE_V3_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    pub enable: MMAL_BOOL_T,
    pub show_shutter: MMAL_BOOL_T,
    pub show_analog_gain: MMAL_BOOL_T,
    pub show_lens: MMAL_BOOL_T,
    pub show_caf: MMAL_BOOL_T,
    pub show_motion: MMAL_BOOL_T,
    pub show_frame_num: MMAL_BOOL_T,
    pub enable_text_background: MMAL_BOOL_T,
    pub custom_background_colour: MMAL_BOOL_T,
    pub custom_background_Y: u8,
    pub custom_background_U: u8,
    pub custom_background_V: u8,
    pub dummy1: u8,
    pub custom_text_colour: MMAL_BOOL_T,
    pub custom_text_Y: u8,
    pub custom_text_U: u8,
    pub custom_text_V: u8,
    pub text_size: u8,
    pub text: [::std::os::raw::c_char; 256usize],
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_CAMERA_ANNOTATE_V3_T() {
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_CAMERA_ANNOTATE_V3_T>(),
        312usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_CAMERA_ANNOTATE_V3_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_CAMERA_ANNOTATE_V3_T>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(MMAL_PARAMETER_CAMERA_ANNOTATE_V3_T)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CAMERA_ANNOTATE_V3_T>())).hdr as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_ANNOTATE_V3_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CAMERA_ANNOTATE_V3_T>())).enable as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_ANNOTATE_V3_T),
            "::",
            stringify!(enable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CAMERA_ANNOTATE_V3_T>())).show_shutter as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_ANNOTATE_V3_T),
            "::",
            stringify!(show_shutter)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CAMERA_ANNOTATE_V3_T>())).show_analog_gain
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_ANNOTATE_V3_T),
            "::",
            stringify!(show_analog_gain)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CAMERA_ANNOTATE_V3_T>())).show_lens as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_ANNOTATE_V3_T),
            "::",
            stringify!(show_lens)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CAMERA_ANNOTATE_V3_T>())).show_caf as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_ANNOTATE_V3_T),
            "::",
            stringify!(show_caf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CAMERA_ANNOTATE_V3_T>())).show_motion as *const _
                as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_ANNOTATE_V3_T),
            "::",
            stringify!(show_motion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CAMERA_ANNOTATE_V3_T>())).show_frame_num
                as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_ANNOTATE_V3_T),
            "::",
            stringify!(show_frame_num)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CAMERA_ANNOTATE_V3_T>())).enable_text_background
                as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_ANNOTATE_V3_T),
            "::",
            stringify!(enable_text_background)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CAMERA_ANNOTATE_V3_T>())).custom_background_colour
                as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_ANNOTATE_V3_T),
            "::",
            stringify!(custom_background_colour)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CAMERA_ANNOTATE_V3_T>())).custom_background_Y
                as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_ANNOTATE_V3_T),
            "::",
            stringify!(custom_background_Y)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CAMERA_ANNOTATE_V3_T>())).custom_background_U
                as *const _ as usize
        },
        45usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_ANNOTATE_V3_T),
            "::",
            stringify!(custom_background_U)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CAMERA_ANNOTATE_V3_T>())).custom_background_V
                as *const _ as usize
        },
        46usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_ANNOTATE_V3_T),
            "::",
            stringify!(custom_background_V)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CAMERA_ANNOTATE_V3_T>())).dummy1 as *const _
                as usize
        },
        47usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_ANNOTATE_V3_T),
            "::",
            stringify!(dummy1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CAMERA_ANNOTATE_V3_T>())).custom_text_colour
                as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_ANNOTATE_V3_T),
            "::",
            stringify!(custom_text_colour)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CAMERA_ANNOTATE_V3_T>())).custom_text_Y
                as *const _ as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_ANNOTATE_V3_T),
            "::",
            stringify!(custom_text_Y)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CAMERA_ANNOTATE_V3_T>())).custom_text_U
                as *const _ as usize
        },
        53usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_ANNOTATE_V3_T),
            "::",
            stringify!(custom_text_U)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CAMERA_ANNOTATE_V3_T>())).custom_text_V
                as *const _ as usize
        },
        54usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_ANNOTATE_V3_T),
            "::",
            stringify!(custom_text_V)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CAMERA_ANNOTATE_V3_T>())).text_size as *const _
                as usize
        },
        55usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_ANNOTATE_V3_T),
            "::",
            stringify!(text_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CAMERA_ANNOTATE_V3_T>())).text as *const _
                as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_ANNOTATE_V3_T),
            "::",
            stringify!(text)
        )
    );
}
impl ::std::fmt::Debug for MMAL_PARAMETER_CAMERA_ANNOTATE_V3_T {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! ( f , "MMAL_PARAMETER_CAMERA_ANNOTATE_V3_T {{ hdr: {:?}, enable: {:?}, show_shutter: {:?}, show_analog_gain: {:?}, show_lens: {:?}, show_caf: {:?}, show_motion: {:?}, show_frame_num: {:?}, enable_text_background: {:?}, custom_background_colour: {:?}, custom_background_Y: {:?}, custom_background_U: {:?}, custom_background_V: {:?}, dummy1: {:?}, custom_text_colour: {:?}, custom_text_Y: {:?}, custom_text_U: {:?}, custom_text_V: {:?}, text_size: {:?}, text: [{}] }}" , self . hdr , self . enable , self . show_shutter , self . show_analog_gain , self . show_lens , self . show_caf , self . show_motion , self . show_frame_num , self . enable_text_background , self . custom_background_colour , self . custom_background_Y , self . custom_background_U , self . custom_background_V , self . dummy1 , self . custom_text_colour , self . custom_text_Y , self . custom_text_U , self . custom_text_V , self . text_size , self . text . iter ( ) . enumerate ( ) . map ( | ( i , v ) | format ! ( "{}{:?}" , if i > 0 { ", " } else { "" } , v ) ) . collect :: < String > ( ) )
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct MMAL_PARAMETER_CAMERA_ANNOTATE_V4_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    pub enable: MMAL_BOOL_T,
    pub show_shutter: MMAL_BOOL_T,
    pub show_analog_gain: MMAL_BOOL_T,
    pub show_lens: MMAL_BOOL_T,
    pub show_caf: MMAL_BOOL_T,
    pub show_motion: MMAL_BOOL_T,
    pub show_frame_num: MMAL_BOOL_T,
    pub enable_text_background: MMAL_BOOL_T,
    pub custom_background_colour: MMAL_BOOL_T,
    pub custom_background_Y: u8,
    pub custom_background_U: u8,
    pub custom_background_V: u8,
    pub dummy1: u8,
    pub custom_text_colour: MMAL_BOOL_T,
    pub custom_text_Y: u8,
    pub custom_text_U: u8,
    pub custom_text_V: u8,
    pub text_size: u8,
    pub text: [::std::os::raw::c_char; 256usize],
    pub justify: u32,
    pub x_offset: u32,
    pub y_offset: u32,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_CAMERA_ANNOTATE_V4_T() {
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_CAMERA_ANNOTATE_V4_T>(),
        324usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_CAMERA_ANNOTATE_V4_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_CAMERA_ANNOTATE_V4_T>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(MMAL_PARAMETER_CAMERA_ANNOTATE_V4_T)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CAMERA_ANNOTATE_V4_T>())).hdr as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_ANNOTATE_V4_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CAMERA_ANNOTATE_V4_T>())).enable as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_ANNOTATE_V4_T),
            "::",
            stringify!(enable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CAMERA_ANNOTATE_V4_T>())).show_shutter as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_ANNOTATE_V4_T),
            "::",
            stringify!(show_shutter)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CAMERA_ANNOTATE_V4_T>())).show_analog_gain
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_ANNOTATE_V4_T),
            "::",
            stringify!(show_analog_gain)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CAMERA_ANNOTATE_V4_T>())).show_lens as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_ANNOTATE_V4_T),
            "::",
            stringify!(show_lens)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CAMERA_ANNOTATE_V4_T>())).show_caf as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_ANNOTATE_V4_T),
            "::",
            stringify!(show_caf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CAMERA_ANNOTATE_V4_T>())).show_motion as *const _
                as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_ANNOTATE_V4_T),
            "::",
            stringify!(show_motion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CAMERA_ANNOTATE_V4_T>())).show_frame_num
                as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_ANNOTATE_V4_T),
            "::",
            stringify!(show_frame_num)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CAMERA_ANNOTATE_V4_T>())).enable_text_background
                as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_ANNOTATE_V4_T),
            "::",
            stringify!(enable_text_background)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CAMERA_ANNOTATE_V4_T>())).custom_background_colour
                as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_ANNOTATE_V4_T),
            "::",
            stringify!(custom_background_colour)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CAMERA_ANNOTATE_V4_T>())).custom_background_Y
                as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_ANNOTATE_V4_T),
            "::",
            stringify!(custom_background_Y)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CAMERA_ANNOTATE_V4_T>())).custom_background_U
                as *const _ as usize
        },
        45usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_ANNOTATE_V4_T),
            "::",
            stringify!(custom_background_U)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CAMERA_ANNOTATE_V4_T>())).custom_background_V
                as *const _ as usize
        },
        46usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_ANNOTATE_V4_T),
            "::",
            stringify!(custom_background_V)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CAMERA_ANNOTATE_V4_T>())).dummy1 as *const _
                as usize
        },
        47usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_ANNOTATE_V4_T),
            "::",
            stringify!(dummy1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CAMERA_ANNOTATE_V4_T>())).custom_text_colour
                as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_ANNOTATE_V4_T),
            "::",
            stringify!(custom_text_colour)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CAMERA_ANNOTATE_V4_T>())).custom_text_Y
                as *const _ as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_ANNOTATE_V4_T),
            "::",
            stringify!(custom_text_Y)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CAMERA_ANNOTATE_V4_T>())).custom_text_U
                as *const _ as usize
        },
        53usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_ANNOTATE_V4_T),
            "::",
            stringify!(custom_text_U)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CAMERA_ANNOTATE_V4_T>())).custom_text_V
                as *const _ as usize
        },
        54usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_ANNOTATE_V4_T),
            "::",
            stringify!(custom_text_V)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CAMERA_ANNOTATE_V4_T>())).text_size as *const _
                as usize
        },
        55usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_ANNOTATE_V4_T),
            "::",
            stringify!(text_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CAMERA_ANNOTATE_V4_T>())).text as *const _
                as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_ANNOTATE_V4_T),
            "::",
            stringify!(text)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CAMERA_ANNOTATE_V4_T>())).justify as *const _
                as usize
        },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_ANNOTATE_V4_T),
            "::",
            stringify!(justify)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CAMERA_ANNOTATE_V4_T>())).x_offset as *const _
                as usize
        },
        316usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_ANNOTATE_V4_T),
            "::",
            stringify!(x_offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CAMERA_ANNOTATE_V4_T>())).y_offset as *const _
                as usize
        },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_ANNOTATE_V4_T),
            "::",
            stringify!(y_offset)
        )
    );
}
impl ::std::fmt::Debug for MMAL_PARAMETER_CAMERA_ANNOTATE_V4_T {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! ( f , "MMAL_PARAMETER_CAMERA_ANNOTATE_V4_T {{ hdr: {:?}, enable: {:?}, show_shutter: {:?}, show_analog_gain: {:?}, show_lens: {:?}, show_caf: {:?}, show_motion: {:?}, show_frame_num: {:?}, enable_text_background: {:?}, custom_background_colour: {:?}, custom_background_Y: {:?}, custom_background_U: {:?}, custom_background_V: {:?}, dummy1: {:?}, custom_text_colour: {:?}, custom_text_Y: {:?}, custom_text_U: {:?}, custom_text_V: {:?}, text_size: {:?}, text: [{}], justify: {:?}, x_offset: {:?}, y_offset: {:?} }}" , self . hdr , self . enable , self . show_shutter , self . show_analog_gain , self . show_lens , self . show_caf , self . show_motion , self . show_frame_num , self . enable_text_background , self . custom_background_colour , self . custom_background_Y , self . custom_background_U , self . custom_background_V , self . dummy1 , self . custom_text_colour , self . custom_text_Y , self . custom_text_U , self . custom_text_V , self . text_size , self . text . iter ( ) . enumerate ( ) . map ( | ( i , v ) | format ! ( "{}{:?}" , if i > 0 { ", " } else { "" } , v ) ) . collect :: < String > ( ) , self . justify , self . x_offset , self . y_offset )
    }
}
pub const MMAL_STEREOSCOPIC_MODE_T_MMAL_STEREOSCOPIC_MODE_NONE: MMAL_STEREOSCOPIC_MODE_T = 0;
pub const MMAL_STEREOSCOPIC_MODE_T_MMAL_STEREOSCOPIC_MODE_SIDE_BY_SIDE: MMAL_STEREOSCOPIC_MODE_T =
    1;
pub const MMAL_STEREOSCOPIC_MODE_T_MMAL_STEREOSCOPIC_MODE_TOP_BOTTOM: MMAL_STEREOSCOPIC_MODE_T = 2;
pub const MMAL_STEREOSCOPIC_MODE_T_MMAL_STEREOSCOPIC_MODE_MAX: MMAL_STEREOSCOPIC_MODE_T =
    2147483647;
pub type MMAL_STEREOSCOPIC_MODE_T = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_STEREOSCOPIC_MODE_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    pub mode: MMAL_STEREOSCOPIC_MODE_T,
    pub decimate: MMAL_BOOL_T,
    pub swap_eyes: MMAL_BOOL_T,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_STEREOSCOPIC_MODE_T() {
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_STEREOSCOPIC_MODE_T>(),
        20usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_STEREOSCOPIC_MODE_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_STEREOSCOPIC_MODE_T>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(MMAL_PARAMETER_STEREOSCOPIC_MODE_T)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_STEREOSCOPIC_MODE_T>())).hdr as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_STEREOSCOPIC_MODE_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_STEREOSCOPIC_MODE_T>())).mode as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_STEREOSCOPIC_MODE_T),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_STEREOSCOPIC_MODE_T>())).decimate as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_STEREOSCOPIC_MODE_T),
            "::",
            stringify!(decimate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_STEREOSCOPIC_MODE_T>())).swap_eyes as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_STEREOSCOPIC_MODE_T),
            "::",
            stringify!(swap_eyes)
        )
    );
}
pub const MMAL_CAMERA_INTERFACE_T_MMAL_CAMERA_INTERFACE_CSI2: MMAL_CAMERA_INTERFACE_T = 0;
pub const MMAL_CAMERA_INTERFACE_T_MMAL_CAMERA_INTERFACE_CCP2: MMAL_CAMERA_INTERFACE_T = 1;
pub const MMAL_CAMERA_INTERFACE_T_MMAL_CAMERA_INTERFACE_CPI: MMAL_CAMERA_INTERFACE_T = 2;
pub const MMAL_CAMERA_INTERFACE_T_MMAL_CAMERA_INTERFACE_MAX: MMAL_CAMERA_INTERFACE_T = 2147483647;
pub type MMAL_CAMERA_INTERFACE_T = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_CAMERA_INTERFACE_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    pub mode: MMAL_CAMERA_INTERFACE_T,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_CAMERA_INTERFACE_T() {
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_CAMERA_INTERFACE_T>(),
        12usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_CAMERA_INTERFACE_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_CAMERA_INTERFACE_T>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(MMAL_PARAMETER_CAMERA_INTERFACE_T)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CAMERA_INTERFACE_T>())).hdr as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_INTERFACE_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CAMERA_INTERFACE_T>())).mode as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_INTERFACE_T),
            "::",
            stringify!(mode)
        )
    );
}
pub const MMAL_CAMERA_CLOCKING_MODE_T_MMAL_CAMERA_CLOCKING_MODE_STROBE:
    MMAL_CAMERA_CLOCKING_MODE_T = 0;
pub const MMAL_CAMERA_CLOCKING_MODE_T_MMAL_CAMERA_CLOCKING_MODE_CLOCK: MMAL_CAMERA_CLOCKING_MODE_T =
    1;
pub const MMAL_CAMERA_CLOCKING_MODE_T_MMAL_CAMERA_CLOCKING_MODE_MAX: MMAL_CAMERA_CLOCKING_MODE_T =
    2147483647;
pub type MMAL_CAMERA_CLOCKING_MODE_T = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_CAMERA_CLOCKING_MODE_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    pub mode: MMAL_CAMERA_CLOCKING_MODE_T,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_CAMERA_CLOCKING_MODE_T() {
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_CAMERA_CLOCKING_MODE_T>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(MMAL_PARAMETER_CAMERA_CLOCKING_MODE_T)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_CAMERA_CLOCKING_MODE_T>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(MMAL_PARAMETER_CAMERA_CLOCKING_MODE_T)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CAMERA_CLOCKING_MODE_T>())).hdr as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_CLOCKING_MODE_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CAMERA_CLOCKING_MODE_T>())).mode as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_CLOCKING_MODE_T),
            "::",
            stringify!(mode)
        )
    );
}
pub const MMAL_CAMERA_RX_CONFIG_DECODE_MMAL_CAMERA_RX_CONFIG_DECODE_NONE:
    MMAL_CAMERA_RX_CONFIG_DECODE = 0;
pub const MMAL_CAMERA_RX_CONFIG_DECODE_MMAL_CAMERA_RX_CONFIG_DECODE_DPCM8TO10:
    MMAL_CAMERA_RX_CONFIG_DECODE = 1;
pub const MMAL_CAMERA_RX_CONFIG_DECODE_MMAL_CAMERA_RX_CONFIG_DECODE_DPCM7TO10:
    MMAL_CAMERA_RX_CONFIG_DECODE = 2;
pub const MMAL_CAMERA_RX_CONFIG_DECODE_MMAL_CAMERA_RX_CONFIG_DECODE_DPCM6TO10:
    MMAL_CAMERA_RX_CONFIG_DECODE = 3;
pub const MMAL_CAMERA_RX_CONFIG_DECODE_MMAL_CAMERA_RX_CONFIG_DECODE_DPCM8TO12:
    MMAL_CAMERA_RX_CONFIG_DECODE = 4;
pub const MMAL_CAMERA_RX_CONFIG_DECODE_MMAL_CAMERA_RX_CONFIG_DECODE_DPCM7TO12:
    MMAL_CAMERA_RX_CONFIG_DECODE = 5;
pub const MMAL_CAMERA_RX_CONFIG_DECODE_MMAL_CAMERA_RX_CONFIG_DECODE_DPCM6TO12:
    MMAL_CAMERA_RX_CONFIG_DECODE = 6;
pub const MMAL_CAMERA_RX_CONFIG_DECODE_MMAL_CAMERA_RX_CONFIG_DECODE_DPCM10TO14:
    MMAL_CAMERA_RX_CONFIG_DECODE = 7;
pub const MMAL_CAMERA_RX_CONFIG_DECODE_MMAL_CAMERA_RX_CONFIG_DECODE_DPCM8TO14:
    MMAL_CAMERA_RX_CONFIG_DECODE = 8;
pub const MMAL_CAMERA_RX_CONFIG_DECODE_MMAL_CAMERA_RX_CONFIG_DECODE_DPCM12TO16:
    MMAL_CAMERA_RX_CONFIG_DECODE = 9;
pub const MMAL_CAMERA_RX_CONFIG_DECODE_MMAL_CAMERA_RX_CONFIG_DECODE_DPCM10TO16:
    MMAL_CAMERA_RX_CONFIG_DECODE = 10;
pub const MMAL_CAMERA_RX_CONFIG_DECODE_MMAL_CAMERA_RX_CONFIG_DECODE_DPCM8TO16:
    MMAL_CAMERA_RX_CONFIG_DECODE = 11;
pub const MMAL_CAMERA_RX_CONFIG_DECODE_MMAL_CAMERA_RX_CONFIG_DECODE_MAX:
    MMAL_CAMERA_RX_CONFIG_DECODE = 2147483647;
pub type MMAL_CAMERA_RX_CONFIG_DECODE = u32;
pub const MMAL_CAMERA_RX_CONFIG_ENCODE_MMAL_CAMERA_RX_CONFIG_ENCODE_NONE:
    MMAL_CAMERA_RX_CONFIG_ENCODE = 0;
pub const MMAL_CAMERA_RX_CONFIG_ENCODE_MMAL_CAMERA_RX_CONFIG_ENCODE_DPCM10TO8:
    MMAL_CAMERA_RX_CONFIG_ENCODE = 1;
pub const MMAL_CAMERA_RX_CONFIG_ENCODE_MMAL_CAMERA_RX_CONFIG_ENCODE_DPCM12TO8:
    MMAL_CAMERA_RX_CONFIG_ENCODE = 2;
pub const MMAL_CAMERA_RX_CONFIG_ENCODE_MMAL_CAMERA_RX_CONFIG_ENCODE_DPCM14TO8:
    MMAL_CAMERA_RX_CONFIG_ENCODE = 3;
pub const MMAL_CAMERA_RX_CONFIG_ENCODE_MMAL_CAMERA_RX_CONFIG_ENCODE_MAX:
    MMAL_CAMERA_RX_CONFIG_ENCODE = 2147483647;
pub type MMAL_CAMERA_RX_CONFIG_ENCODE = u32;
pub const MMAL_CAMERA_RX_CONFIG_UNPACK_MMAL_CAMERA_RX_CONFIG_UNPACK_NONE:
    MMAL_CAMERA_RX_CONFIG_UNPACK = 0;
pub const MMAL_CAMERA_RX_CONFIG_UNPACK_MMAL_CAMERA_RX_CONFIG_UNPACK_6:
    MMAL_CAMERA_RX_CONFIG_UNPACK = 1;
pub const MMAL_CAMERA_RX_CONFIG_UNPACK_MMAL_CAMERA_RX_CONFIG_UNPACK_7:
    MMAL_CAMERA_RX_CONFIG_UNPACK = 2;
pub const MMAL_CAMERA_RX_CONFIG_UNPACK_MMAL_CAMERA_RX_CONFIG_UNPACK_8:
    MMAL_CAMERA_RX_CONFIG_UNPACK = 3;
pub const MMAL_CAMERA_RX_CONFIG_UNPACK_MMAL_CAMERA_RX_CONFIG_UNPACK_10:
    MMAL_CAMERA_RX_CONFIG_UNPACK = 4;
pub const MMAL_CAMERA_RX_CONFIG_UNPACK_MMAL_CAMERA_RX_CONFIG_UNPACK_12:
    MMAL_CAMERA_RX_CONFIG_UNPACK = 5;
pub const MMAL_CAMERA_RX_CONFIG_UNPACK_MMAL_CAMERA_RX_CONFIG_UNPACK_14:
    MMAL_CAMERA_RX_CONFIG_UNPACK = 6;
pub const MMAL_CAMERA_RX_CONFIG_UNPACK_MMAL_CAMERA_RX_CONFIG_UNPACK_16:
    MMAL_CAMERA_RX_CONFIG_UNPACK = 7;
pub const MMAL_CAMERA_RX_CONFIG_UNPACK_MMAL_CAMERA_RX_CONFIG_UNPACK_MAX:
    MMAL_CAMERA_RX_CONFIG_UNPACK = 2147483647;
pub type MMAL_CAMERA_RX_CONFIG_UNPACK = u32;
pub const MMAL_CAMERA_RX_CONFIG_PACK_MMAL_CAMERA_RX_CONFIG_PACK_NONE: MMAL_CAMERA_RX_CONFIG_PACK =
    0;
pub const MMAL_CAMERA_RX_CONFIG_PACK_MMAL_CAMERA_RX_CONFIG_PACK_8: MMAL_CAMERA_RX_CONFIG_PACK = 1;
pub const MMAL_CAMERA_RX_CONFIG_PACK_MMAL_CAMERA_RX_CONFIG_PACK_10: MMAL_CAMERA_RX_CONFIG_PACK = 2;
pub const MMAL_CAMERA_RX_CONFIG_PACK_MMAL_CAMERA_RX_CONFIG_PACK_12: MMAL_CAMERA_RX_CONFIG_PACK = 3;
pub const MMAL_CAMERA_RX_CONFIG_PACK_MMAL_CAMERA_RX_CONFIG_PACK_14: MMAL_CAMERA_RX_CONFIG_PACK = 4;
pub const MMAL_CAMERA_RX_CONFIG_PACK_MMAL_CAMERA_RX_CONFIG_PACK_16: MMAL_CAMERA_RX_CONFIG_PACK = 5;
pub const MMAL_CAMERA_RX_CONFIG_PACK_MMAL_CAMERA_RX_CONFIG_PACK_RAW10: MMAL_CAMERA_RX_CONFIG_PACK =
    6;
pub const MMAL_CAMERA_RX_CONFIG_PACK_MMAL_CAMERA_RX_CONFIG_PACK_RAW12: MMAL_CAMERA_RX_CONFIG_PACK =
    7;
pub const MMAL_CAMERA_RX_CONFIG_PACK_MMAL_CAMERA_RX_CONFIG_PACK_MAX: MMAL_CAMERA_RX_CONFIG_PACK =
    2147483647;
pub type MMAL_CAMERA_RX_CONFIG_PACK = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_CAMERA_RX_CONFIG_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    pub decode: MMAL_CAMERA_RX_CONFIG_DECODE,
    pub encode: MMAL_CAMERA_RX_CONFIG_ENCODE,
    pub unpack: MMAL_CAMERA_RX_CONFIG_UNPACK,
    pub pack: MMAL_CAMERA_RX_CONFIG_PACK,
    pub data_lanes: u32,
    pub encode_block_length: u32,
    pub embedded_data_lines: u32,
    pub image_id: u32,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_CAMERA_RX_CONFIG_T() {
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_CAMERA_RX_CONFIG_T>(),
        40usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_CAMERA_RX_CONFIG_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_CAMERA_RX_CONFIG_T>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(MMAL_PARAMETER_CAMERA_RX_CONFIG_T)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CAMERA_RX_CONFIG_T>())).hdr as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_RX_CONFIG_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CAMERA_RX_CONFIG_T>())).decode as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_RX_CONFIG_T),
            "::",
            stringify!(decode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CAMERA_RX_CONFIG_T>())).encode as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_RX_CONFIG_T),
            "::",
            stringify!(encode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CAMERA_RX_CONFIG_T>())).unpack as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_RX_CONFIG_T),
            "::",
            stringify!(unpack)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CAMERA_RX_CONFIG_T>())).pack as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_RX_CONFIG_T),
            "::",
            stringify!(pack)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CAMERA_RX_CONFIG_T>())).data_lanes as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_RX_CONFIG_T),
            "::",
            stringify!(data_lanes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CAMERA_RX_CONFIG_T>())).encode_block_length
                as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_RX_CONFIG_T),
            "::",
            stringify!(encode_block_length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CAMERA_RX_CONFIG_T>())).embedded_data_lines
                as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_RX_CONFIG_T),
            "::",
            stringify!(embedded_data_lines)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CAMERA_RX_CONFIG_T>())).image_id as *const _
                as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_RX_CONFIG_T),
            "::",
            stringify!(image_id)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_CAMERA_RX_TIMING_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    pub timing1: u32,
    pub timing2: u32,
    pub timing3: u32,
    pub timing4: u32,
    pub timing5: u32,
    pub term1: u32,
    pub term2: u32,
    pub cpi_timing1: u32,
    pub cpi_timing2: u32,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_CAMERA_RX_TIMING_T() {
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_CAMERA_RX_TIMING_T>(),
        44usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_CAMERA_RX_TIMING_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_CAMERA_RX_TIMING_T>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(MMAL_PARAMETER_CAMERA_RX_TIMING_T)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CAMERA_RX_TIMING_T>())).hdr as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_RX_TIMING_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CAMERA_RX_TIMING_T>())).timing1 as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_RX_TIMING_T),
            "::",
            stringify!(timing1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CAMERA_RX_TIMING_T>())).timing2 as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_RX_TIMING_T),
            "::",
            stringify!(timing2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CAMERA_RX_TIMING_T>())).timing3 as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_RX_TIMING_T),
            "::",
            stringify!(timing3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CAMERA_RX_TIMING_T>())).timing4 as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_RX_TIMING_T),
            "::",
            stringify!(timing4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CAMERA_RX_TIMING_T>())).timing5 as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_RX_TIMING_T),
            "::",
            stringify!(timing5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CAMERA_RX_TIMING_T>())).term1 as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_RX_TIMING_T),
            "::",
            stringify!(term1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CAMERA_RX_TIMING_T>())).term2 as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_RX_TIMING_T),
            "::",
            stringify!(term2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CAMERA_RX_TIMING_T>())).cpi_timing1 as *const _
                as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_RX_TIMING_T),
            "::",
            stringify!(cpi_timing1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CAMERA_RX_TIMING_T>())).cpi_timing2 as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_RX_TIMING_T),
            "::",
            stringify!(cpi_timing2)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_LENS_SHADING_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    pub enabled: MMAL_BOOL_T,
    pub grid_cell_size: u32,
    pub grid_width: u32,
    pub grid_stride: u32,
    pub grid_height: u32,
    pub mem_handle_table: u32,
    pub ref_transform: u32,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_LENS_SHADING_T() {
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_LENS_SHADING_T>(),
        36usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_LENS_SHADING_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_LENS_SHADING_T>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_PARAMETER_LENS_SHADING_T))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_LENS_SHADING_T>())).hdr as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_LENS_SHADING_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_LENS_SHADING_T>())).enabled as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_LENS_SHADING_T),
            "::",
            stringify!(enabled)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_LENS_SHADING_T>())).grid_cell_size as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_LENS_SHADING_T),
            "::",
            stringify!(grid_cell_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_LENS_SHADING_T>())).grid_width as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_LENS_SHADING_T),
            "::",
            stringify!(grid_width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_LENS_SHADING_T>())).grid_stride as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_LENS_SHADING_T),
            "::",
            stringify!(grid_stride)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_LENS_SHADING_T>())).grid_height as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_LENS_SHADING_T),
            "::",
            stringify!(grid_height)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_LENS_SHADING_T>())).mem_handle_table as *const _
                as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_LENS_SHADING_T),
            "::",
            stringify!(mem_handle_table)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_LENS_SHADING_T>())).ref_transform as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_LENS_SHADING_T),
            "::",
            stringify!(ref_transform)
        )
    );
}
pub const MMAL_RESIZEMODE_T_MMAL_RESIZE_NONE: MMAL_RESIZEMODE_T = 0;
pub const MMAL_RESIZEMODE_T_MMAL_RESIZE_CROP: MMAL_RESIZEMODE_T = 1;
pub const MMAL_RESIZEMODE_T_MMAL_RESIZE_BOX: MMAL_RESIZEMODE_T = 2;
pub const MMAL_RESIZEMODE_T_MMAL_RESIZE_BYTES: MMAL_RESIZEMODE_T = 3;
pub const MMAL_RESIZEMODE_T_MMAL_RESIZE_DUMMY: MMAL_RESIZEMODE_T = 2147483647;
pub type MMAL_RESIZEMODE_T = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_RESIZE_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    pub mode: MMAL_RESIZEMODE_T,
    pub max_width: u32,
    pub max_height: u32,
    pub max_bytes: u32,
    pub preserve_aspect_ratio: MMAL_BOOL_T,
    pub allow_upscaling: MMAL_BOOL_T,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_RESIZE_T() {
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_RESIZE_T>(),
        32usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_RESIZE_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_RESIZE_T>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_PARAMETER_RESIZE_T))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_PARAMETER_RESIZE_T>())).hdr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_RESIZE_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_PARAMETER_RESIZE_T>())).mode as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_RESIZE_T),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_RESIZE_T>())).max_width as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_RESIZE_T),
            "::",
            stringify!(max_width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_RESIZE_T>())).max_height as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_RESIZE_T),
            "::",
            stringify!(max_height)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_RESIZE_T>())).max_bytes as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_RESIZE_T),
            "::",
            stringify!(max_bytes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_RESIZE_T>())).preserve_aspect_ratio as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_RESIZE_T),
            "::",
            stringify!(preserve_aspect_ratio)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_RESIZE_T>())).allow_upscaling as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_RESIZE_T),
            "::",
            stringify!(allow_upscaling)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_CROP_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    pub rect: MMAL_RECT_T,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_CROP_T() {
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_CROP_T>(),
        24usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_CROP_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_CROP_T>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_PARAMETER_CROP_T))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_PARAMETER_CROP_T>())).hdr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CROP_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_PARAMETER_CROP_T>())).rect as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CROP_T),
            "::",
            stringify!(rect)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_CCM_T {
    pub ccm: [[MMAL_RATIONAL_T; 3usize]; 3usize],
    pub offsets: [i32; 3usize],
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_CCM_T() {
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_CCM_T>(),
        84usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_CCM_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_CCM_T>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_PARAMETER_CCM_T))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_PARAMETER_CCM_T>())).ccm as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CCM_T),
            "::",
            stringify!(ccm)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_PARAMETER_CCM_T>())).offsets as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CCM_T),
            "::",
            stringify!(offsets)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_CUSTOM_CCM_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    #[doc = "< Enable the custom CCM."]
    pub enable: MMAL_BOOL_T,
    #[doc = "< CCM to be used."]
    pub ccm: MMAL_PARAMETER_CCM_T,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_CUSTOM_CCM_T() {
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_CUSTOM_CCM_T>(),
        96usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_CUSTOM_CCM_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_CUSTOM_CCM_T>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_PARAMETER_CUSTOM_CCM_T))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_PARAMETER_CUSTOM_CCM_T>())).hdr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CUSTOM_CCM_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CUSTOM_CCM_T>())).enable as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CUSTOM_CCM_T),
            "::",
            stringify!(enable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_PARAMETER_CUSTOM_CCM_T>())).ccm as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CUSTOM_CCM_T),
            "::",
            stringify!(ccm)
        )
    );
}
#[doc = "< Takes a @ref MMAL_DISPLAYREGION_T"]
pub const MMAL_PARAMETER_DISPLAYREGION: _bindgen_ty_27 = 131072;
#[doc = "< Takes a @ref MMAL_PARAMETER_VIDEO_PROFILE_T"]
pub const MMAL_PARAMETER_SUPPORTED_PROFILES: _bindgen_ty_27 = 131073;
#[doc = "< Takes a @ref MMAL_PARAMETER_VIDEO_PROFILE_T"]
pub const MMAL_PARAMETER_PROFILE: _bindgen_ty_27 = 131074;
#[doc = "< Takes a @ref MMAL_PARAMETER_UINT32_T"]
pub const MMAL_PARAMETER_INTRAPERIOD: _bindgen_ty_27 = 131075;
#[doc = "< Takes a @ref MMAL_PARAMETER_VIDEO_RATECONTROL_T"]
pub const MMAL_PARAMETER_RATECONTROL: _bindgen_ty_27 = 131076;
#[doc = "< Takes a @ref MMAL_PARAMETER_VIDEO_NALUNITFORMAT_T"]
pub const MMAL_PARAMETER_NALUNITFORMAT: _bindgen_ty_27 = 131077;
#[doc = "< Takes a @ref MMAL_PARAMETER_BOOLEAN_T"]
pub const MMAL_PARAMETER_MINIMISE_FRAGMENTATION: _bindgen_ty_27 = 131078;
#[doc = "< Takes a @ref MMAL_PARAMETER_UINT32_T."]
#[doc = " Setting the value to zero resets to the default (one slice per frame)."]
pub const MMAL_PARAMETER_MB_ROWS_PER_SLICE: _bindgen_ty_27 = 131079;
#[doc = "< Takes a @ref MMAL_PARAMETER_VIDEO_LEVEL_EXTENSION_T"]
pub const MMAL_PARAMETER_VIDEO_LEVEL_EXTENSION: _bindgen_ty_27 = 131080;
#[doc = "< Takes a @ref MMAL_PARAMETER_VIDEO_EEDE_ENABLE_T"]
pub const MMAL_PARAMETER_VIDEO_EEDE_ENABLE: _bindgen_ty_27 = 131081;
#[doc = "< Takes a @ref MMAL_PARAMETER_VIDEO_EEDE_LOSSRATE_T"]
pub const MMAL_PARAMETER_VIDEO_EEDE_LOSSRATE: _bindgen_ty_27 = 131082;
#[doc = "< Takes a @ref MMAL_PARAMETER_BOOLEAN_T."]
#[doc = " Request an I-frame."]
pub const MMAL_PARAMETER_VIDEO_REQUEST_I_FRAME: _bindgen_ty_27 = 131083;
#[doc = "< Takes a @ref MMAL_PARAMETER_VIDEO_INTRA_REFRESH_T"]
pub const MMAL_PARAMETER_VIDEO_INTRA_REFRESH: _bindgen_ty_27 = 131084;
#[doc = "< Takes a @ref MMAL_PARAMETER_BOOLEAN_T."]
pub const MMAL_PARAMETER_VIDEO_IMMUTABLE_INPUT: _bindgen_ty_27 = 131085;
#[doc = "< Takes a @ref MMAL_PARAMETER_UINT32_T."]
#[doc = " Run-time bit rate control"]
pub const MMAL_PARAMETER_VIDEO_BIT_RATE: _bindgen_ty_27 = 131086;
#[doc = "< Takes a @ref MMAL_PARAMETER_FRAME_RATE_T"]
pub const MMAL_PARAMETER_VIDEO_FRAME_RATE: _bindgen_ty_27 = 131087;
#[doc = "< Takes a @ref MMAL_PARAMETER_UINT32_T."]
pub const MMAL_PARAMETER_VIDEO_ENCODE_MIN_QUANT: _bindgen_ty_27 = 131088;
#[doc = "< Takes a @ref MMAL_PARAMETER_UINT32_T."]
pub const MMAL_PARAMETER_VIDEO_ENCODE_MAX_QUANT: _bindgen_ty_27 = 131089;
#[doc = "< Takes a @ref MMAL_PARAMETER_VIDEO_ENCODE_RC_MODEL_T."]
pub const MMAL_PARAMETER_VIDEO_ENCODE_RC_MODEL: _bindgen_ty_27 = 131090;
#[doc = "< Takes a @ref MMAL_PARAMETER_UINT32_T."]
pub const MMAL_PARAMETER_EXTRA_BUFFERS: _bindgen_ty_27 = 131091;
#[doc = "< Takes a @ref MMAL_PARAMETER_UINT32_T."]
#[doc = "Changing this paramater from the default can reduce frame rate"]
#[doc = "because image buffers need to be re-pitched."]
pub const MMAL_PARAMETER_VIDEO_ALIGN_HORIZ: _bindgen_ty_27 = 131092;
#[doc = "< Takes a @ref MMAL_PARAMETER_UINT32_T."]
#[doc = "Changing this paramater from the default can reduce frame rate"]
#[doc = "because image buffers need to be re-pitched."]
pub const MMAL_PARAMETER_VIDEO_ALIGN_VERT: _bindgen_ty_27 = 131093;
#[doc = "< Take a @ref MMAL_PARAMETER_BOOLEAN_T."]
pub const MMAL_PARAMETER_VIDEO_DROPPABLE_PFRAMES: _bindgen_ty_27 = 131094;
#[doc = "< Takes a @ref MMAL_PARAMETER_UINT32_T."]
pub const MMAL_PARAMETER_VIDEO_ENCODE_INITIAL_QUANT: _bindgen_ty_27 = 131095;
#[doc = "< Takes a @ref MMAL_PARAMETER_UINT32_T."]
pub const MMAL_PARAMETER_VIDEO_ENCODE_QP_P: _bindgen_ty_27 = 131096;
#[doc = "< Takes a @ref MMAL_PARAMETER_UINT32_T."]
pub const MMAL_PARAMETER_VIDEO_ENCODE_RC_SLICE_DQUANT: _bindgen_ty_27 = 131097;
#[doc = "< Takes a @ref MMAL_PARAMETER_UINT32_T"]
pub const MMAL_PARAMETER_VIDEO_ENCODE_FRAME_LIMIT_BITS: _bindgen_ty_27 = 131098;
#[doc = "< Takes a @ref MMAL_PARAMETER_UINT32_T."]
pub const MMAL_PARAMETER_VIDEO_ENCODE_PEAK_RATE: _bindgen_ty_27 = 131099;
#[doc = "< Take a @ref MMAL_PARAMETER_BOOLEAN_T."]
pub const MMAL_PARAMETER_VIDEO_ENCODE_H264_DISABLE_CABAC: _bindgen_ty_27 = 131100;
#[doc = "< Take a @ref MMAL_PARAMETER_BOOLEAN_T."]
pub const MMAL_PARAMETER_VIDEO_ENCODE_H264_LOW_LATENCY: _bindgen_ty_27 = 131101;
#[doc = "< Take a @ref MMAL_PARAMETER_BOOLEAN_T."]
pub const MMAL_PARAMETER_VIDEO_ENCODE_H264_AU_DELIMITERS: _bindgen_ty_27 = 131102;
#[doc = "< Takes a @ref MMAL_PARAMETER_UINT32_T."]
pub const MMAL_PARAMETER_VIDEO_ENCODE_H264_DEBLOCK_IDC: _bindgen_ty_27 = 131103;
#[doc = "< Takes a @ref MMAL_PARAMETER_VIDEO_ENCODER_H264_MB_INTRA_MODES_T."]
pub const MMAL_PARAMETER_VIDEO_ENCODE_H264_MB_INTRA_MODE: _bindgen_ty_27 = 131104;
#[doc = "< Takes a @ref MMAL_PARAMETER_BOOLEAN_T"]
pub const MMAL_PARAMETER_VIDEO_ENCODE_HEADER_ON_OPEN: _bindgen_ty_27 = 131105;
#[doc = "< Takes a @ref MMAL_PARAMETER_BOOLEAN_T"]
pub const MMAL_PARAMETER_VIDEO_ENCODE_PRECODE_FOR_QP: _bindgen_ty_27 = 131106;
#[doc = "< Takes a @ref MMAL_PARAMETER_VIDEO_DRM_INIT_INFO_T."]
pub const MMAL_PARAMETER_VIDEO_DRM_INIT_INFO: _bindgen_ty_27 = 131107;
#[doc = "< Takes a @ref MMAL_PARAMETER_BOOLEAN_T"]
pub const MMAL_PARAMETER_VIDEO_TIMESTAMP_FIFO: _bindgen_ty_27 = 131108;
#[doc = "< Takes a @ref MMAL_PARAMETER_BOOLEAN_T"]
pub const MMAL_PARAMETER_VIDEO_DECODE_ERROR_CONCEALMENT: _bindgen_ty_27 = 131109;
#[doc = "< Takes a @ref MMAL_PARAMETER_VIDEO_DRM_PROTECT_BUFFER_T."]
pub const MMAL_PARAMETER_VIDEO_DRM_PROTECT_BUFFER: _bindgen_ty_27 = 131110;
#[doc = "< Takes a @ref MMAL_PARAMETER_BYTES_T"]
pub const MMAL_PARAMETER_VIDEO_DECODE_CONFIG_VD3: _bindgen_ty_27 = 131111;
#[doc = "< Take a @ref MMAL_PARAMETER_BOOLEAN_T."]
pub const MMAL_PARAMETER_VIDEO_ENCODE_H264_VCL_HRD_PARAMETERS: _bindgen_ty_27 = 131112;
#[doc = "< Take a @ref MMAL_PARAMETER_BOOLEAN_T."]
pub const MMAL_PARAMETER_VIDEO_ENCODE_H264_LOW_DELAY_HRD_FLAG: _bindgen_ty_27 = 131113;
#[doc = "< Take a @ref MMAL_PARAMETER_BOOLEAN_T."]
pub const MMAL_PARAMETER_VIDEO_ENCODE_INLINE_HEADER: _bindgen_ty_27 = 131114;
#[doc = "< Take a @ref MMAL_PARAMETER_BOOLEAN_T."]
pub const MMAL_PARAMETER_VIDEO_ENCODE_SEI_ENABLE: _bindgen_ty_27 = 131115;
#[doc = "< Take a @ref MMAL_PARAMETER_BOOLEAN_T."]
pub const MMAL_PARAMETER_VIDEO_ENCODE_INLINE_VECTORS: _bindgen_ty_27 = 131116;
#[doc = "< Take a @ref MMAL_PARAMETER_VIDEO_RENDER_STATS_T."]
pub const MMAL_PARAMETER_VIDEO_RENDER_STATS: _bindgen_ty_27 = 131117;
#[doc = "< Take a @ref MMAL_PARAMETER_VIDEO_INTERLACE_TYPE_T."]
pub const MMAL_PARAMETER_VIDEO_INTERLACE_TYPE: _bindgen_ty_27 = 131118;
#[doc = "< Takes a @ref MMAL_PARAMETER_BOOLEAN_T"]
pub const MMAL_PARAMETER_VIDEO_INTERPOLATE_TIMESTAMPS: _bindgen_ty_27 = 131119;
#[doc = "< Take a @ref MMAL_PARAMETER_BOOLEAN_T"]
pub const MMAL_PARAMETER_VIDEO_ENCODE_SPS_TIMING: _bindgen_ty_27 = 131120;
#[doc = "< Take a @ref MMAL_PARAMETER_UINT32_T"]
pub const MMAL_PARAMETER_VIDEO_MAX_NUM_CALLBACKS: _bindgen_ty_27 = 131121;
#[doc = "< Take a @ref MMAL_PARAMETER_SOURCE_PATTERN_T"]
pub const MMAL_PARAMETER_VIDEO_SOURCE_PATTERN: _bindgen_ty_27 = 131122;
#[doc = "< Take a @ref MMAL_PARAMETER_BOOLEAN_T"]
pub const MMAL_PARAMETER_VIDEO_ENCODE_SEPARATE_NAL_BUFS: _bindgen_ty_27 = 131123;
#[doc = "< Take a @ref MMAL_PARAMETER_UINT32_T"]
pub const MMAL_PARAMETER_VIDEO_DROPPABLE_PFRAME_LENGTH: _bindgen_ty_27 = 131124;
#[doc = " Video-specific MMAL parameter IDs."]
#[doc = " @ingroup MMAL_PARAMETER_IDS"]
pub type _bindgen_ty_27 = u32;
pub const MMAL_DISPLAYTRANSFORM_T_MMAL_DISPLAY_ROT0: MMAL_DISPLAYTRANSFORM_T = 0;
pub const MMAL_DISPLAYTRANSFORM_T_MMAL_DISPLAY_MIRROR_ROT0: MMAL_DISPLAYTRANSFORM_T = 1;
pub const MMAL_DISPLAYTRANSFORM_T_MMAL_DISPLAY_MIRROR_ROT180: MMAL_DISPLAYTRANSFORM_T = 2;
pub const MMAL_DISPLAYTRANSFORM_T_MMAL_DISPLAY_ROT180: MMAL_DISPLAYTRANSFORM_T = 3;
pub const MMAL_DISPLAYTRANSFORM_T_MMAL_DISPLAY_MIRROR_ROT90: MMAL_DISPLAYTRANSFORM_T = 4;
pub const MMAL_DISPLAYTRANSFORM_T_MMAL_DISPLAY_ROT270: MMAL_DISPLAYTRANSFORM_T = 5;
pub const MMAL_DISPLAYTRANSFORM_T_MMAL_DISPLAY_ROT90: MMAL_DISPLAYTRANSFORM_T = 6;
pub const MMAL_DISPLAYTRANSFORM_T_MMAL_DISPLAY_MIRROR_ROT270: MMAL_DISPLAYTRANSFORM_T = 7;
pub const MMAL_DISPLAYTRANSFORM_T_MMAL_DISPLAY_DUMMY: MMAL_DISPLAYTRANSFORM_T = 2147483647;
#[doc = " Display transformations."]
#[doc = " Although an enumeration, the values correspond to combinations of:"]
#[doc = " \\li 1 Reflect in a vertical axis"]
#[doc = " \\li 2 180 degree rotation"]
#[doc = " \\li 4 Reflect in the leading diagonal"]
pub type MMAL_DISPLAYTRANSFORM_T = u32;
pub const MMAL_DISPLAYMODE_T_MMAL_DISPLAY_MODE_FILL: MMAL_DISPLAYMODE_T = 0;
pub const MMAL_DISPLAYMODE_T_MMAL_DISPLAY_MODE_LETTERBOX: MMAL_DISPLAYMODE_T = 1;
pub const MMAL_DISPLAYMODE_T_MMAL_DISPLAY_MODE_STEREO_LEFT_TO_LEFT: MMAL_DISPLAYMODE_T = 2;
pub const MMAL_DISPLAYMODE_T_MMAL_DISPLAY_MODE_STEREO_TOP_TO_TOP: MMAL_DISPLAYMODE_T = 3;
pub const MMAL_DISPLAYMODE_T_MMAL_DISPLAY_MODE_STEREO_LEFT_TO_TOP: MMAL_DISPLAYMODE_T = 4;
pub const MMAL_DISPLAYMODE_T_MMAL_DISPLAY_MODE_STEREO_TOP_TO_LEFT: MMAL_DISPLAYMODE_T = 5;
pub const MMAL_DISPLAYMODE_T_MMAL_DISPLAY_MODE_DUMMY: MMAL_DISPLAYMODE_T = 2147483647;
#[doc = " Display modes."]
pub type MMAL_DISPLAYMODE_T = u32;
pub const MMAL_DISPLAYSET_T_MMAL_DISPLAY_SET_NONE: MMAL_DISPLAYSET_T = 0;
pub const MMAL_DISPLAYSET_T_MMAL_DISPLAY_SET_NUM: MMAL_DISPLAYSET_T = 1;
pub const MMAL_DISPLAYSET_T_MMAL_DISPLAY_SET_FULLSCREEN: MMAL_DISPLAYSET_T = 2;
pub const MMAL_DISPLAYSET_T_MMAL_DISPLAY_SET_TRANSFORM: MMAL_DISPLAYSET_T = 4;
pub const MMAL_DISPLAYSET_T_MMAL_DISPLAY_SET_DEST_RECT: MMAL_DISPLAYSET_T = 8;
pub const MMAL_DISPLAYSET_T_MMAL_DISPLAY_SET_SRC_RECT: MMAL_DISPLAYSET_T = 16;
pub const MMAL_DISPLAYSET_T_MMAL_DISPLAY_SET_MODE: MMAL_DISPLAYSET_T = 32;
pub const MMAL_DISPLAYSET_T_MMAL_DISPLAY_SET_PIXEL: MMAL_DISPLAYSET_T = 64;
pub const MMAL_DISPLAYSET_T_MMAL_DISPLAY_SET_NOASPECT: MMAL_DISPLAYSET_T = 128;
pub const MMAL_DISPLAYSET_T_MMAL_DISPLAY_SET_LAYER: MMAL_DISPLAYSET_T = 256;
pub const MMAL_DISPLAYSET_T_MMAL_DISPLAY_SET_COPYPROTECT: MMAL_DISPLAYSET_T = 512;
pub const MMAL_DISPLAYSET_T_MMAL_DISPLAY_SET_ALPHA: MMAL_DISPLAYSET_T = 1024;
pub const MMAL_DISPLAYSET_T_MMAL_DISPLAY_SET_DUMMY: MMAL_DISPLAYSET_T = 2147483647;
#[doc = " Values used to indicate which fields are used when setting the"]
#[doc = " display configuration"]
pub type MMAL_DISPLAYSET_T = u32;
pub const MMAL_DISPLAYALPHAFLAGS_T_MMAL_DISPLAY_ALPHA_FLAGS_NONE: MMAL_DISPLAYALPHAFLAGS_T = 0;
pub const MMAL_DISPLAYALPHAFLAGS_T_MMAL_DISPLAY_ALPHA_FLAGS_DISCARD_LOWER_LAYERS:
    MMAL_DISPLAYALPHAFLAGS_T = 536870912;
pub const MMAL_DISPLAYALPHAFLAGS_T_MMAL_DISPLAY_ALPHA_FLAGS_PREMULT: MMAL_DISPLAYALPHAFLAGS_T =
    1073741824;
pub const MMAL_DISPLAYALPHAFLAGS_T_MMAL_DISPLAY_ALPHA_FLAGS_MIX: MMAL_DISPLAYALPHAFLAGS_T =
    -2147483648;
pub type MMAL_DISPLAYALPHAFLAGS_T = i32;
#[doc = "This config sets the output display device, as well as the region used"]
#[doc = "on the output display, any display transformation, and some flags to"]
#[doc = "indicate how to scale the image."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_DISPLAYREGION_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    #[doc = " Bitfield that indicates which fields are set and should be used. All"]
    #[doc = " other fields will maintain their current value."]
    #[doc = " \\ref MMAL_DISPLAYSET_T defines the bits that can be combined."]
    pub set: u32,
    #[doc = " Describes the display output device, with 0 typically being a directly"]
    #[doc = " connected LCD display.  The actual values will depend on the hardware."]
    #[doc = " Code using hard-wired numbers (e.g. 2) is certain to fail."]
    pub display_num: u32,
    #[doc = " Indicates that we are using the full device screen area, rather than"]
    #[doc = " a window of the display.  If zero, then dest_rect is used to specify a"]
    #[doc = " region of the display to use."]
    pub fullscreen: MMAL_BOOL_T,
    #[doc = " Indicates any rotation or flipping used to map frames onto the natural"]
    #[doc = " display orientation."]
    pub transform: MMAL_DISPLAYTRANSFORM_T,
    #[doc = " Where to display the frame within the screen, if fullscreen is zero."]
    pub dest_rect: MMAL_RECT_T,
    #[doc = " Indicates which area of the frame to display. If all values are zero,"]
    #[doc = " the whole frame will be used."]
    pub src_rect: MMAL_RECT_T,
    #[doc = " If set to non-zero, indicates that any display scaling should disregard"]
    #[doc = " the aspect ratio of the frame region being displayed."]
    pub noaspect: MMAL_BOOL_T,
    #[doc = " Indicates how the image should be scaled to fit the display. \\code"]
    #[doc = " MMAL_DISPLAY_MODE_FILL \\endcode indicates that the image should fill the"]
    #[doc = " screen by potentially cropping the frames.  Setting \\code mode \\endcode"]
    #[doc = " to \\code MMAL_DISPLAY_MODE_LETTERBOX \\endcode indicates that all the source"]
    #[doc = " region should be displayed and black bars added if necessary."]
    pub mode: MMAL_DISPLAYMODE_T,
    #[doc = " If non-zero, defines the width of a source pixel relative to \\code pixel_y"]
    #[doc = " \\endcode.  If zero, then pixels default to being square."]
    pub pixel_x: u32,
    #[doc = " If non-zero, defines the height of a source pixel relative to \\code pixel_x"]
    #[doc = " \\endcode.  If zero, then pixels default to being square."]
    pub pixel_y: u32,
    #[doc = " Sets the relative depth of the images, with greater values being in front"]
    #[doc = " of smaller values."]
    pub layer: i32,
    #[doc = " Set to non-zero to ensure copy protection is used on output."]
    pub copyprotect_required: MMAL_BOOL_T,
    #[doc = " Bits 7-0: Level of opacity of the layer, where zero is fully transparent and"]
    #[doc = " 255 is fully opaque."]
    #[doc = " Bits 31-8: Flags from \\code MMAL_DISPLAYALPHAFLAGS_T for alpha mode selection."]
    pub alpha: u32,
}
#[test]
fn bindgen_test_layout_MMAL_DISPLAYREGION_T() {
    assert_eq!(
        ::std::mem::size_of::<MMAL_DISPLAYREGION_T>(),
        84usize,
        concat!("Size of: ", stringify!(MMAL_DISPLAYREGION_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_DISPLAYREGION_T>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_DISPLAYREGION_T))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_DISPLAYREGION_T>())).hdr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_DISPLAYREGION_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_DISPLAYREGION_T>())).set as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_DISPLAYREGION_T),
            "::",
            stringify!(set)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_DISPLAYREGION_T>())).display_num as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_DISPLAYREGION_T),
            "::",
            stringify!(display_num)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_DISPLAYREGION_T>())).fullscreen as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_DISPLAYREGION_T),
            "::",
            stringify!(fullscreen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_DISPLAYREGION_T>())).transform as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_DISPLAYREGION_T),
            "::",
            stringify!(transform)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_DISPLAYREGION_T>())).dest_rect as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_DISPLAYREGION_T),
            "::",
            stringify!(dest_rect)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_DISPLAYREGION_T>())).src_rect as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_DISPLAYREGION_T),
            "::",
            stringify!(src_rect)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_DISPLAYREGION_T>())).noaspect as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_DISPLAYREGION_T),
            "::",
            stringify!(noaspect)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_DISPLAYREGION_T>())).mode as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_DISPLAYREGION_T),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_DISPLAYREGION_T>())).pixel_x as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_DISPLAYREGION_T),
            "::",
            stringify!(pixel_x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_DISPLAYREGION_T>())).pixel_y as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_DISPLAYREGION_T),
            "::",
            stringify!(pixel_y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_DISPLAYREGION_T>())).layer as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_DISPLAYREGION_T),
            "::",
            stringify!(layer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_DISPLAYREGION_T>())).copyprotect_required as *const _
                as usize
        },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_DISPLAYREGION_T),
            "::",
            stringify!(copyprotect_required)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_DISPLAYREGION_T>())).alpha as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_DISPLAYREGION_T),
            "::",
            stringify!(alpha)
        )
    );
}
pub const MMAL_VIDEO_PROFILE_T_MMAL_VIDEO_PROFILE_H263_BASELINE: MMAL_VIDEO_PROFILE_T = 0;
pub const MMAL_VIDEO_PROFILE_T_MMAL_VIDEO_PROFILE_H263_H320CODING: MMAL_VIDEO_PROFILE_T = 1;
pub const MMAL_VIDEO_PROFILE_T_MMAL_VIDEO_PROFILE_H263_BACKWARDCOMPATIBLE: MMAL_VIDEO_PROFILE_T = 2;
pub const MMAL_VIDEO_PROFILE_T_MMAL_VIDEO_PROFILE_H263_ISWV2: MMAL_VIDEO_PROFILE_T = 3;
pub const MMAL_VIDEO_PROFILE_T_MMAL_VIDEO_PROFILE_H263_ISWV3: MMAL_VIDEO_PROFILE_T = 4;
pub const MMAL_VIDEO_PROFILE_T_MMAL_VIDEO_PROFILE_H263_HIGHCOMPRESSION: MMAL_VIDEO_PROFILE_T = 5;
pub const MMAL_VIDEO_PROFILE_T_MMAL_VIDEO_PROFILE_H263_INTERNET: MMAL_VIDEO_PROFILE_T = 6;
pub const MMAL_VIDEO_PROFILE_T_MMAL_VIDEO_PROFILE_H263_INTERLACE: MMAL_VIDEO_PROFILE_T = 7;
pub const MMAL_VIDEO_PROFILE_T_MMAL_VIDEO_PROFILE_H263_HIGHLATENCY: MMAL_VIDEO_PROFILE_T = 8;
pub const MMAL_VIDEO_PROFILE_T_MMAL_VIDEO_PROFILE_MP4V_SIMPLE: MMAL_VIDEO_PROFILE_T = 9;
pub const MMAL_VIDEO_PROFILE_T_MMAL_VIDEO_PROFILE_MP4V_SIMPLESCALABLE: MMAL_VIDEO_PROFILE_T = 10;
pub const MMAL_VIDEO_PROFILE_T_MMAL_VIDEO_PROFILE_MP4V_CORE: MMAL_VIDEO_PROFILE_T = 11;
pub const MMAL_VIDEO_PROFILE_T_MMAL_VIDEO_PROFILE_MP4V_MAIN: MMAL_VIDEO_PROFILE_T = 12;
pub const MMAL_VIDEO_PROFILE_T_MMAL_VIDEO_PROFILE_MP4V_NBIT: MMAL_VIDEO_PROFILE_T = 13;
pub const MMAL_VIDEO_PROFILE_T_MMAL_VIDEO_PROFILE_MP4V_SCALABLETEXTURE: MMAL_VIDEO_PROFILE_T = 14;
pub const MMAL_VIDEO_PROFILE_T_MMAL_VIDEO_PROFILE_MP4V_SIMPLEFACE: MMAL_VIDEO_PROFILE_T = 15;
pub const MMAL_VIDEO_PROFILE_T_MMAL_VIDEO_PROFILE_MP4V_SIMPLEFBA: MMAL_VIDEO_PROFILE_T = 16;
pub const MMAL_VIDEO_PROFILE_T_MMAL_VIDEO_PROFILE_MP4V_BASICANIMATED: MMAL_VIDEO_PROFILE_T = 17;
pub const MMAL_VIDEO_PROFILE_T_MMAL_VIDEO_PROFILE_MP4V_HYBRID: MMAL_VIDEO_PROFILE_T = 18;
pub const MMAL_VIDEO_PROFILE_T_MMAL_VIDEO_PROFILE_MP4V_ADVANCEDREALTIME: MMAL_VIDEO_PROFILE_T = 19;
pub const MMAL_VIDEO_PROFILE_T_MMAL_VIDEO_PROFILE_MP4V_CORESCALABLE: MMAL_VIDEO_PROFILE_T = 20;
pub const MMAL_VIDEO_PROFILE_T_MMAL_VIDEO_PROFILE_MP4V_ADVANCEDCODING: MMAL_VIDEO_PROFILE_T = 21;
pub const MMAL_VIDEO_PROFILE_T_MMAL_VIDEO_PROFILE_MP4V_ADVANCEDCORE: MMAL_VIDEO_PROFILE_T = 22;
pub const MMAL_VIDEO_PROFILE_T_MMAL_VIDEO_PROFILE_MP4V_ADVANCEDSCALABLE: MMAL_VIDEO_PROFILE_T = 23;
pub const MMAL_VIDEO_PROFILE_T_MMAL_VIDEO_PROFILE_MP4V_ADVANCEDSIMPLE: MMAL_VIDEO_PROFILE_T = 24;
pub const MMAL_VIDEO_PROFILE_T_MMAL_VIDEO_PROFILE_H264_BASELINE: MMAL_VIDEO_PROFILE_T = 25;
pub const MMAL_VIDEO_PROFILE_T_MMAL_VIDEO_PROFILE_H264_MAIN: MMAL_VIDEO_PROFILE_T = 26;
pub const MMAL_VIDEO_PROFILE_T_MMAL_VIDEO_PROFILE_H264_EXTENDED: MMAL_VIDEO_PROFILE_T = 27;
pub const MMAL_VIDEO_PROFILE_T_MMAL_VIDEO_PROFILE_H264_HIGH: MMAL_VIDEO_PROFILE_T = 28;
pub const MMAL_VIDEO_PROFILE_T_MMAL_VIDEO_PROFILE_H264_HIGH10: MMAL_VIDEO_PROFILE_T = 29;
pub const MMAL_VIDEO_PROFILE_T_MMAL_VIDEO_PROFILE_H264_HIGH422: MMAL_VIDEO_PROFILE_T = 30;
pub const MMAL_VIDEO_PROFILE_T_MMAL_VIDEO_PROFILE_H264_HIGH444: MMAL_VIDEO_PROFILE_T = 31;
pub const MMAL_VIDEO_PROFILE_T_MMAL_VIDEO_PROFILE_H264_CONSTRAINED_BASELINE: MMAL_VIDEO_PROFILE_T =
    32;
pub const MMAL_VIDEO_PROFILE_T_MMAL_VIDEO_PROFILE_DUMMY: MMAL_VIDEO_PROFILE_T = 2147483647;
#[doc = " Video profiles."]
#[doc = " Only certain combinations of profile and level will be valid."]
#[doc = " @ref MMAL_VIDEO_LEVEL_T"]
pub type MMAL_VIDEO_PROFILE_T = u32;
pub const MMAL_VIDEO_LEVEL_T_MMAL_VIDEO_LEVEL_H263_10: MMAL_VIDEO_LEVEL_T = 0;
pub const MMAL_VIDEO_LEVEL_T_MMAL_VIDEO_LEVEL_H263_20: MMAL_VIDEO_LEVEL_T = 1;
pub const MMAL_VIDEO_LEVEL_T_MMAL_VIDEO_LEVEL_H263_30: MMAL_VIDEO_LEVEL_T = 2;
pub const MMAL_VIDEO_LEVEL_T_MMAL_VIDEO_LEVEL_H263_40: MMAL_VIDEO_LEVEL_T = 3;
pub const MMAL_VIDEO_LEVEL_T_MMAL_VIDEO_LEVEL_H263_45: MMAL_VIDEO_LEVEL_T = 4;
pub const MMAL_VIDEO_LEVEL_T_MMAL_VIDEO_LEVEL_H263_50: MMAL_VIDEO_LEVEL_T = 5;
pub const MMAL_VIDEO_LEVEL_T_MMAL_VIDEO_LEVEL_H263_60: MMAL_VIDEO_LEVEL_T = 6;
pub const MMAL_VIDEO_LEVEL_T_MMAL_VIDEO_LEVEL_H263_70: MMAL_VIDEO_LEVEL_T = 7;
pub const MMAL_VIDEO_LEVEL_T_MMAL_VIDEO_LEVEL_MP4V_0: MMAL_VIDEO_LEVEL_T = 8;
pub const MMAL_VIDEO_LEVEL_T_MMAL_VIDEO_LEVEL_MP4V_0b: MMAL_VIDEO_LEVEL_T = 9;
pub const MMAL_VIDEO_LEVEL_T_MMAL_VIDEO_LEVEL_MP4V_1: MMAL_VIDEO_LEVEL_T = 10;
pub const MMAL_VIDEO_LEVEL_T_MMAL_VIDEO_LEVEL_MP4V_2: MMAL_VIDEO_LEVEL_T = 11;
pub const MMAL_VIDEO_LEVEL_T_MMAL_VIDEO_LEVEL_MP4V_3: MMAL_VIDEO_LEVEL_T = 12;
pub const MMAL_VIDEO_LEVEL_T_MMAL_VIDEO_LEVEL_MP4V_4: MMAL_VIDEO_LEVEL_T = 13;
pub const MMAL_VIDEO_LEVEL_T_MMAL_VIDEO_LEVEL_MP4V_4a: MMAL_VIDEO_LEVEL_T = 14;
pub const MMAL_VIDEO_LEVEL_T_MMAL_VIDEO_LEVEL_MP4V_5: MMAL_VIDEO_LEVEL_T = 15;
pub const MMAL_VIDEO_LEVEL_T_MMAL_VIDEO_LEVEL_MP4V_6: MMAL_VIDEO_LEVEL_T = 16;
pub const MMAL_VIDEO_LEVEL_T_MMAL_VIDEO_LEVEL_H264_1: MMAL_VIDEO_LEVEL_T = 17;
pub const MMAL_VIDEO_LEVEL_T_MMAL_VIDEO_LEVEL_H264_1b: MMAL_VIDEO_LEVEL_T = 18;
pub const MMAL_VIDEO_LEVEL_T_MMAL_VIDEO_LEVEL_H264_11: MMAL_VIDEO_LEVEL_T = 19;
pub const MMAL_VIDEO_LEVEL_T_MMAL_VIDEO_LEVEL_H264_12: MMAL_VIDEO_LEVEL_T = 20;
pub const MMAL_VIDEO_LEVEL_T_MMAL_VIDEO_LEVEL_H264_13: MMAL_VIDEO_LEVEL_T = 21;
pub const MMAL_VIDEO_LEVEL_T_MMAL_VIDEO_LEVEL_H264_2: MMAL_VIDEO_LEVEL_T = 22;
pub const MMAL_VIDEO_LEVEL_T_MMAL_VIDEO_LEVEL_H264_21: MMAL_VIDEO_LEVEL_T = 23;
pub const MMAL_VIDEO_LEVEL_T_MMAL_VIDEO_LEVEL_H264_22: MMAL_VIDEO_LEVEL_T = 24;
pub const MMAL_VIDEO_LEVEL_T_MMAL_VIDEO_LEVEL_H264_3: MMAL_VIDEO_LEVEL_T = 25;
pub const MMAL_VIDEO_LEVEL_T_MMAL_VIDEO_LEVEL_H264_31: MMAL_VIDEO_LEVEL_T = 26;
pub const MMAL_VIDEO_LEVEL_T_MMAL_VIDEO_LEVEL_H264_32: MMAL_VIDEO_LEVEL_T = 27;
pub const MMAL_VIDEO_LEVEL_T_MMAL_VIDEO_LEVEL_H264_4: MMAL_VIDEO_LEVEL_T = 28;
pub const MMAL_VIDEO_LEVEL_T_MMAL_VIDEO_LEVEL_H264_41: MMAL_VIDEO_LEVEL_T = 29;
pub const MMAL_VIDEO_LEVEL_T_MMAL_VIDEO_LEVEL_H264_42: MMAL_VIDEO_LEVEL_T = 30;
pub const MMAL_VIDEO_LEVEL_T_MMAL_VIDEO_LEVEL_H264_5: MMAL_VIDEO_LEVEL_T = 31;
pub const MMAL_VIDEO_LEVEL_T_MMAL_VIDEO_LEVEL_H264_51: MMAL_VIDEO_LEVEL_T = 32;
pub const MMAL_VIDEO_LEVEL_T_MMAL_VIDEO_LEVEL_DUMMY: MMAL_VIDEO_LEVEL_T = 2147483647;
#[doc = " Video levels."]
#[doc = " Only certain combinations of profile and level will be valid."]
#[doc = " @ref MMAL_VIDEO_PROFILE_T"]
pub type MMAL_VIDEO_LEVEL_T = u32;
#[doc = " Video profile and level setting."]
#[doc = " This is a variable length structure when querying the supported profiles and"]
#[doc = " levels. To get more than one, pass a structure with more profile/level pairs."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_VIDEO_PROFILE_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    pub profile: [MMAL_PARAMETER_VIDEO_PROFILE_T__bindgen_ty_1; 1usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_VIDEO_PROFILE_T__bindgen_ty_1 {
    pub profile: MMAL_VIDEO_PROFILE_T,
    pub level: MMAL_VIDEO_LEVEL_T,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_VIDEO_PROFILE_T__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_VIDEO_PROFILE_T__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(MMAL_PARAMETER_VIDEO_PROFILE_T__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_VIDEO_PROFILE_T__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(MMAL_PARAMETER_VIDEO_PROFILE_T__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_VIDEO_PROFILE_T__bindgen_ty_1>())).profile
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_VIDEO_PROFILE_T__bindgen_ty_1),
            "::",
            stringify!(profile)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_VIDEO_PROFILE_T__bindgen_ty_1>())).level
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_VIDEO_PROFILE_T__bindgen_ty_1),
            "::",
            stringify!(level)
        )
    );
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_VIDEO_PROFILE_T() {
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_VIDEO_PROFILE_T>(),
        16usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_VIDEO_PROFILE_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_VIDEO_PROFILE_T>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_PARAMETER_VIDEO_PROFILE_T))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_VIDEO_PROFILE_T>())).hdr as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_VIDEO_PROFILE_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_VIDEO_PROFILE_T>())).profile as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_VIDEO_PROFILE_T),
            "::",
            stringify!(profile)
        )
    );
}
pub const MMAL_VIDEO_RATECONTROL_T_MMAL_VIDEO_RATECONTROL_DEFAULT: MMAL_VIDEO_RATECONTROL_T = 0;
pub const MMAL_VIDEO_RATECONTROL_T_MMAL_VIDEO_RATECONTROL_VARIABLE: MMAL_VIDEO_RATECONTROL_T = 1;
pub const MMAL_VIDEO_RATECONTROL_T_MMAL_VIDEO_RATECONTROL_CONSTANT: MMAL_VIDEO_RATECONTROL_T = 2;
pub const MMAL_VIDEO_RATECONTROL_T_MMAL_VIDEO_RATECONTROL_VARIABLE_SKIP_FRAMES:
    MMAL_VIDEO_RATECONTROL_T = 3;
pub const MMAL_VIDEO_RATECONTROL_T_MMAL_VIDEO_RATECONTROL_CONSTANT_SKIP_FRAMES:
    MMAL_VIDEO_RATECONTROL_T = 4;
pub const MMAL_VIDEO_RATECONTROL_T_MMAL_VIDEO_RATECONTROL_DUMMY: MMAL_VIDEO_RATECONTROL_T =
    2147483647;
#[doc = " Manner of video rate control"]
pub type MMAL_VIDEO_RATECONTROL_T = u32;
pub const MMAL_VIDEO_INTRA_REFRESH_T_MMAL_VIDEO_INTRA_REFRESH_CYCLIC: MMAL_VIDEO_INTRA_REFRESH_T =
    0;
pub const MMAL_VIDEO_INTRA_REFRESH_T_MMAL_VIDEO_INTRA_REFRESH_ADAPTIVE: MMAL_VIDEO_INTRA_REFRESH_T =
    1;
pub const MMAL_VIDEO_INTRA_REFRESH_T_MMAL_VIDEO_INTRA_REFRESH_BOTH: MMAL_VIDEO_INTRA_REFRESH_T = 2;
pub const MMAL_VIDEO_INTRA_REFRESH_T_MMAL_VIDEO_INTRA_REFRESH_KHRONOSEXTENSIONS:
    MMAL_VIDEO_INTRA_REFRESH_T = 1862270976;
pub const MMAL_VIDEO_INTRA_REFRESH_T_MMAL_VIDEO_INTRA_REFRESH_VENDORSTARTUNUSED:
    MMAL_VIDEO_INTRA_REFRESH_T = 2130706432;
pub const MMAL_VIDEO_INTRA_REFRESH_T_MMAL_VIDEO_INTRA_REFRESH_CYCLIC_MROWS:
    MMAL_VIDEO_INTRA_REFRESH_T = 2130706433;
pub const MMAL_VIDEO_INTRA_REFRESH_T_MMAL_VIDEO_INTRA_REFRESH_PSEUDO_RAND:
    MMAL_VIDEO_INTRA_REFRESH_T = 2130706434;
pub const MMAL_VIDEO_INTRA_REFRESH_T_MMAL_VIDEO_INTRA_REFRESH_MAX: MMAL_VIDEO_INTRA_REFRESH_T =
    2130706435;
pub const MMAL_VIDEO_INTRA_REFRESH_T_MMAL_VIDEO_INTRA_REFRESH_DUMMY: MMAL_VIDEO_INTRA_REFRESH_T =
    2147483647;
#[doc = " Intra refresh modes"]
pub type MMAL_VIDEO_INTRA_REFRESH_T = u32;
pub const MMAL_VIDEO_ENCODE_RC_MODEL_T_MMAL_VIDEO_ENCODER_RC_MODEL_DEFAULT:
    MMAL_VIDEO_ENCODE_RC_MODEL_T = 0;
pub const MMAL_VIDEO_ENCODE_RC_MODEL_T_MMAL_VIDEO_ENCODER_RC_MODEL_JVT:
    MMAL_VIDEO_ENCODE_RC_MODEL_T = 0;
pub const MMAL_VIDEO_ENCODE_RC_MODEL_T_MMAL_VIDEO_ENCODER_RC_MODEL_VOWIFI:
    MMAL_VIDEO_ENCODE_RC_MODEL_T = 1;
pub const MMAL_VIDEO_ENCODE_RC_MODEL_T_MMAL_VIDEO_ENCODER_RC_MODEL_CBR:
    MMAL_VIDEO_ENCODE_RC_MODEL_T = 2;
pub const MMAL_VIDEO_ENCODE_RC_MODEL_T_MMAL_VIDEO_ENCODER_RC_MODEL_LAST:
    MMAL_VIDEO_ENCODE_RC_MODEL_T = 3;
pub const MMAL_VIDEO_ENCODE_RC_MODEL_T_MMAL_VIDEO_ENCODER_RC_MODEL_DUMMY:
    MMAL_VIDEO_ENCODE_RC_MODEL_T = 2147483647;
pub type MMAL_VIDEO_ENCODE_RC_MODEL_T = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_VIDEO_ENCODE_RC_MODEL_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    pub rc_model: MMAL_VIDEO_ENCODE_RC_MODEL_T,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_VIDEO_ENCODE_RC_MODEL_T() {
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_VIDEO_ENCODE_RC_MODEL_T>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(MMAL_PARAMETER_VIDEO_ENCODE_RC_MODEL_T)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_VIDEO_ENCODE_RC_MODEL_T>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(MMAL_PARAMETER_VIDEO_ENCODE_RC_MODEL_T)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_VIDEO_ENCODE_RC_MODEL_T>())).hdr as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_VIDEO_ENCODE_RC_MODEL_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_VIDEO_ENCODE_RC_MODEL_T>())).rc_model as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_VIDEO_ENCODE_RC_MODEL_T),
            "::",
            stringify!(rc_model)
        )
    );
}
#[doc = " Video rate control setting"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_VIDEO_RATECONTROL_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    pub control: MMAL_VIDEO_RATECONTROL_T,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_VIDEO_RATECONTROL_T() {
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_VIDEO_RATECONTROL_T>(),
        12usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_VIDEO_RATECONTROL_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_VIDEO_RATECONTROL_T>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(MMAL_PARAMETER_VIDEO_RATECONTROL_T)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_VIDEO_RATECONTROL_T>())).hdr as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_VIDEO_RATECONTROL_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_VIDEO_RATECONTROL_T>())).control as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_VIDEO_RATECONTROL_T),
            "::",
            stringify!(control)
        )
    );
}
pub const MMAL_VIDEO_ENCODE_H264_MB_INTRA_MODES_T_MMAL_VIDEO_ENCODER_H264_MB_4x4_INTRA:
    MMAL_VIDEO_ENCODE_H264_MB_INTRA_MODES_T = 1;
pub const MMAL_VIDEO_ENCODE_H264_MB_INTRA_MODES_T_MMAL_VIDEO_ENCODER_H264_MB_8x8_INTRA:
    MMAL_VIDEO_ENCODE_H264_MB_INTRA_MODES_T = 2;
pub const MMAL_VIDEO_ENCODE_H264_MB_INTRA_MODES_T_MMAL_VIDEO_ENCODER_H264_MB_16x16_INTRA:
    MMAL_VIDEO_ENCODE_H264_MB_INTRA_MODES_T = 4;
pub const MMAL_VIDEO_ENCODE_H264_MB_INTRA_MODES_T_MMAL_VIDEO_ENCODER_H264_MB_INTRA_DUMMY:
    MMAL_VIDEO_ENCODE_H264_MB_INTRA_MODES_T = 2147483647;
pub type MMAL_VIDEO_ENCODE_H264_MB_INTRA_MODES_T = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_VIDEO_ENCODER_H264_MB_INTRA_MODES_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    pub mb_mode: MMAL_VIDEO_ENCODE_H264_MB_INTRA_MODES_T,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_VIDEO_ENCODER_H264_MB_INTRA_MODES_T() {
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_VIDEO_ENCODER_H264_MB_INTRA_MODES_T>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(MMAL_PARAMETER_VIDEO_ENCODER_H264_MB_INTRA_MODES_T)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_VIDEO_ENCODER_H264_MB_INTRA_MODES_T>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(MMAL_PARAMETER_VIDEO_ENCODER_H264_MB_INTRA_MODES_T)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_VIDEO_ENCODER_H264_MB_INTRA_MODES_T>())).hdr
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_VIDEO_ENCODER_H264_MB_INTRA_MODES_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_VIDEO_ENCODER_H264_MB_INTRA_MODES_T>())).mb_mode
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_VIDEO_ENCODER_H264_MB_INTRA_MODES_T),
            "::",
            stringify!(mb_mode)
        )
    );
}
pub const MMAL_VIDEO_NALUNITFORMAT_T_MMAL_VIDEO_NALUNITFORMAT_STARTCODES:
    MMAL_VIDEO_NALUNITFORMAT_T = 1;
pub const MMAL_VIDEO_NALUNITFORMAT_T_MMAL_VIDEO_NALUNITFORMAT_NALUNITPERBUFFER:
    MMAL_VIDEO_NALUNITFORMAT_T = 2;
pub const MMAL_VIDEO_NALUNITFORMAT_T_MMAL_VIDEO_NALUNITFORMAT_ONEBYTEINTERLEAVELENGTH:
    MMAL_VIDEO_NALUNITFORMAT_T = 4;
pub const MMAL_VIDEO_NALUNITFORMAT_T_MMAL_VIDEO_NALUNITFORMAT_TWOBYTEINTERLEAVELENGTH:
    MMAL_VIDEO_NALUNITFORMAT_T = 8;
pub const MMAL_VIDEO_NALUNITFORMAT_T_MMAL_VIDEO_NALUNITFORMAT_FOURBYTEINTERLEAVELENGTH:
    MMAL_VIDEO_NALUNITFORMAT_T = 16;
pub const MMAL_VIDEO_NALUNITFORMAT_T_MMAL_VIDEO_NALUNITFORMAT_DUMMY: MMAL_VIDEO_NALUNITFORMAT_T =
    2147483647;
#[doc = " NAL unit formats"]
pub type MMAL_VIDEO_NALUNITFORMAT_T = u32;
#[doc = " NAL unit format setting"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_VIDEO_NALUNITFORMAT_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    pub format: MMAL_VIDEO_NALUNITFORMAT_T,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_VIDEO_NALUNITFORMAT_T() {
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_VIDEO_NALUNITFORMAT_T>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(MMAL_PARAMETER_VIDEO_NALUNITFORMAT_T)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_VIDEO_NALUNITFORMAT_T>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(MMAL_PARAMETER_VIDEO_NALUNITFORMAT_T)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_VIDEO_NALUNITFORMAT_T>())).hdr as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_VIDEO_NALUNITFORMAT_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_VIDEO_NALUNITFORMAT_T>())).format as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_VIDEO_NALUNITFORMAT_T),
            "::",
            stringify!(format)
        )
    );
}
#[doc = " H264 Only: Overrides for max macro-blocks per second, max framesize,"]
#[doc = " and max bitrates. This overrides the default maximums for the configured level."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_VIDEO_LEVEL_EXTENSION_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    pub custom_max_mbps: u32,
    pub custom_max_fs: u32,
    pub custom_max_br_and_cpb: u32,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_VIDEO_LEVEL_EXTENSION_T() {
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_VIDEO_LEVEL_EXTENSION_T>(),
        20usize,
        concat!(
            "Size of: ",
            stringify!(MMAL_PARAMETER_VIDEO_LEVEL_EXTENSION_T)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_VIDEO_LEVEL_EXTENSION_T>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(MMAL_PARAMETER_VIDEO_LEVEL_EXTENSION_T)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_VIDEO_LEVEL_EXTENSION_T>())).hdr as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_VIDEO_LEVEL_EXTENSION_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_VIDEO_LEVEL_EXTENSION_T>())).custom_max_mbps
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_VIDEO_LEVEL_EXTENSION_T),
            "::",
            stringify!(custom_max_mbps)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_VIDEO_LEVEL_EXTENSION_T>())).custom_max_fs
                as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_VIDEO_LEVEL_EXTENSION_T),
            "::",
            stringify!(custom_max_fs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_VIDEO_LEVEL_EXTENSION_T>())).custom_max_br_and_cpb
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_VIDEO_LEVEL_EXTENSION_T),
            "::",
            stringify!(custom_max_br_and_cpb)
        )
    );
}
#[doc = " H264 Only: Overrides for max macro-blocks per second, max framesize,"]
#[doc = " and max bitrates. This overrides the default maximums for the configured level."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_VIDEO_INTRA_REFRESH_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    pub refresh_mode: MMAL_VIDEO_INTRA_REFRESH_T,
    pub air_mbs: u32,
    pub air_ref: u32,
    pub cir_mbs: u32,
    pub pir_mbs: u32,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_VIDEO_INTRA_REFRESH_T() {
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_VIDEO_INTRA_REFRESH_T>(),
        28usize,
        concat!(
            "Size of: ",
            stringify!(MMAL_PARAMETER_VIDEO_INTRA_REFRESH_T)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_VIDEO_INTRA_REFRESH_T>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(MMAL_PARAMETER_VIDEO_INTRA_REFRESH_T)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_VIDEO_INTRA_REFRESH_T>())).hdr as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_VIDEO_INTRA_REFRESH_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_VIDEO_INTRA_REFRESH_T>())).refresh_mode
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_VIDEO_INTRA_REFRESH_T),
            "::",
            stringify!(refresh_mode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_VIDEO_INTRA_REFRESH_T>())).air_mbs as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_VIDEO_INTRA_REFRESH_T),
            "::",
            stringify!(air_mbs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_VIDEO_INTRA_REFRESH_T>())).air_ref as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_VIDEO_INTRA_REFRESH_T),
            "::",
            stringify!(air_ref)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_VIDEO_INTRA_REFRESH_T>())).cir_mbs as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_VIDEO_INTRA_REFRESH_T),
            "::",
            stringify!(cir_mbs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_VIDEO_INTRA_REFRESH_T>())).pir_mbs as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_VIDEO_INTRA_REFRESH_T),
            "::",
            stringify!(pir_mbs)
        )
    );
}
#[doc = " Structure for enabling EEDE, we keep it like this for now, there could be extra fields in the future"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_VIDEO_EEDE_ENABLE_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    pub enable: u32,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_VIDEO_EEDE_ENABLE_T() {
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_VIDEO_EEDE_ENABLE_T>(),
        12usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_VIDEO_EEDE_ENABLE_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_VIDEO_EEDE_ENABLE_T>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(MMAL_PARAMETER_VIDEO_EEDE_ENABLE_T)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_VIDEO_EEDE_ENABLE_T>())).hdr as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_VIDEO_EEDE_ENABLE_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_VIDEO_EEDE_ENABLE_T>())).enable as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_VIDEO_EEDE_ENABLE_T),
            "::",
            stringify!(enable)
        )
    );
}
#[doc = " Structure for setting lossrate for EEDE, we keep it like this for now, there could be extra fields in the future"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_VIDEO_EEDE_LOSSRATE_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    pub loss_rate: u32,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_VIDEO_EEDE_LOSSRATE_T() {
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_VIDEO_EEDE_LOSSRATE_T>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(MMAL_PARAMETER_VIDEO_EEDE_LOSSRATE_T)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_VIDEO_EEDE_LOSSRATE_T>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(MMAL_PARAMETER_VIDEO_EEDE_LOSSRATE_T)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_VIDEO_EEDE_LOSSRATE_T>())).hdr as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_VIDEO_EEDE_LOSSRATE_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_VIDEO_EEDE_LOSSRATE_T>())).loss_rate as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_VIDEO_EEDE_LOSSRATE_T),
            "::",
            stringify!(loss_rate)
        )
    );
}
#[doc = " Structure for setting initial DRM parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_VIDEO_DRM_INIT_INFO_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    pub current_time: u32,
    pub ticks_per_sec: u32,
    pub lhs: [u8; 32usize],
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_VIDEO_DRM_INIT_INFO_T() {
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_VIDEO_DRM_INIT_INFO_T>(),
        48usize,
        concat!(
            "Size of: ",
            stringify!(MMAL_PARAMETER_VIDEO_DRM_INIT_INFO_T)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_VIDEO_DRM_INIT_INFO_T>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(MMAL_PARAMETER_VIDEO_DRM_INIT_INFO_T)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_VIDEO_DRM_INIT_INFO_T>())).hdr as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_VIDEO_DRM_INIT_INFO_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_VIDEO_DRM_INIT_INFO_T>())).current_time
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_VIDEO_DRM_INIT_INFO_T),
            "::",
            stringify!(current_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_VIDEO_DRM_INIT_INFO_T>())).ticks_per_sec
                as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_VIDEO_DRM_INIT_INFO_T),
            "::",
            stringify!(ticks_per_sec)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_VIDEO_DRM_INIT_INFO_T>())).lhs as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_VIDEO_DRM_INIT_INFO_T),
            "::",
            stringify!(lhs)
        )
    );
}
#[doc = " Structure for requesting a hardware-protected memory buffer"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_VIDEO_DRM_PROTECT_BUFFER_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    #[doc = "< Input. Zero size means internal video decoder buffer,"]
    #[doc = "mem_handle and phys_addr not returned in this case"]
    pub size_wanted: u32,
    #[doc = "< Input. 1 = protect, 0 = unprotect"]
    pub protect: u32,
    #[doc = "< Output. Handle for protected buffer"]
    pub mem_handle: u32,
    #[doc = "< Output. Physical memory address of protected buffer"]
    pub phys_addr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_VIDEO_DRM_PROTECT_BUFFER_T() {
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_VIDEO_DRM_PROTECT_BUFFER_T>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(MMAL_PARAMETER_VIDEO_DRM_PROTECT_BUFFER_T)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_VIDEO_DRM_PROTECT_BUFFER_T>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(MMAL_PARAMETER_VIDEO_DRM_PROTECT_BUFFER_T)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_VIDEO_DRM_PROTECT_BUFFER_T>())).hdr as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_VIDEO_DRM_PROTECT_BUFFER_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_VIDEO_DRM_PROTECT_BUFFER_T>())).size_wanted
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_VIDEO_DRM_PROTECT_BUFFER_T),
            "::",
            stringify!(size_wanted)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_VIDEO_DRM_PROTECT_BUFFER_T>())).protect
                as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_VIDEO_DRM_PROTECT_BUFFER_T),
            "::",
            stringify!(protect)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_VIDEO_DRM_PROTECT_BUFFER_T>())).mem_handle
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_VIDEO_DRM_PROTECT_BUFFER_T),
            "::",
            stringify!(mem_handle)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_VIDEO_DRM_PROTECT_BUFFER_T>())).phys_addr
                as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_VIDEO_DRM_PROTECT_BUFFER_T),
            "::",
            stringify!(phys_addr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_VIDEO_RENDER_STATS_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    pub valid: MMAL_BOOL_T,
    pub match_: u32,
    pub period: u32,
    pub phase: u32,
    pub pixel_clock_nominal: u32,
    pub pixel_clock: u32,
    pub hvs_status: u32,
    pub dummy: [u32; 2usize],
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_VIDEO_RENDER_STATS_T() {
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_VIDEO_RENDER_STATS_T>(),
        44usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_VIDEO_RENDER_STATS_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_VIDEO_RENDER_STATS_T>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(MMAL_PARAMETER_VIDEO_RENDER_STATS_T)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_VIDEO_RENDER_STATS_T>())).hdr as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_VIDEO_RENDER_STATS_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_VIDEO_RENDER_STATS_T>())).valid as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_VIDEO_RENDER_STATS_T),
            "::",
            stringify!(valid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_VIDEO_RENDER_STATS_T>())).match_ as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_VIDEO_RENDER_STATS_T),
            "::",
            stringify!(match_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_VIDEO_RENDER_STATS_T>())).period as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_VIDEO_RENDER_STATS_T),
            "::",
            stringify!(period)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_VIDEO_RENDER_STATS_T>())).phase as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_VIDEO_RENDER_STATS_T),
            "::",
            stringify!(phase)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_VIDEO_RENDER_STATS_T>())).pixel_clock_nominal
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_VIDEO_RENDER_STATS_T),
            "::",
            stringify!(pixel_clock_nominal)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_VIDEO_RENDER_STATS_T>())).pixel_clock as *const _
                as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_VIDEO_RENDER_STATS_T),
            "::",
            stringify!(pixel_clock)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_VIDEO_RENDER_STATS_T>())).hvs_status as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_VIDEO_RENDER_STATS_T),
            "::",
            stringify!(hvs_status)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_VIDEO_RENDER_STATS_T>())).dummy as *const _
                as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_VIDEO_RENDER_STATS_T),
            "::",
            stringify!(dummy)
        )
    );
}
#[doc = "< The data is not interlaced, it is progressive scan"]
pub const MMAL_INTERLACETYPE_T_MMAL_InterlaceProgressive: MMAL_INTERLACETYPE_T = 0;
#[doc = "< The data is interlaced, fields sent"]
#[doc = "separately in temporal order, with upper field first"]
pub const MMAL_INTERLACETYPE_T_MMAL_InterlaceFieldSingleUpperFirst: MMAL_INTERLACETYPE_T = 1;
#[doc = "< The data is interlaced, fields sent"]
#[doc = "separately in temporal order, with lower field first"]
pub const MMAL_INTERLACETYPE_T_MMAL_InterlaceFieldSingleLowerFirst: MMAL_INTERLACETYPE_T = 2;
#[doc = "< The data is interlaced, two fields sent together line"]
#[doc = "interleaved, with the upper field temporally earlier"]
pub const MMAL_INTERLACETYPE_T_MMAL_InterlaceFieldsInterleavedUpperFirst: MMAL_INTERLACETYPE_T = 3;
#[doc = "< The data is interlaced, two fields sent together line"]
#[doc = "interleaved, with the lower field temporally earlier"]
pub const MMAL_INTERLACETYPE_T_MMAL_InterlaceFieldsInterleavedLowerFirst: MMAL_INTERLACETYPE_T = 4;
#[doc = "< The stream may contain a mixture of progressive"]
#[doc = "and interlaced frames"]
pub const MMAL_INTERLACETYPE_T_MMAL_InterlaceMixed: MMAL_INTERLACETYPE_T = 5;
#[doc = "< Reserved region for introducing Khronos Standard Extensions"]
pub const MMAL_INTERLACETYPE_T_MMAL_InterlaceKhronosExtensions: MMAL_INTERLACETYPE_T = 1862270976;
#[doc = "< Reserved region for introducing Vendor Extensions"]
pub const MMAL_INTERLACETYPE_T_MMAL_InterlaceVendorStartUnused: MMAL_INTERLACETYPE_T = 2130706432;
pub const MMAL_INTERLACETYPE_T_MMAL_InterlaceMax: MMAL_INTERLACETYPE_T = 2147483647;
pub type MMAL_INTERLACETYPE_T = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_VIDEO_INTERLACE_TYPE_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    #[doc = "< The interlace type of the content"]
    pub eMode: MMAL_INTERLACETYPE_T,
    #[doc = "< Whether to repeat the first field"]
    pub bRepeatFirstField: MMAL_BOOL_T,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_VIDEO_INTERLACE_TYPE_T() {
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_VIDEO_INTERLACE_TYPE_T>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(MMAL_PARAMETER_VIDEO_INTERLACE_TYPE_T)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_VIDEO_INTERLACE_TYPE_T>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(MMAL_PARAMETER_VIDEO_INTERLACE_TYPE_T)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_VIDEO_INTERLACE_TYPE_T>())).hdr as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_VIDEO_INTERLACE_TYPE_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_VIDEO_INTERLACE_TYPE_T>())).eMode as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_VIDEO_INTERLACE_TYPE_T),
            "::",
            stringify!(eMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_VIDEO_INTERLACE_TYPE_T>())).bRepeatFirstField
                as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_VIDEO_INTERLACE_TYPE_T),
            "::",
            stringify!(bRepeatFirstField)
        )
    );
}
pub const MMAL_SOURCE_PATTERN_T_MMAL_VIDEO_SOURCE_PATTERN_WHITE: MMAL_SOURCE_PATTERN_T = 0;
pub const MMAL_SOURCE_PATTERN_T_MMAL_VIDEO_SOURCE_PATTERN_BLACK: MMAL_SOURCE_PATTERN_T = 1;
pub const MMAL_SOURCE_PATTERN_T_MMAL_VIDEO_SOURCE_PATTERN_DIAGONAL: MMAL_SOURCE_PATTERN_T = 2;
pub const MMAL_SOURCE_PATTERN_T_MMAL_VIDEO_SOURCE_PATTERN_NOISE: MMAL_SOURCE_PATTERN_T = 3;
pub const MMAL_SOURCE_PATTERN_T_MMAL_VIDEO_SOURCE_PATTERN_RANDOM: MMAL_SOURCE_PATTERN_T = 4;
pub const MMAL_SOURCE_PATTERN_T_MMAL_VIDEO_SOURCE_PATTERN_COLOUR: MMAL_SOURCE_PATTERN_T = 5;
pub const MMAL_SOURCE_PATTERN_T_MMAL_VIDEO_SOURCE_PATTERN_BLOCKS: MMAL_SOURCE_PATTERN_T = 6;
pub const MMAL_SOURCE_PATTERN_T_MMAL_VIDEO_SOURCE_PATTERN_SWIRLY: MMAL_SOURCE_PATTERN_T = 7;
pub const MMAL_SOURCE_PATTERN_T_MMAL_VIDEO_SOURCE_PATTERN_DUMMY: MMAL_SOURCE_PATTERN_T = 2147483647;
pub type MMAL_SOURCE_PATTERN_T = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_VIDEO_SOURCE_PATTERN_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    pub pattern: MMAL_SOURCE_PATTERN_T,
    #[doc = "< Colour for PATTERN_COLOUR mode"]
    pub param: u32,
    #[doc = "< Number of frames to produce. 0 for continuous."]
    pub framecount: u32,
    #[doc = "< Framerate used when determining buffer timestamps"]
    pub framerate: MMAL_RATIONAL_T,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_VIDEO_SOURCE_PATTERN_T() {
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_VIDEO_SOURCE_PATTERN_T>(),
        28usize,
        concat!(
            "Size of: ",
            stringify!(MMAL_PARAMETER_VIDEO_SOURCE_PATTERN_T)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_VIDEO_SOURCE_PATTERN_T>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(MMAL_PARAMETER_VIDEO_SOURCE_PATTERN_T)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_VIDEO_SOURCE_PATTERN_T>())).hdr as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_VIDEO_SOURCE_PATTERN_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_VIDEO_SOURCE_PATTERN_T>())).pattern as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_VIDEO_SOURCE_PATTERN_T),
            "::",
            stringify!(pattern)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_VIDEO_SOURCE_PATTERN_T>())).param as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_VIDEO_SOURCE_PATTERN_T),
            "::",
            stringify!(param)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_VIDEO_SOURCE_PATTERN_T>())).framecount as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_VIDEO_SOURCE_PATTERN_T),
            "::",
            stringify!(framecount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_VIDEO_SOURCE_PATTERN_T>())).framerate as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_VIDEO_SOURCE_PATTERN_T),
            "::",
            stringify!(framerate)
        )
    );
}
#[doc = "< Takes a MMAL_PARAMETER_STRING_T"]
pub const MMAL_PARAMETER_AUDIO_DESTINATION: _bindgen_ty_28 = 196608;
#[doc = "< Takes a MMAL_PARAMETER_AUDIO_LATENCY_TARGET_T"]
pub const MMAL_PARAMETER_AUDIO_LATENCY_TARGET: _bindgen_ty_28 = 196609;
pub const MMAL_PARAMETER_AUDIO_SOURCE: _bindgen_ty_28 = 196610;
#[doc = "< Takes a MMAL_PARAMETER_BOOLEAN_T"]
pub const MMAL_PARAMETER_AUDIO_PASSTHROUGH: _bindgen_ty_28 = 196611;
#[doc = " Audio-specific MMAL parameter IDs."]
#[doc = " @ingroup MMAL_PARAMETER_IDS"]
pub type _bindgen_ty_28 = u32;
#[doc = " Audio latency target to maintain."]
#[doc = " These settings are used to adjust the clock speed in order"]
#[doc = " to match the measured audio latency to a specified value."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_AUDIO_LATENCY_TARGET_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    #[doc = "< whether this mode is enabled"]
    pub enable: MMAL_BOOL_T,
    #[doc = "< number of latency samples to filter on, good value: 1"]
    pub filter: u32,
    #[doc = "< target latency (microseconds)"]
    pub target: u32,
    #[doc = "< shift for storing latency values, good value: 7"]
    pub shift: u32,
    #[doc = "< multiplier for speed changes, in 24.8 format, good value: 256-512"]
    pub speed_factor: i32,
    #[doc = "< divider for comparing latency versus gradiant, good value: 300"]
    pub inter_factor: i32,
    #[doc = "< limit for speed change before nSpeedFactor is applied, good value: 100"]
    pub adj_cap: i32,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_AUDIO_LATENCY_TARGET_T() {
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_AUDIO_LATENCY_TARGET_T>(),
        36usize,
        concat!(
            "Size of: ",
            stringify!(MMAL_PARAMETER_AUDIO_LATENCY_TARGET_T)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_AUDIO_LATENCY_TARGET_T>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(MMAL_PARAMETER_AUDIO_LATENCY_TARGET_T)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_AUDIO_LATENCY_TARGET_T>())).hdr as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_AUDIO_LATENCY_TARGET_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_AUDIO_LATENCY_TARGET_T>())).enable as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_AUDIO_LATENCY_TARGET_T),
            "::",
            stringify!(enable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_AUDIO_LATENCY_TARGET_T>())).filter as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_AUDIO_LATENCY_TARGET_T),
            "::",
            stringify!(filter)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_AUDIO_LATENCY_TARGET_T>())).target as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_AUDIO_LATENCY_TARGET_T),
            "::",
            stringify!(target)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_AUDIO_LATENCY_TARGET_T>())).shift as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_AUDIO_LATENCY_TARGET_T),
            "::",
            stringify!(shift)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_AUDIO_LATENCY_TARGET_T>())).speed_factor
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_AUDIO_LATENCY_TARGET_T),
            "::",
            stringify!(speed_factor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_AUDIO_LATENCY_TARGET_T>())).inter_factor
                as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_AUDIO_LATENCY_TARGET_T),
            "::",
            stringify!(inter_factor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_AUDIO_LATENCY_TARGET_T>())).adj_cap as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_AUDIO_LATENCY_TARGET_T),
            "::",
            stringify!(adj_cap)
        )
    );
}
#[doc = " Thresholds used when updating a clock's media-time"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_CLOCK_UPDATE_THRESHOLD_T {
    #[doc = " Time differences below this threshold are ignored (microseconds)"]
    pub threshold_lower: i64,
    #[doc = " Time differences above this threshold reset media-time (microseconds)"]
    pub threshold_upper: i64,
}
#[test]
fn bindgen_test_layout_MMAL_CLOCK_UPDATE_THRESHOLD_T() {
    assert_eq!(
        ::std::mem::size_of::<MMAL_CLOCK_UPDATE_THRESHOLD_T>(),
        16usize,
        concat!("Size of: ", stringify!(MMAL_CLOCK_UPDATE_THRESHOLD_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_CLOCK_UPDATE_THRESHOLD_T>(),
        8usize,
        concat!("Alignment of ", stringify!(MMAL_CLOCK_UPDATE_THRESHOLD_T))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_CLOCK_UPDATE_THRESHOLD_T>())).threshold_lower as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_CLOCK_UPDATE_THRESHOLD_T),
            "::",
            stringify!(threshold_lower)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_CLOCK_UPDATE_THRESHOLD_T>())).threshold_upper as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_CLOCK_UPDATE_THRESHOLD_T),
            "::",
            stringify!(threshold_upper)
        )
    );
}
#[doc = " Threshold for detecting a discontinuity in media-time"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_CLOCK_DISCONT_THRESHOLD_T {
    #[doc = " Threshold after which backward jumps in media-time are treated as a"]
    #[doc = " discontinuity (microseconds)"]
    pub threshold: i64,
    #[doc = " Duration in microseconds for which a discontinuity applies (wall-time)"]
    pub duration: i64,
}
#[test]
fn bindgen_test_layout_MMAL_CLOCK_DISCONT_THRESHOLD_T() {
    assert_eq!(
        ::std::mem::size_of::<MMAL_CLOCK_DISCONT_THRESHOLD_T>(),
        16usize,
        concat!("Size of: ", stringify!(MMAL_CLOCK_DISCONT_THRESHOLD_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_CLOCK_DISCONT_THRESHOLD_T>(),
        8usize,
        concat!("Alignment of ", stringify!(MMAL_CLOCK_DISCONT_THRESHOLD_T))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_CLOCK_DISCONT_THRESHOLD_T>())).threshold as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_CLOCK_DISCONT_THRESHOLD_T),
            "::",
            stringify!(threshold)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_CLOCK_DISCONT_THRESHOLD_T>())).duration as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_CLOCK_DISCONT_THRESHOLD_T),
            "::",
            stringify!(duration)
        )
    );
}
#[doc = " Threshold applied to client callback requests"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_CLOCK_REQUEST_THRESHOLD_T {
    #[doc = " Frames with a media-time difference (compared to current media-time)"]
    #[doc = " above this threshold are dropped (microseconds)"]
    pub threshold: i64,
    #[doc = " Enable/disable the request threshold"]
    pub threshold_enable: MMAL_BOOL_T,
}
#[test]
fn bindgen_test_layout_MMAL_CLOCK_REQUEST_THRESHOLD_T() {
    assert_eq!(
        ::std::mem::size_of::<MMAL_CLOCK_REQUEST_THRESHOLD_T>(),
        16usize,
        concat!("Size of: ", stringify!(MMAL_CLOCK_REQUEST_THRESHOLD_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_CLOCK_REQUEST_THRESHOLD_T>(),
        8usize,
        concat!("Alignment of ", stringify!(MMAL_CLOCK_REQUEST_THRESHOLD_T))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_CLOCK_REQUEST_THRESHOLD_T>())).threshold as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_CLOCK_REQUEST_THRESHOLD_T),
            "::",
            stringify!(threshold)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_CLOCK_REQUEST_THRESHOLD_T>())).threshold_enable as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_CLOCK_REQUEST_THRESHOLD_T),
            "::",
            stringify!(threshold_enable)
        )
    );
}
#[doc = " Structure for passing buffer information to a clock port"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_CLOCK_BUFFER_INFO_T {
    pub time_stamp: i64,
    pub arrival_time: u32,
}
#[test]
fn bindgen_test_layout_MMAL_CLOCK_BUFFER_INFO_T() {
    assert_eq!(
        ::std::mem::size_of::<MMAL_CLOCK_BUFFER_INFO_T>(),
        16usize,
        concat!("Size of: ", stringify!(MMAL_CLOCK_BUFFER_INFO_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_CLOCK_BUFFER_INFO_T>(),
        8usize,
        concat!("Alignment of ", stringify!(MMAL_CLOCK_BUFFER_INFO_T))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_CLOCK_BUFFER_INFO_T>())).time_stamp as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_CLOCK_BUFFER_INFO_T),
            "::",
            stringify!(time_stamp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_CLOCK_BUFFER_INFO_T>())).arrival_time as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_CLOCK_BUFFER_INFO_T),
            "::",
            stringify!(arrival_time)
        )
    );
}
#[doc = " Clock latency settings used by the clock component"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_CLOCK_LATENCY_T {
    #[doc = "< target latency (microseconds)"]
    pub target: i64,
    #[doc = "< duration of one attack period (microseconds)"]
    pub attack_period: i64,
    #[doc = "< amount by which media-time will be adjusted"]
    #[doc = "every attack_period (microseconds)"]
    pub attack_rate: i64,
}
#[test]
fn bindgen_test_layout_MMAL_CLOCK_LATENCY_T() {
    assert_eq!(
        ::std::mem::size_of::<MMAL_CLOCK_LATENCY_T>(),
        24usize,
        concat!("Size of: ", stringify!(MMAL_CLOCK_LATENCY_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_CLOCK_LATENCY_T>(),
        8usize,
        concat!("Alignment of ", stringify!(MMAL_CLOCK_LATENCY_T))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_CLOCK_LATENCY_T>())).target as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_CLOCK_LATENCY_T),
            "::",
            stringify!(target)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_CLOCK_LATENCY_T>())).attack_period as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_CLOCK_LATENCY_T),
            "::",
            stringify!(attack_period)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_CLOCK_LATENCY_T>())).attack_rate as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_CLOCK_LATENCY_T),
            "::",
            stringify!(attack_rate)
        )
    );
}
#[doc = " Clock event used to pass data between clock ports and a client."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct MMAL_CLOCK_EVENT_T {
    #[doc = " 4cc event id"]
    pub id: u32,
    #[doc = " 4cc event magic"]
    pub magic: u32,
    #[doc = " buffer associated with this event (can be NULL)"]
    pub buffer: *mut MMAL_BUFFER_HEADER_T,
    #[doc = " pad to 64-bit boundary"]
    pub padding0: u32,
    pub data: MMAL_CLOCK_EVENT_T__bindgen_ty_1,
    #[doc = " pad to 64-bit boundary"]
    pub padding1: u64,
}
#[doc = " additional event data (type-specific)"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union MMAL_CLOCK_EVENT_T__bindgen_ty_1 {
    #[doc = " used either for clock reference or clock state"]
    pub enable: MMAL_BOOL_T,
    #[doc = " new clock scale"]
    pub scale: MMAL_RATIONAL_T,
    #[doc = " new media-time"]
    pub media_time: i64,
    #[doc = " media-time update threshold"]
    pub update_threshold: MMAL_CLOCK_UPDATE_THRESHOLD_T,
    #[doc = " media-time discontinuity threshold"]
    pub discont_threshold: MMAL_CLOCK_DISCONT_THRESHOLD_T,
    #[doc = " client callback request threshold"]
    pub request_threshold: MMAL_CLOCK_REQUEST_THRESHOLD_T,
    #[doc = " input/output buffer information"]
    pub buffer: MMAL_CLOCK_BUFFER_INFO_T,
    #[doc = " clock latency setting"]
    pub latency: MMAL_CLOCK_LATENCY_T,
    _bindgen_union_align: [u64; 3usize],
}
#[test]
fn bindgen_test_layout_MMAL_CLOCK_EVENT_T__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<MMAL_CLOCK_EVENT_T__bindgen_ty_1>(),
        24usize,
        concat!("Size of: ", stringify!(MMAL_CLOCK_EVENT_T__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_CLOCK_EVENT_T__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(MMAL_CLOCK_EVENT_T__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_CLOCK_EVENT_T__bindgen_ty_1>())).enable as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_CLOCK_EVENT_T__bindgen_ty_1),
            "::",
            stringify!(enable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_CLOCK_EVENT_T__bindgen_ty_1>())).scale as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_CLOCK_EVENT_T__bindgen_ty_1),
            "::",
            stringify!(scale)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_CLOCK_EVENT_T__bindgen_ty_1>())).media_time as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_CLOCK_EVENT_T__bindgen_ty_1),
            "::",
            stringify!(media_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_CLOCK_EVENT_T__bindgen_ty_1>())).update_threshold
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_CLOCK_EVENT_T__bindgen_ty_1),
            "::",
            stringify!(update_threshold)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_CLOCK_EVENT_T__bindgen_ty_1>())).discont_threshold
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_CLOCK_EVENT_T__bindgen_ty_1),
            "::",
            stringify!(discont_threshold)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_CLOCK_EVENT_T__bindgen_ty_1>())).request_threshold
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_CLOCK_EVENT_T__bindgen_ty_1),
            "::",
            stringify!(request_threshold)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_CLOCK_EVENT_T__bindgen_ty_1>())).buffer as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_CLOCK_EVENT_T__bindgen_ty_1),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_CLOCK_EVENT_T__bindgen_ty_1>())).latency as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_CLOCK_EVENT_T__bindgen_ty_1),
            "::",
            stringify!(latency)
        )
    );
}
impl ::std::fmt::Debug for MMAL_CLOCK_EVENT_T__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "MMAL_CLOCK_EVENT_T__bindgen_ty_1 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout_MMAL_CLOCK_EVENT_T() {
    assert_eq!(
        ::std::mem::size_of::<MMAL_CLOCK_EVENT_T>(),
        48usize,
        concat!("Size of: ", stringify!(MMAL_CLOCK_EVENT_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_CLOCK_EVENT_T>(),
        8usize,
        concat!("Alignment of ", stringify!(MMAL_CLOCK_EVENT_T))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_CLOCK_EVENT_T>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_CLOCK_EVENT_T),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_CLOCK_EVENT_T>())).magic as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_CLOCK_EVENT_T),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_CLOCK_EVENT_T>())).buffer as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_CLOCK_EVENT_T),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_CLOCK_EVENT_T>())).padding0 as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_CLOCK_EVENT_T),
            "::",
            stringify!(padding0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_CLOCK_EVENT_T>())).data as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_CLOCK_EVENT_T),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_CLOCK_EVENT_T>())).padding1 as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_CLOCK_EVENT_T),
            "::",
            stringify!(padding1)
        )
    );
}
impl ::std::fmt::Debug for MMAL_CLOCK_EVENT_T {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! ( f , "MMAL_CLOCK_EVENT_T {{ id: {:?}, magic: {:?}, buffer: {:?}, padding0: {:?}, data: {:?}, padding1: {:?} }}" , self . id , self . magic , self . buffer , self . padding0 , self . data , self . padding1 )
    }
}
#[doc = "< Takes a MMAL_PARAMETER_BOOLEAN_T"]
pub const MMAL_PARAMETER_CLOCK_REFERENCE: _bindgen_ty_29 = 262144;
#[doc = "< Takes a MMAL_PARAMETER_BOOLEAN_T"]
pub const MMAL_PARAMETER_CLOCK_ACTIVE: _bindgen_ty_29 = 262145;
#[doc = "< Takes a MMAL_PARAMETER_RATIONAL_T"]
pub const MMAL_PARAMETER_CLOCK_SCALE: _bindgen_ty_29 = 262146;
#[doc = "< Takes a MMAL_PARAMETER_INT64_T"]
pub const MMAL_PARAMETER_CLOCK_TIME: _bindgen_ty_29 = 262147;
#[doc = "< Takes a MMAL_PARAMETER_CLOCK_UPDATE_THRESHOLD_T"]
pub const MMAL_PARAMETER_CLOCK_UPDATE_THRESHOLD: _bindgen_ty_29 = 262148;
#[doc = "< Takes a MMAL_PARAMETER_CLOCK_DISCONT_THRESHOLD_T"]
pub const MMAL_PARAMETER_CLOCK_DISCONT_THRESHOLD: _bindgen_ty_29 = 262149;
#[doc = "< Takes a MMAL_PARAMETER_CLOCK_REQUEST_THRESHOLD_T"]
pub const MMAL_PARAMETER_CLOCK_REQUEST_THRESHOLD: _bindgen_ty_29 = 262150;
#[doc = "< Takes a MMAL_PARAMETER_BOOLEAN_T"]
pub const MMAL_PARAMETER_CLOCK_ENABLE_BUFFER_INFO: _bindgen_ty_29 = 262151;
#[doc = "< Takes a MMAL_PARAMETER_RATIONAL_T"]
pub const MMAL_PARAMETER_CLOCK_FRAME_RATE: _bindgen_ty_29 = 262152;
#[doc = "< Takes a MMAL_PARAMETER_CLOCK_LATENCY_T"]
pub const MMAL_PARAMETER_CLOCK_LATENCY: _bindgen_ty_29 = 262153;
#[doc = " Clock-specific MMAL parameter IDs."]
#[doc = " @ingroup MMAL_PARAMETER_IDS"]
pub type _bindgen_ty_29 = u32;
#[doc = " Media-time update thresholds"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_CLOCK_UPDATE_THRESHOLD_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    pub value: MMAL_CLOCK_UPDATE_THRESHOLD_T,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_CLOCK_UPDATE_THRESHOLD_T() {
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_CLOCK_UPDATE_THRESHOLD_T>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(MMAL_PARAMETER_CLOCK_UPDATE_THRESHOLD_T)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_CLOCK_UPDATE_THRESHOLD_T>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(MMAL_PARAMETER_CLOCK_UPDATE_THRESHOLD_T)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CLOCK_UPDATE_THRESHOLD_T>())).hdr as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CLOCK_UPDATE_THRESHOLD_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CLOCK_UPDATE_THRESHOLD_T>())).value as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CLOCK_UPDATE_THRESHOLD_T),
            "::",
            stringify!(value)
        )
    );
}
#[doc = " Media-time discontinuity settings"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_CLOCK_DISCONT_THRESHOLD_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    pub value: MMAL_CLOCK_DISCONT_THRESHOLD_T,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_CLOCK_DISCONT_THRESHOLD_T() {
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_CLOCK_DISCONT_THRESHOLD_T>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(MMAL_PARAMETER_CLOCK_DISCONT_THRESHOLD_T)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_CLOCK_DISCONT_THRESHOLD_T>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(MMAL_PARAMETER_CLOCK_DISCONT_THRESHOLD_T)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CLOCK_DISCONT_THRESHOLD_T>())).hdr as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CLOCK_DISCONT_THRESHOLD_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CLOCK_DISCONT_THRESHOLD_T>())).value as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CLOCK_DISCONT_THRESHOLD_T),
            "::",
            stringify!(value)
        )
    );
}
#[doc = " Media-time future frame drop settings"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_CLOCK_REQUEST_THRESHOLD_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    pub value: MMAL_CLOCK_REQUEST_THRESHOLD_T,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_CLOCK_REQUEST_THRESHOLD_T() {
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_CLOCK_REQUEST_THRESHOLD_T>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(MMAL_PARAMETER_CLOCK_REQUEST_THRESHOLD_T)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_CLOCK_REQUEST_THRESHOLD_T>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(MMAL_PARAMETER_CLOCK_REQUEST_THRESHOLD_T)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CLOCK_REQUEST_THRESHOLD_T>())).hdr as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CLOCK_REQUEST_THRESHOLD_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CLOCK_REQUEST_THRESHOLD_T>())).value as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CLOCK_REQUEST_THRESHOLD_T),
            "::",
            stringify!(value)
        )
    );
}
#[doc = " Clock latency parameter"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_CLOCK_LATENCY_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    pub value: MMAL_CLOCK_LATENCY_T,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_CLOCK_LATENCY_T() {
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_CLOCK_LATENCY_T>(),
        32usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_CLOCK_LATENCY_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_CLOCK_LATENCY_T>(),
        8usize,
        concat!("Alignment of ", stringify!(MMAL_PARAMETER_CLOCK_LATENCY_T))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CLOCK_LATENCY_T>())).hdr as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CLOCK_LATENCY_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CLOCK_LATENCY_T>())).value as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CLOCK_LATENCY_T),
            "::",
            stringify!(value)
        )
    );
}
#[doc = " Generic unsigned 64-bit integer parameter type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_UINT64_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    #[doc = "< Parameter value"]
    pub value: u64,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_UINT64_T() {
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_UINT64_T>(),
        16usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_UINT64_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_UINT64_T>(),
        8usize,
        concat!("Alignment of ", stringify!(MMAL_PARAMETER_UINT64_T))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_PARAMETER_UINT64_T>())).hdr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_UINT64_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_PARAMETER_UINT64_T>())).value as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_UINT64_T),
            "::",
            stringify!(value)
        )
    );
}
#[doc = " Generic signed 64-bit integer parameter type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_INT64_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    #[doc = "< Parameter value"]
    pub value: i64,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_INT64_T() {
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_INT64_T>(),
        16usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_INT64_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_INT64_T>(),
        8usize,
        concat!("Alignment of ", stringify!(MMAL_PARAMETER_INT64_T))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_PARAMETER_INT64_T>())).hdr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_INT64_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_PARAMETER_INT64_T>())).value as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_INT64_T),
            "::",
            stringify!(value)
        )
    );
}
#[doc = " Generic unsigned 32-bit integer parameter type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_UINT32_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    #[doc = "< Parameter value"]
    pub value: u32,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_UINT32_T() {
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_UINT32_T>(),
        12usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_UINT32_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_UINT32_T>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_PARAMETER_UINT32_T))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_PARAMETER_UINT32_T>())).hdr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_UINT32_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_PARAMETER_UINT32_T>())).value as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_UINT32_T),
            "::",
            stringify!(value)
        )
    );
}
#[doc = " Generic signed 32-bit integer parameter type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_INT32_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    #[doc = "< Parameter value"]
    pub value: i32,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_INT32_T() {
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_INT32_T>(),
        12usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_INT32_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_INT32_T>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_PARAMETER_INT32_T))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_PARAMETER_INT32_T>())).hdr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_INT32_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_PARAMETER_INT32_T>())).value as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_INT32_T),
            "::",
            stringify!(value)
        )
    );
}
#[doc = " Generic rational parameter type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_RATIONAL_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    #[doc = "< Parameter value"]
    pub value: MMAL_RATIONAL_T,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_RATIONAL_T() {
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_RATIONAL_T>(),
        16usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_RATIONAL_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_RATIONAL_T>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_PARAMETER_RATIONAL_T))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_PARAMETER_RATIONAL_T>())).hdr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_RATIONAL_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_PARAMETER_RATIONAL_T>())).value as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_RATIONAL_T),
            "::",
            stringify!(value)
        )
    );
}
#[doc = " Generic boolean parameter type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_BOOLEAN_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    #[doc = "< Parameter value"]
    pub enable: MMAL_BOOL_T,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_BOOLEAN_T() {
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_BOOLEAN_T>(),
        12usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_BOOLEAN_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_BOOLEAN_T>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_PARAMETER_BOOLEAN_T))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_PARAMETER_BOOLEAN_T>())).hdr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_BOOLEAN_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_PARAMETER_BOOLEAN_T>())).enable as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_BOOLEAN_T),
            "::",
            stringify!(enable)
        )
    );
}
#[doc = " Generic string parameter type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_STRING_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    #[doc = "< Null-terminated string"]
    pub str: [::std::os::raw::c_char; 1usize],
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_STRING_T() {
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_STRING_T>(),
        12usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_STRING_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_STRING_T>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_PARAMETER_STRING_T))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_PARAMETER_STRING_T>())).hdr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_STRING_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_PARAMETER_STRING_T>())).str as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_STRING_T),
            "::",
            stringify!(str)
        )
    );
}
#[doc = " Generic array of bytes parameter type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_BYTES_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    #[doc = "< Array of bytes"]
    pub data: [u8; 1usize],
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_BYTES_T() {
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_BYTES_T>(),
        12usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_BYTES_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_BYTES_T>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_PARAMETER_BYTES_T))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_PARAMETER_BYTES_T>())).hdr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_BYTES_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_PARAMETER_BYTES_T>())).data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_BYTES_T),
            "::",
            stringify!(data)
        )
    );
}
#[doc = " Generic two-dimensional scaling factor type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_SCALEFACTOR_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    #[doc = "< Scaling factor in X-axis"]
    pub scale_x: MMAL_FIXED_16_16_T,
    #[doc = "< Scaling factor in Y-axis"]
    pub scale_y: MMAL_FIXED_16_16_T,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_SCALEFACTOR_T() {
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_SCALEFACTOR_T>(),
        16usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_SCALEFACTOR_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_SCALEFACTOR_T>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_PARAMETER_SCALEFACTOR_T))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_SCALEFACTOR_T>())).hdr as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_SCALEFACTOR_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_SCALEFACTOR_T>())).scale_x as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_SCALEFACTOR_T),
            "::",
            stringify!(scale_x)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_SCALEFACTOR_T>())).scale_y as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_SCALEFACTOR_T),
            "::",
            stringify!(scale_y)
        )
    );
}
pub const MMAL_PARAM_MIRROR_T_MMAL_PARAM_MIRROR_NONE: MMAL_PARAM_MIRROR_T = 0;
pub const MMAL_PARAM_MIRROR_T_MMAL_PARAM_MIRROR_VERTICAL: MMAL_PARAM_MIRROR_T = 1;
pub const MMAL_PARAM_MIRROR_T_MMAL_PARAM_MIRROR_HORIZONTAL: MMAL_PARAM_MIRROR_T = 2;
pub const MMAL_PARAM_MIRROR_T_MMAL_PARAM_MIRROR_BOTH: MMAL_PARAM_MIRROR_T = 3;
#[doc = " Valid mirror modes"]
pub type MMAL_PARAM_MIRROR_T = u32;
#[doc = " Generic mirror parameter type"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_MIRROR_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    #[doc = "< Mirror mode"]
    pub value: MMAL_PARAM_MIRROR_T,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_MIRROR_T() {
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_MIRROR_T>(),
        12usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_MIRROR_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_MIRROR_T>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_PARAMETER_MIRROR_T))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_PARAMETER_MIRROR_T>())).hdr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_MIRROR_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_PARAMETER_MIRROR_T>())).value as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_MIRROR_T),
            "::",
            stringify!(value)
        )
    );
}
#[doc = " URI parameter type."]
#[doc = " The parameter may hold an arbitrary length, nul-terminated string as long"]
#[doc = " as the size is set appropriately."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_URI_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    #[doc = "< URI string (null-terminated)"]
    pub uri: [::std::os::raw::c_char; 1usize],
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_URI_T() {
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_URI_T>(),
        12usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_URI_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_URI_T>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_PARAMETER_URI_T))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_PARAMETER_URI_T>())).hdr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_URI_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_PARAMETER_URI_T>())).uri as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_URI_T),
            "::",
            stringify!(uri)
        )
    );
}
#[doc = " Generic encoding parameter type."]
#[doc = " The parameter may hold more than one encoding by overriding the size to"]
#[doc = " include a bigger array."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_ENCODING_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    #[doc = "< Array of FourCC encodings, see \\ref MmalEncodings"]
    pub encoding: [u32; 1usize],
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_ENCODING_T() {
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_ENCODING_T>(),
        12usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_ENCODING_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_ENCODING_T>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_PARAMETER_ENCODING_T))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_PARAMETER_ENCODING_T>())).hdr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_ENCODING_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_ENCODING_T>())).encoding as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_ENCODING_T),
            "::",
            stringify!(encoding)
        )
    );
}
#[doc = " Generic frame-rate parameter type."]
#[doc = " Frame rates are specified as a rational number, using a pair of integers."]
#[doc = " Since there can be many valid pairs for the same ratio, a frame-rate may"]
#[doc = " not contain exactly the same pairs of values when read back as it was"]
#[doc = " when set."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_FRAME_RATE_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    #[doc = "< Frame-rate value"]
    pub frame_rate: MMAL_RATIONAL_T,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_FRAME_RATE_T() {
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_FRAME_RATE_T>(),
        16usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_FRAME_RATE_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_FRAME_RATE_T>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_PARAMETER_FRAME_RATE_T))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_PARAMETER_FRAME_RATE_T>())).hdr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_FRAME_RATE_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_FRAME_RATE_T>())).frame_rate as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_FRAME_RATE_T),
            "::",
            stringify!(frame_rate)
        )
    );
}
#[doc = " Generic configuration-file setup type."]
#[doc = " Configuration files are transferred in small chunks. The component can"]
#[doc = " save all the chunks into a buffer, then process the entire file later."]
#[doc = " This parameter initialises a config file to have the given size."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_CONFIGFILE_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    #[doc = "< Size of complete file data"]
    pub file_size: u32,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_CONFIGFILE_T() {
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_CONFIGFILE_T>(),
        12usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_CONFIGFILE_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_CONFIGFILE_T>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_PARAMETER_CONFIGFILE_T))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_PARAMETER_CONFIGFILE_T>())).hdr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CONFIGFILE_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CONFIGFILE_T>())).file_size as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CONFIGFILE_T),
            "::",
            stringify!(file_size)
        )
    );
}
#[doc = " Generic configuration-file chunk data type."]
#[doc = " Once a config file has been initialised, this parameter can be used to"]
#[doc = " write an arbitrary chunk of the file data (limited by the maximum MMAL"]
#[doc = " message size)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_CONFIGFILE_CHUNK_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    #[doc = "< Number of bytes being transferred in this chunk"]
    pub size: u32,
    #[doc = "< Offset of this chunk in the file"]
    pub offset: u32,
    #[doc = "< Chunk data"]
    pub data: [::std::os::raw::c_char; 1usize],
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_CONFIGFILE_CHUNK_T() {
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_CONFIGFILE_CHUNK_T>(),
        20usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_CONFIGFILE_CHUNK_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_CONFIGFILE_CHUNK_T>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(MMAL_PARAMETER_CONFIGFILE_CHUNK_T)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CONFIGFILE_CHUNK_T>())).hdr as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CONFIGFILE_CHUNK_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CONFIGFILE_CHUNK_T>())).size as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CONFIGFILE_CHUNK_T),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CONFIGFILE_CHUNK_T>())).offset as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CONFIGFILE_CHUNK_T),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PARAMETER_CONFIGFILE_CHUNK_T>())).data as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CONFIGFILE_CHUNK_T),
            "::",
            stringify!(data)
        )
    );
}
#[doc = "< Unknown port type"]
pub const MMAL_PORT_TYPE_T_MMAL_PORT_TYPE_UNKNOWN: MMAL_PORT_TYPE_T = 0;
#[doc = "< Control port"]
pub const MMAL_PORT_TYPE_T_MMAL_PORT_TYPE_CONTROL: MMAL_PORT_TYPE_T = 1;
#[doc = "< Input port"]
pub const MMAL_PORT_TYPE_T_MMAL_PORT_TYPE_INPUT: MMAL_PORT_TYPE_T = 2;
#[doc = "< Output port"]
pub const MMAL_PORT_TYPE_T_MMAL_PORT_TYPE_OUTPUT: MMAL_PORT_TYPE_T = 3;
#[doc = "< Clock port"]
pub const MMAL_PORT_TYPE_T_MMAL_PORT_TYPE_CLOCK: MMAL_PORT_TYPE_T = 4;
#[doc = "< Dummy value to force 32bit enum"]
pub const MMAL_PORT_TYPE_T_MMAL_PORT_TYPE_INVALID: MMAL_PORT_TYPE_T = 4294967295;
#[doc = " List of port types"]
pub type MMAL_PORT_TYPE_T = u32;
#[doc = " Definition of a port."]
#[doc = " A port is the entity that is exposed by components to receive or transmit"]
#[doc = " buffer headers (\\ref MMAL_BUFFER_HEADER_T). A port is defined by its"]
#[doc = " \\ref MMAL_ES_FORMAT_T."]
#[doc = ""]
#[doc = " It may be possible to override the buffer requirements of a port by using"]
#[doc = " the MMAL_PARAMETER_BUFFER_REQUIREMENTS parameter."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PORT_T {
    #[doc = "< Private member used by the framework"]
    pub priv_: *mut MMAL_PORT_PRIVATE_T,
    #[doc = "< Port name. Used for debugging purposes (Read Only)"]
    pub name: *const ::std::os::raw::c_char,
    #[doc = "< Type of the port (Read Only)"]
    pub type_: MMAL_PORT_TYPE_T,
    #[doc = "< Index of the port in its type list (Read Only)"]
    pub index: u16,
    #[doc = "< Index of the port in the list of all ports (Read Only)"]
    pub index_all: u16,
    #[doc = "< Indicates whether the port is enabled or not (Read Only)"]
    pub is_enabled: u32,
    #[doc = "< Format of the elementary stream"]
    pub format: *mut MMAL_ES_FORMAT_T,
    #[doc = "< Minimum number of buffers the port requires (Read Only)."]
    #[doc = "This is set by the component."]
    pub buffer_num_min: u32,
    #[doc = "< Minimum size of buffers the port requires (Read Only)."]
    #[doc = "This is set by the component."]
    pub buffer_size_min: u32,
    #[doc = "< Minimum alignment requirement for the buffers (Read Only)."]
    #[doc = "A value of zero means no special alignment requirements."]
    #[doc = "This is set by the component."]
    pub buffer_alignment_min: u32,
    #[doc = "< Number of buffers the port recommends for optimal performance (Read Only)."]
    #[doc = "A value of zero means no special recommendation."]
    #[doc = "This is set by the component."]
    pub buffer_num_recommended: u32,
    #[doc = "< Size of buffers the port recommends for optimal performance (Read Only)."]
    #[doc = "A value of zero means no special recommendation."]
    #[doc = "This is set by the component."]
    pub buffer_size_recommended: u32,
    #[doc = "< Actual number of buffers the port will use."]
    #[doc = "This is set by the client."]
    pub buffer_num: u32,
    #[doc = "< Actual maximum size of the buffers that will be sent"]
    #[doc = "to the port. This is set by the client."]
    pub buffer_size: u32,
    #[doc = "< Component this port belongs to (Read Only)"]
    pub component: *mut MMAL_COMPONENT_T,
    #[doc = "< Field reserved for use by the client"]
    pub userdata: *mut MMAL_PORT_USERDATA_T,
    #[doc = "< Flags describing the capabilities of a port (Read Only)."]
    #[doc = " Bitwise combination of \\ref portcapabilities \"Port capabilities\""]
    #[doc = " values."]
    pub capabilities: u32,
}
#[test]
fn bindgen_test_layout_MMAL_PORT_T() {
    assert_eq!(
        ::std::mem::size_of::<MMAL_PORT_T>(),
        64usize,
        concat!("Size of: ", stringify!(MMAL_PORT_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PORT_T>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_PORT_T))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_PORT_T>())).priv_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PORT_T),
            "::",
            stringify!(priv_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_PORT_T>())).name as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PORT_T),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_PORT_T>())).type_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PORT_T),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_PORT_T>())).index as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PORT_T),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_PORT_T>())).index_all as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PORT_T),
            "::",
            stringify!(index_all)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_PORT_T>())).is_enabled as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PORT_T),
            "::",
            stringify!(is_enabled)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_PORT_T>())).format as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PORT_T),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_PORT_T>())).buffer_num_min as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PORT_T),
            "::",
            stringify!(buffer_num_min)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_PORT_T>())).buffer_size_min as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PORT_T),
            "::",
            stringify!(buffer_size_min)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PORT_T>())).buffer_alignment_min as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PORT_T),
            "::",
            stringify!(buffer_alignment_min)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PORT_T>())).buffer_num_recommended as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PORT_T),
            "::",
            stringify!(buffer_num_recommended)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_PORT_T>())).buffer_size_recommended as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PORT_T),
            "::",
            stringify!(buffer_size_recommended)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_PORT_T>())).buffer_num as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PORT_T),
            "::",
            stringify!(buffer_num)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_PORT_T>())).buffer_size as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PORT_T),
            "::",
            stringify!(buffer_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_PORT_T>())).component as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PORT_T),
            "::",
            stringify!(component)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_PORT_T>())).userdata as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PORT_T),
            "::",
            stringify!(userdata)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_PORT_T>())).capabilities as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PORT_T),
            "::",
            stringify!(capabilities)
        )
    );
}
extern "C" {
    #[doc = " Commit format changes on a port."]
    #[doc = ""]
    #[doc = " @param port The port for which format changes are to be committed."]
    #[doc = " @return MMAL_SUCCESS on success"]
    pub fn mmal_port_format_commit(port: *mut MMAL_PORT_T) -> MMAL_STATUS_T::Type;
}
#[doc = " Definition of the callback used by a port to send a \\ref MMAL_BUFFER_HEADER_T"]
#[doc = " back to the user."]
#[doc = ""]
#[doc = " @param port The port sending the buffer header."]
#[doc = " @param buffer The buffer header being sent."]
pub type MMAL_PORT_BH_CB_T = ::std::option::Option<
    unsafe extern "C" fn(port: *mut MMAL_PORT_T, buffer: *mut MMAL_BUFFER_HEADER_T),
>;
extern "C" {
    #[doc = " Enable processing on a port"]
    #[doc = ""]
    #[doc = " If this port is connected to another, the given callback must be NULL, while for a"]
    #[doc = " disconnected port, the callback must be non-NULL."]
    #[doc = ""]
    #[doc = " If this is a connected output port and is successfully enabled:"]
    #[doc = " <ul>"]
    #[doc = " <li>The port shall be populated with a pool of buffers, allocated as required, according"]
    #[doc = " to the buffer_num and buffer_size values."]
    #[doc = " <li>The input port to which it is connected shall be set to the same buffer"]
    #[doc = " configuration and then be enabled. Should that fail, the original port shall be"]
    #[doc = " disabled."]
    #[doc = " </ul>"]
    #[doc = ""]
    #[doc = " @param port port to enable"]
    #[doc = " @param cb callback use by the port to send a \\ref MMAL_BUFFER_HEADER_T back"]
    #[doc = " @return MMAL_SUCCESS on success"]
    pub fn mmal_port_enable(port: *mut MMAL_PORT_T, cb: MMAL_PORT_BH_CB_T) -> MMAL_STATUS_T::Type;
}
extern "C" {
    #[doc = " Disable processing on a port"]
    #[doc = ""]
    #[doc = " Disabling a port will stop all processing on this port and return all (non-processed)"]
    #[doc = " buffer headers to the client."]
    #[doc = ""]
    #[doc = " If this is a connected output port, the input port to which it is connected shall"]
    #[doc = " also be disabled. Any buffer pool shall be released."]
    #[doc = ""]
    #[doc = " @param port port to disable"]
    #[doc = " @return MMAL_SUCCESS on success"]
    pub fn mmal_port_disable(port: *mut MMAL_PORT_T) -> MMAL_STATUS_T::Type;
}
extern "C" {
    #[doc = " Ask a port to release all the buffer headers it currently has."]
    #[doc = ""]
    #[doc = " Flushing a port will ask the port to send all the buffer headers it currently has"]
    #[doc = " to the client. Flushing is an asynchronous request and the flush call will"]
    #[doc = " return before all the buffer headers are returned to the client."]
    #[doc = " It is up to the client to keep a count on the buffer headers to know when the"]
    #[doc = " flush operation has completed."]
    #[doc = " It is also important to note that flushing will also reset the state of the port"]
    #[doc = " and any processing which was buffered by the port will be lost."]
    #[doc = ""]
    #[doc = " \\attention Flushing a connected port behaviour TBD."]
    #[doc = ""]
    #[doc = " @param port The port to flush."]
    #[doc = " @return MMAL_SUCCESS on success"]
    pub fn mmal_port_flush(port: *mut MMAL_PORT_T) -> MMAL_STATUS_T::Type;
}
extern "C" {
    #[doc = " Set a parameter on a port."]
    #[doc = ""]
    #[doc = " @param port The port to which the request is sent."]
    #[doc = " @param param The pointer to the header of the parameter to set."]
    #[doc = " @return MMAL_SUCCESS on success"]
    pub fn mmal_port_parameter_set(
        port: *mut MMAL_PORT_T,
        param: *const MMAL_PARAMETER_HEADER_T,
    ) -> MMAL_STATUS_T::Type;
}
extern "C" {
    #[doc = " Get a parameter from a port."]
    #[doc = " The size field must be set on input to the maximum size of the parameter"]
    #[doc = " (including the header) and will be set on output to the actual size of the"]
    #[doc = " parameter retrieved."]
    #[doc = ""]
    #[doc = " \\note If MMAL_ENOSPC is returned, the parameter is larger than the size"]
    #[doc = " given. The given parameter will have been filled up to its size and then"]
    #[doc = " the size field set to the full parameter's size. This can be used to"]
    #[doc = " resize the parameter buffer so that a second call should succeed."]
    #[doc = ""]
    #[doc = " @param port The port to which the request is sent."]
    #[doc = " @param param The pointer to the header of the parameter to get."]
    #[doc = " @return MMAL_SUCCESS on success"]
    pub fn mmal_port_parameter_get(
        port: *mut MMAL_PORT_T,
        param: *mut MMAL_PARAMETER_HEADER_T,
    ) -> MMAL_STATUS_T::Type;
}
extern "C" {
    #[doc = " Send a buffer header to a port."]
    #[doc = ""]
    #[doc = " @param port The port to which the buffer header is to be sent."]
    #[doc = " @param buffer The buffer header to send."]
    #[doc = " @return MMAL_SUCCESS on success"]
    pub fn mmal_port_send_buffer(
        port: *mut MMAL_PORT_T,
        buffer: *mut MMAL_BUFFER_HEADER_T,
    ) -> MMAL_STATUS_T::Type;
}
extern "C" {
    #[doc = " Connect an output port to an input port."]
    #[doc = ""]
    #[doc = " When connected and enabled, buffers will automatically progress from the"]
    #[doc = " output port to the input port when they become available, and released back"]
    #[doc = " to the output port when no longer required by the input port."]
    #[doc = ""]
    #[doc = " Ports can be given either way around, but one must be an output port and"]
    #[doc = " the other must be an input port. Neither can be connected or enabled"]
    #[doc = " already. The format of the output port will be applied to the input port"]
    #[doc = " on connection."]
    #[doc = ""]
    #[doc = " @param port One of the ports to connect."]
    #[doc = " @param other_port The other port to connect."]
    #[doc = " @return MMAL_SUCCESS on success."]
    pub fn mmal_port_connect(
        port: *mut MMAL_PORT_T,
        other_port: *mut MMAL_PORT_T,
    ) -> MMAL_STATUS_T::Type;
}
extern "C" {
    #[doc = " Disconnect a connected port."]
    #[doc = ""]
    #[doc = " If the port is not connected, an error will be returned. Otherwise, if the"]
    #[doc = " ports are enabled, they will be disabled and any buffer pool created will be"]
    #[doc = " freed."]
    #[doc = ""]
    #[doc = " @param port The ports to disconnect."]
    #[doc = " @return MMAL_SUCCESS on success."]
    pub fn mmal_port_disconnect(port: *mut MMAL_PORT_T) -> MMAL_STATUS_T::Type;
}
extern "C" {
    #[doc = " Allocate a payload buffer."]
    #[doc = " This allows a client to allocate memory for a payload buffer based on the preferences"]
    #[doc = " of a port. This for instance will allow the port to allocate memory which can be shared"]
    #[doc = " between the host processor and videocore."]
    #[doc = ""]
    #[doc = " See \\ref mmal_pool_create_with_allocator()."]
    #[doc = ""]
    #[doc = " @param port         Port responsible for allocating the memory."]
    #[doc = " @param payload_size Size of the payload buffer which will be allocated."]
    #[doc = ""]
    #[doc = " @return Pointer to the allocated memory."]
    pub fn mmal_port_payload_alloc(port: *mut MMAL_PORT_T, payload_size: u32) -> *mut u8;
}
extern "C" {
    #[doc = " Free a payload buffer."]
    #[doc = " This allows a client to free memory allocated by a previous call to \\ref mmal_port_payload_alloc."]
    #[doc = ""]
    #[doc = " See \\ref mmal_pool_create_with_allocator()."]
    #[doc = ""]
    #[doc = " @param port         Port responsible for allocating the memory."]
    #[doc = " @param payload      Pointer to the memory to free."]
    pub fn mmal_port_payload_free(port: *mut MMAL_PORT_T, payload: *mut u8);
}
extern "C" {
    #[doc = " Get an empty event buffer header from a port"]
    #[doc = ""]
    #[doc = " @param port The port from which to get the event buffer header."]
    #[doc = " @param buffer The address of a buffer header pointer, which will be set on return."]
    #[doc = " @param event The specific event FourCC required. See the \\ref MmalEvents \"pre-defined events\"."]
    #[doc = " @return MMAL_SUCCESS on success"]
    pub fn mmal_port_event_get(
        port: *mut MMAL_PORT_T,
        buffer: *mut *mut MMAL_BUFFER_HEADER_T,
        event: u32,
    ) -> MMAL_STATUS_T::Type;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_COMPONENT_PRIVATE_T {
    _unused: [u8; 0],
}
#[doc = " Definition of a component."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_COMPONENT_T {
    #[doc = " Pointer to the private data of the module in use"]
    pub priv_: *mut MMAL_COMPONENT_PRIVATE_T,
    #[doc = " Pointer to private data of the client"]
    pub userdata: *mut MMAL_COMPONENT_USERDATA_T,
    #[doc = " Component name"]
    pub name: *const ::std::os::raw::c_char,
    #[doc = " Specifies whether the component is enabled or not"]
    pub is_enabled: u32,
    #[doc = " All components expose a control port."]
    #[doc = " The control port is used by clients to set / get parameters that are global to the"]
    #[doc = " component. It is also used to receive events, which again are global to the component."]
    #[doc = " To be able to receive events, the client needs to enable and register a callback on the"]
    #[doc = " control port."]
    pub control: *mut MMAL_PORT_T,
    #[doc = "< Number of input ports"]
    pub input_num: u32,
    #[doc = "< Array of input ports"]
    pub input: *mut *mut MMAL_PORT_T,
    #[doc = "< Number of output ports"]
    pub output_num: u32,
    #[doc = "< Array of output ports"]
    pub output: *mut *mut MMAL_PORT_T,
    #[doc = "< Number of clock ports"]
    pub clock_num: u32,
    #[doc = "< Array of clock ports"]
    pub clock: *mut *mut MMAL_PORT_T,
    #[doc = "< Total number of ports"]
    pub port_num: u32,
    #[doc = "< Array of all the ports (control/input/output/clock)"]
    pub port: *mut *mut MMAL_PORT_T,
    #[doc = " Uniquely identifies the component's instance within the MMAL"]
    #[doc = " context / process. For debugging."]
    pub id: u32,
}
#[test]
fn bindgen_test_layout_MMAL_COMPONENT_T() {
    assert_eq!(
        ::std::mem::size_of::<MMAL_COMPONENT_T>(),
        56usize,
        concat!("Size of: ", stringify!(MMAL_COMPONENT_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_COMPONENT_T>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_COMPONENT_T))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_COMPONENT_T>())).priv_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_COMPONENT_T),
            "::",
            stringify!(priv_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_COMPONENT_T>())).userdata as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_COMPONENT_T),
            "::",
            stringify!(userdata)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_COMPONENT_T>())).name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_COMPONENT_T),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_COMPONENT_T>())).is_enabled as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_COMPONENT_T),
            "::",
            stringify!(is_enabled)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_COMPONENT_T>())).control as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_COMPONENT_T),
            "::",
            stringify!(control)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_COMPONENT_T>())).input_num as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_COMPONENT_T),
            "::",
            stringify!(input_num)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_COMPONENT_T>())).input as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_COMPONENT_T),
            "::",
            stringify!(input)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_COMPONENT_T>())).output_num as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_COMPONENT_T),
            "::",
            stringify!(output_num)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_COMPONENT_T>())).output as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_COMPONENT_T),
            "::",
            stringify!(output)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_COMPONENT_T>())).clock_num as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_COMPONENT_T),
            "::",
            stringify!(clock_num)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_COMPONENT_T>())).clock as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_COMPONENT_T),
            "::",
            stringify!(clock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_COMPONENT_T>())).port_num as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_COMPONENT_T),
            "::",
            stringify!(port_num)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_COMPONENT_T>())).port as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_COMPONENT_T),
            "::",
            stringify!(port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_COMPONENT_T>())).id as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_COMPONENT_T),
            "::",
            stringify!(id)
        )
    );
}
extern "C" {
    #[doc = " Create an instance of a component."]
    #[doc = " The newly created component will expose ports to the client. All the exposed ports are"]
    #[doc = " disabled by default."]
    #[doc = " Note that components are reference counted and creating a component automatically"]
    #[doc = " acquires a reference to it (released when \\ref mmal_component_destroy is called)."]
    #[doc = ""]
    #[doc = " @param name name of the component to create, e.g. \"video_decode\""]
    #[doc = " @param component returned component"]
    #[doc = " @return MMAL_SUCCESS on success"]
    pub fn mmal_component_create(
        name: *const ::std::os::raw::c_char,
        component: *mut *mut MMAL_COMPONENT_T,
    ) -> MMAL_STATUS_T::Type;
}
extern "C" {
    #[doc = " Acquire a reference on a component."]
    #[doc = " Acquiring a reference on a component will prevent a component from being destroyed until"]
    #[doc = " the acquired reference is released (by a call to \\ref mmal_component_destroy)."]
    #[doc = " References are internally counted so all acquired references need a matching call to"]
    #[doc = " release them."]
    #[doc = ""]
    #[doc = " @param component component to acquire"]
    pub fn mmal_component_acquire(component: *mut MMAL_COMPONENT_T);
}
extern "C" {
    #[doc = " Release a reference on a component"]
    #[doc = " Release an acquired reference on a component. Triggers the destruction of the component when"]
    #[doc = " the last reference is being released."]
    #[doc = " \\note This is in fact an alias of \\ref mmal_component_destroy which is added to make client"]
    #[doc = " code clearer."]
    #[doc = ""]
    #[doc = " @param component component to release"]
    #[doc = " @return MMAL_SUCCESS on success"]
    pub fn mmal_component_release(component: *mut MMAL_COMPONENT_T) -> MMAL_STATUS_T::Type;
}
extern "C" {
    #[doc = " Destroy a previously created component"]
    #[doc = " Release an acquired reference on a component. Only actually destroys the component when"]
    #[doc = " the last reference is being released."]
    #[doc = ""]
    #[doc = " @param component component to destroy"]
    #[doc = " @return MMAL_SUCCESS on success"]
    pub fn mmal_component_destroy(component: *mut MMAL_COMPONENT_T) -> MMAL_STATUS_T::Type;
}
extern "C" {
    #[doc = " Enable processing on a component"]
    #[doc = " @param component component to enable"]
    #[doc = " @return MMAL_SUCCESS on success"]
    pub fn mmal_component_enable(component: *mut MMAL_COMPONENT_T) -> MMAL_STATUS_T::Type;
}
extern "C" {
    #[doc = " Disable processing on a component"]
    #[doc = " @param component component to disable"]
    #[doc = " @return MMAL_SUCCESS on success"]
    pub fn mmal_component_disable(component: *mut MMAL_COMPONENT_T) -> MMAL_STATUS_T::Type;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_QUEUE_T {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Create a queue of MMAL_BUFFER_HEADER_T"]
    #[doc = ""]
    #[doc = " @return Pointer to the newly created queue or NULL on failure."]
    pub fn mmal_queue_create() -> *mut MMAL_QUEUE_T;
}
extern "C" {
    #[doc = " Put a MMAL_BUFFER_HEADER_T into a queue"]
    #[doc = ""]
    #[doc = " @param queue  Pointer to a queue"]
    #[doc = " @param buffer Pointer to the MMAL_BUFFER_HEADER_T to add to the queue"]
    pub fn mmal_queue_put(queue: *mut MMAL_QUEUE_T, buffer: *mut MMAL_BUFFER_HEADER_T);
}
extern "C" {
    #[doc = " Put a MMAL_BUFFER_HEADER_T back at the start of a queue."]
    #[doc = " This is used when a buffer header was removed from the queue but not"]
    #[doc = " fully processed and needs to be put back where it was originally taken."]
    #[doc = ""]
    #[doc = " @param queue  Pointer to a queue"]
    #[doc = " @param buffer Pointer to the MMAL_BUFFER_HEADER_T to add to the queue"]
    pub fn mmal_queue_put_back(queue: *mut MMAL_QUEUE_T, buffer: *mut MMAL_BUFFER_HEADER_T);
}
extern "C" {
    #[doc = " Get a MMAL_BUFFER_HEADER_T from a queue"]
    #[doc = ""]
    #[doc = " @param queue  Pointer to a queue"]
    #[doc = ""]
    #[doc = " @return pointer to the next MMAL_BUFFER_HEADER_T or NULL if the queue is empty."]
    pub fn mmal_queue_get(queue: *mut MMAL_QUEUE_T) -> *mut MMAL_BUFFER_HEADER_T;
}
extern "C" {
    #[doc = " Wait for a MMAL_BUFFER_HEADER_T from a queue."]
    #[doc = " This is the same as a get except that this will block until a buffer header is"]
    #[doc = " available."]
    #[doc = ""]
    #[doc = " @param queue  Pointer to a queue"]
    #[doc = ""]
    #[doc = " @return pointer to the next MMAL_BUFFER_HEADER_T."]
    pub fn mmal_queue_wait(queue: *mut MMAL_QUEUE_T) -> *mut MMAL_BUFFER_HEADER_T;
}
extern "C" {
    #[doc = " Wait for a MMAL_BUFFER_HEADER_T from a queue, up to a given timeout."]
    #[doc = " This is the same as a wait, except that it will abort in case of timeout."]
    #[doc = ""]
    #[doc = " @param queue  Pointer to a queue"]
    #[doc = " @param timeout Number of milliseconds to wait before"]
    #[doc = "                returning if the semaphore can't be acquired."]
    #[doc = ""]
    #[doc = " @return pointer to the next MMAL_BUFFER_HEADER_T."]
    pub fn mmal_queue_timedwait(
        queue: *mut MMAL_QUEUE_T,
        timeout: VCOS_UNSIGNED,
    ) -> *mut MMAL_BUFFER_HEADER_T;
}
extern "C" {
    #[doc = " Get the number of MMAL_BUFFER_HEADER_T currently in a queue."]
    #[doc = ""]
    #[doc = " @param queue  Pointer to a queue"]
    #[doc = ""]
    #[doc = " @return length (in elements) of the queue."]
    pub fn mmal_queue_length(queue: *mut MMAL_QUEUE_T) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Destroy a queue of MMAL_BUFFER_HEADER_T."]
    #[doc = ""]
    #[doc = " @param queue  Pointer to a queue"]
    pub fn mmal_queue_destroy(queue: *mut MMAL_QUEUE_T);
}
#[doc = " Definition of a pool"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_POOL_T {
    #[doc = "< Queue used by the pool"]
    pub queue: *mut MMAL_QUEUE_T,
    #[doc = "< Number of buffer headers in the pool"]
    pub headers_num: u32,
    #[doc = "< Array of buffer headers belonging to the pool"]
    pub header: *mut *mut MMAL_BUFFER_HEADER_T,
}
#[test]
fn bindgen_test_layout_MMAL_POOL_T() {
    assert_eq!(
        ::std::mem::size_of::<MMAL_POOL_T>(),
        12usize,
        concat!("Size of: ", stringify!(MMAL_POOL_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_POOL_T>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_POOL_T))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_POOL_T>())).queue as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_POOL_T),
            "::",
            stringify!(queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_POOL_T>())).headers_num as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_POOL_T),
            "::",
            stringify!(headers_num)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_POOL_T>())).header as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_POOL_T),
            "::",
            stringify!(header)
        )
    );
}
#[doc = " Allocator alloc prototype"]
#[doc = ""]
#[doc = " @param context The context pointer passed in on pool creation."]
#[doc = " @param size    The size of the allocation required, in bytes."]
#[doc = " @return The pointer to the newly allocated memory, or NULL on failure."]
pub type mmal_pool_allocator_alloc_t = ::std::option::Option<
    unsafe extern "C" fn(
        context: *mut ::std::os::raw::c_void,
        size: u32,
    ) -> *mut ::std::os::raw::c_void,
>;
#[doc = " Allocator free prototype"]
#[doc = ""]
#[doc = " @param context The context pointer passed in on pool creation."]
#[doc = " @param mem     The pointer to the memory to be released."]
pub type mmal_pool_allocator_free_t = ::std::option::Option<
    unsafe extern "C" fn(context: *mut ::std::os::raw::c_void, mem: *mut ::std::os::raw::c_void),
>;
extern "C" {
    #[doc = " Create a pool of MMAL_BUFFER_HEADER_T."]
    #[doc = " After allocation, all allocated buffer headers will have been added to the queue."]
    #[doc = ""]
    #[doc = " It is valid to create a pool with no buffer headers, or with zero size payload buffers."]
    #[doc = " The mmal_pool_resize() function can be used to increase or decrease the number of buffer"]
    #[doc = " headers, or the size of the payload buffers, after creation of the pool."]
    #[doc = ""]
    #[doc = " The payload buffers may also be allocated independently by the client, and assigned"]
    #[doc = " to the buffer headers, but it will be the responsibility of the client to deal with"]
    #[doc = " resizing and releasing the memory. It is recommended that mmal_pool_create_with_allocator()"]
    #[doc = " is used in this case, supplying allocator function pointers that will be used as"]
    #[doc = " necessary by MMAL."]
    #[doc = ""]
    #[doc = " @param headers      Number of buffer headers to be allocated with the pool."]
    #[doc = " @param payload_size Size of the payload buffer that will be allocated in"]
    #[doc = "                     each of the buffer headers."]
    #[doc = " @return Pointer to the newly created pool or NULL on failure."]
    pub fn mmal_pool_create(headers: ::std::os::raw::c_uint, payload_size: u32)
        -> *mut MMAL_POOL_T;
}
extern "C" {
    #[doc = " Create a pool of MMAL_BUFFER_HEADER_T."]
    #[doc = " After allocation, all allocated buffer headers will have been added to the queue."]
    #[doc = ""]
    #[doc = " It is valid to create a pool with no buffer headers, or with zero size payload buffers."]
    #[doc = " The mmal_pool_resize() function can be used to increase or decrease the number of buffer"]
    #[doc = " headers, or the size of the payload buffers, after creation of the pool. The allocators"]
    #[doc = " passed during creation shall be used when resizing the payload buffers."]
    #[doc = ""]
    #[doc = " @param headers      Number of buffer headers to be allocated with the pool."]
    #[doc = " @param payload_size Size of the payload buffer that will be allocated in"]
    #[doc = "                     each of the buffer headers."]
    #[doc = " @param allocator_context Pointer to the context of the allocator."]
    #[doc = " @param allocator_alloc   Function pointer for the alloc call of the allocator."]
    #[doc = " @param allocator_free    Function pointer for the free call of the allocator."]
    #[doc = ""]
    #[doc = " @return Pointer to the newly created pool or NULL on failure."]
    pub fn mmal_pool_create_with_allocator(
        headers: ::std::os::raw::c_uint,
        payload_size: u32,
        allocator_context: *mut ::std::os::raw::c_void,
        allocator_alloc: mmal_pool_allocator_alloc_t,
        allocator_free: mmal_pool_allocator_free_t,
    ) -> *mut MMAL_POOL_T;
}
extern "C" {
    #[doc = " Destroy a pool of MMAL_BUFFER_HEADER_T."]
    #[doc = " This will also deallocate all of the memory which was allocated when creating or"]
    #[doc = " resizing the pool."]
    #[doc = ""]
    #[doc = " If payload buffers have been allocated independently by the client, they should be"]
    #[doc = " released prior to calling this function. If the client provided allocator functions,"]
    #[doc = " the allocator_free function shall be called for each payload buffer."]
    #[doc = ""]
    #[doc = " @param pool  Pointer to a pool"]
    pub fn mmal_pool_destroy(pool: *mut MMAL_POOL_T);
}
extern "C" {
    #[doc = " Resize a pool of MMAL_BUFFER_HEADER_T."]
    #[doc = " This allows modifying either the number of allocated buffers, the payload size or both at the"]
    #[doc = " same time."]
    #[doc = ""]
    #[doc = " @param pool         Pointer to the pool"]
    #[doc = " @param headers      New number of buffer headers to be allocated in the pool."]
    #[doc = "                     It is not valid to pass zero for the number of buffers."]
    #[doc = " @param payload_size Size of the payload buffer that will be allocated in"]
    #[doc = "                     each of the buffer headers."]
    #[doc = "                     If this is set to 0, all payload buffers shall be released."]
    #[doc = " @return MMAL_SUCCESS or an error on failure."]
    pub fn mmal_pool_resize(
        pool: *mut MMAL_POOL_T,
        headers: ::std::os::raw::c_uint,
        payload_size: u32,
    ) -> MMAL_STATUS_T::Type;
}
#[doc = " Definition of the callback used by a pool to signal back to the user that a buffer header"]
#[doc = " has been released back to the pool."]
#[doc = ""]
#[doc = " @param pool       Pointer to the pool"]
#[doc = " @param buffer     Buffer header just released"]
#[doc = " @param userdata   User specific data passed in when setting the callback"]
#[doc = " @return True to have the buffer header put back in the pool's queue, false if the buffer"]
#[doc = "          header has been taken within the callback."]
pub type MMAL_POOL_BH_CB_T = ::std::option::Option<
    unsafe extern "C" fn(
        pool: *mut MMAL_POOL_T,
        buffer: *mut MMAL_BUFFER_HEADER_T,
        userdata: *mut ::std::os::raw::c_void,
    ) -> MMAL_BOOL_T,
>;
extern "C" {
    #[doc = " Set a buffer header release callback to the pool."]
    #[doc = " Each time a buffer header is released to the pool, the callback will be triggered."]
    #[doc = ""]
    #[doc = " @param pool     Pointer to a pool"]
    #[doc = " @param cb       Callback function"]
    #[doc = " @param userdata User specific data which will be passed with each callback"]
    pub fn mmal_pool_callback_set(
        pool: *mut MMAL_POOL_T,
        cb: MMAL_POOL_BH_CB_T,
        userdata: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Set a pre-release callback for all buffer headers in the pool."]
    #[doc = " Each time a buffer header is about to be released to the pool, the callback"]
    #[doc = " will be triggered."]
    #[doc = ""]
    #[doc = " @param pool     Pointer to the pool"]
    #[doc = " @param cb       Pre-release callback function"]
    #[doc = " @param userdata User-specific data passed back with each callback"]
    pub fn mmal_pool_pre_release_callback_set(
        pool: *mut MMAL_POOL_T,
        cb: MMAL_BH_PRE_RELEASE_CB_T,
        userdata: *mut ::std::os::raw::c_void,
    );
}
#[doc = " End-of-stream event."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_EVENT_END_OF_STREAM_T {
    #[doc = "< Type of port that received the end of stream"]
    pub port_type: MMAL_PORT_TYPE_T,
    #[doc = "< Index of port that received the end of stream"]
    pub port_index: u32,
}
#[test]
fn bindgen_test_layout_MMAL_EVENT_END_OF_STREAM_T() {
    assert_eq!(
        ::std::mem::size_of::<MMAL_EVENT_END_OF_STREAM_T>(),
        8usize,
        concat!("Size of: ", stringify!(MMAL_EVENT_END_OF_STREAM_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_EVENT_END_OF_STREAM_T>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_EVENT_END_OF_STREAM_T))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_EVENT_END_OF_STREAM_T>())).port_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_EVENT_END_OF_STREAM_T),
            "::",
            stringify!(port_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_EVENT_END_OF_STREAM_T>())).port_index as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_EVENT_END_OF_STREAM_T),
            "::",
            stringify!(port_index)
        )
    );
}
#[doc = " Format changed event data."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_EVENT_FORMAT_CHANGED_T {
    #[doc = "< Minimum size of buffers the port requires"]
    pub buffer_size_min: u32,
    #[doc = "< Minimum number of buffers the port requires"]
    pub buffer_num_min: u32,
    #[doc = "< Size of buffers the port recommends for optimal performance."]
    #[doc = "A value of zero means no special recommendation."]
    pub buffer_size_recommended: u32,
    #[doc = "< Number of buffers the port recommends for optimal"]
    #[doc = "performance. A value of zero means no special recommendation."]
    pub buffer_num_recommended: u32,
    #[doc = "< New elementary stream format"]
    pub format: *mut MMAL_ES_FORMAT_T,
}
#[test]
fn bindgen_test_layout_MMAL_EVENT_FORMAT_CHANGED_T() {
    assert_eq!(
        ::std::mem::size_of::<MMAL_EVENT_FORMAT_CHANGED_T>(),
        20usize,
        concat!("Size of: ", stringify!(MMAL_EVENT_FORMAT_CHANGED_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_EVENT_FORMAT_CHANGED_T>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_EVENT_FORMAT_CHANGED_T))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_EVENT_FORMAT_CHANGED_T>())).buffer_size_min as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_EVENT_FORMAT_CHANGED_T),
            "::",
            stringify!(buffer_size_min)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_EVENT_FORMAT_CHANGED_T>())).buffer_num_min as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_EVENT_FORMAT_CHANGED_T),
            "::",
            stringify!(buffer_num_min)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_EVENT_FORMAT_CHANGED_T>())).buffer_size_recommended
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_EVENT_FORMAT_CHANGED_T),
            "::",
            stringify!(buffer_size_recommended)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_EVENT_FORMAT_CHANGED_T>())).buffer_num_recommended
                as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_EVENT_FORMAT_CHANGED_T),
            "::",
            stringify!(buffer_num_recommended)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_EVENT_FORMAT_CHANGED_T>())).format as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_EVENT_FORMAT_CHANGED_T),
            "::",
            stringify!(format)
        )
    );
}
#[doc = " Parameter changed event data."]
#[doc = " This is a variable sized event. The full parameter is included in the event"]
#[doc = " data, not just the header. Use the \\ref MMAL_PARAMETER_HEADER_T::id field to determine how to"]
#[doc = " cast the structure. The \\ref MMAL_PARAMETER_HEADER_T::size field can be used to check validity."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_EVENT_PARAMETER_CHANGED_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
}
#[test]
fn bindgen_test_layout_MMAL_EVENT_PARAMETER_CHANGED_T() {
    assert_eq!(
        ::std::mem::size_of::<MMAL_EVENT_PARAMETER_CHANGED_T>(),
        8usize,
        concat!("Size of: ", stringify!(MMAL_EVENT_PARAMETER_CHANGED_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_EVENT_PARAMETER_CHANGED_T>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_EVENT_PARAMETER_CHANGED_T))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_EVENT_PARAMETER_CHANGED_T>())).hdr as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_EVENT_PARAMETER_CHANGED_T),
            "::",
            stringify!(hdr)
        )
    );
}
extern "C" {
    #[doc = " Get a pointer to the \\ref MMAL_EVENT_FORMAT_CHANGED_T structure contained in the buffer header."]
    #[doc = " Note that the pointer will point inside the data contained in the buffer header"]
    #[doc = " so doesn't need to be freed explicitly."]
    #[doc = ""]
    #[doc = " @param buffer buffer header containing the MMAL_EVENT_FORMAT_CHANGED event."]
    #[doc = " @return pointer to a MMAL_EVENT_FORMAT_CHANGED_T structure."]
    pub fn mmal_event_format_changed_get(
        buffer: *mut MMAL_BUFFER_HEADER_T,
    ) -> *mut MMAL_EVENT_FORMAT_CHANGED_T;
}
#[doc = " Definition of the callback used by a connection to signal back to the client"]
#[doc = " that a buffer header is available either in the pool or in the output queue."]
#[doc = ""]
#[doc = " @param connection Pointer to the connection"]
pub type MMAL_CONNECTION_CALLBACK_T =
    ::std::option::Option<unsafe extern "C" fn(connection: *mut MMAL_CONNECTION_T)>;
#[doc = " Structure describing a connection between 2 ports (1 output and 1 input port)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_CONNECTION_T {
    #[doc = "< Field reserved for use by the client."]
    pub user_data: *mut ::std::os::raw::c_void,
    #[doc = "< Callback set by the client."]
    pub callback: MMAL_CONNECTION_CALLBACK_T,
    #[doc = "< Specifies whether the connection is enabled or not (Read Only)."]
    pub is_enabled: u32,
    #[doc = "< Flags passed during the create call (Read Only). A bitwise"]
    #[doc = " combination of \\ref connectionflags \"Connection flags\" values."]
    pub flags: u32,
    #[doc = "< Input port used for the connection (Read Only)."]
    pub in_: *mut MMAL_PORT_T,
    #[doc = "< Output port used for the connection (Read Only)."]
    pub out: *mut MMAL_PORT_T,
    #[doc = "< Pool of buffer headers used by the output port (Read Only)."]
    pub pool: *mut MMAL_POOL_T,
    #[doc = "< Queue for the buffer headers produced by the output port (Read Only)."]
    pub queue: *mut MMAL_QUEUE_T,
    #[doc = "< Connection name (Read Only). Used for debugging purposes."]
    pub name: *const ::std::os::raw::c_char,
    #[doc = "< Time in microseconds taken to setup the connection."]
    pub time_setup: i64,
    #[doc = "< Time in microseconds taken to enable the connection."]
    pub time_enable: i64,
    #[doc = "< Time in microseconds taken to disable the connection."]
    pub time_disable: i64,
}
#[test]
fn bindgen_test_layout_MMAL_CONNECTION_T() {
    assert_eq!(
        ::std::mem::size_of::<MMAL_CONNECTION_T>(),
        64usize,
        concat!("Size of: ", stringify!(MMAL_CONNECTION_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_CONNECTION_T>(),
        8usize,
        concat!("Alignment of ", stringify!(MMAL_CONNECTION_T))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_CONNECTION_T>())).user_data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_CONNECTION_T),
            "::",
            stringify!(user_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_CONNECTION_T>())).callback as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_CONNECTION_T),
            "::",
            stringify!(callback)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_CONNECTION_T>())).is_enabled as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_CONNECTION_T),
            "::",
            stringify!(is_enabled)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_CONNECTION_T>())).flags as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_CONNECTION_T),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_CONNECTION_T>())).in_ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_CONNECTION_T),
            "::",
            stringify!(in_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_CONNECTION_T>())).out as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_CONNECTION_T),
            "::",
            stringify!(out)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_CONNECTION_T>())).pool as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_CONNECTION_T),
            "::",
            stringify!(pool)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_CONNECTION_T>())).queue as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_CONNECTION_T),
            "::",
            stringify!(queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_CONNECTION_T>())).name as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_CONNECTION_T),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_CONNECTION_T>())).time_setup as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_CONNECTION_T),
            "::",
            stringify!(time_setup)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_CONNECTION_T>())).time_enable as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_CONNECTION_T),
            "::",
            stringify!(time_enable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_CONNECTION_T>())).time_disable as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_CONNECTION_T),
            "::",
            stringify!(time_disable)
        )
    );
}
extern "C" {
    #[doc = " Create a connection between two ports."]
    #[doc = " The connection shall include a pool of buffer headers suitable for the current format of"]
    #[doc = " the output port. The format of the input port shall have been set to the same as that of"]
    #[doc = " the input port."]
    #[doc = " Note that connections are reference counted and creating a connection automatically"]
    #[doc = " acquires a reference to it (released when \\ref mmal_connection_destroy is called)."]
    #[doc = ""]
    #[doc = " @param connection The address of a connection pointer that will be set to point to the created"]
    #[doc = " connection."]
    #[doc = " @param out        The output port to use for the connection."]
    #[doc = " @param in         The input port to use for the connection."]
    #[doc = " @param flags      The flags specifying which type of connection should be created."]
    #[doc = "    A bitwise combination of \\ref connectionflags \"Connection flags\" values."]
    #[doc = " @return MMAL_SUCCESS on success."]
    pub fn mmal_connection_create(
        connection: *mut *mut MMAL_CONNECTION_T,
        out: *mut MMAL_PORT_T,
        in_: *mut MMAL_PORT_T,
        flags: u32,
    ) -> MMAL_STATUS_T::Type;
}
extern "C" {
    #[doc = " Acquire a reference on a connection."]
    #[doc = " Acquiring a reference on a connection will prevent a connection from being destroyed until"]
    #[doc = " the acquired reference is released (by a call to \\ref mmal_connection_destroy)."]
    #[doc = " References are internally counted so all acquired references need a matching call to"]
    #[doc = " release them."]
    #[doc = ""]
    #[doc = " @param connection connection to acquire"]
    pub fn mmal_connection_acquire(connection: *mut MMAL_CONNECTION_T);
}
extern "C" {
    #[doc = " Release a reference on a connection"]
    #[doc = " Release an acquired reference on a connection. Triggers the destruction of the connection when"]
    #[doc = " the last reference is being released."]
    #[doc = " \\note This is in fact an alias of \\ref mmal_connection_destroy which is added to make client"]
    #[doc = " code clearer."]
    #[doc = ""]
    #[doc = " @param connection connection to release"]
    #[doc = " @return MMAL_SUCCESS on success"]
    pub fn mmal_connection_release(connection: *mut MMAL_CONNECTION_T) -> MMAL_STATUS_T::Type;
}
extern "C" {
    #[doc = " Destroy a connection."]
    #[doc = " Release an acquired reference on a connection. Only actually destroys the connection when"]
    #[doc = " the last reference is being released."]
    #[doc = " The actual destruction of the connection will start by disabling it, if necessary."]
    #[doc = " Any pool, queue, and so on owned by the connection shall then be destroyed."]
    #[doc = ""]
    #[doc = " @param connection The connection to be destroyed."]
    #[doc = " @return MMAL_SUCCESS on success."]
    pub fn mmal_connection_destroy(connection: *mut MMAL_CONNECTION_T) -> MMAL_STATUS_T::Type;
}
extern "C" {
    #[doc = " Enable a connection."]
    #[doc = " The format of the two ports must have been committed before calling this function,"]
    #[doc = " although note that on creation, the connection automatically copies and commits the"]
    #[doc = " output port's format to the input port."]
    #[doc = ""]
    #[doc = " The MMAL_CONNECTION_T::callback field must have been set if the \\ref MMAL_CONNECTION_FLAG_TUNNELLING"]
    #[doc = " flag was not specified on creation. The client may also set the MMAL_CONNECTION_T::user_data"]
    #[doc = " in order to get a pointer passed, via the connection, to the callback."]
    #[doc = ""]
    #[doc = " @param connection The connection to be enabled."]
    #[doc = " @return MMAL_SUCCESS on success."]
    pub fn mmal_connection_enable(connection: *mut MMAL_CONNECTION_T) -> MMAL_STATUS_T::Type;
}
extern "C" {
    #[doc = " Disable a connection."]
    #[doc = ""]
    #[doc = " @param connection The connection to be disabled."]
    #[doc = " @return MMAL_SUCCESS on success."]
    pub fn mmal_connection_disable(connection: *mut MMAL_CONNECTION_T) -> MMAL_STATUS_T::Type;
}
extern "C" {
    #[doc = " Apply a format changed event to the connection."]
    #[doc = " This function can be used when the client is processing buffer headers and receives"]
    #[doc = " a format changed event (\\ref MMAL_EVENT_FORMAT_CHANGED). The connection is"]
    #[doc = " reconfigured, changing the format of the ports, the number of buffer headers and"]
    #[doc = " the size of the payload buffers as necessary."]
    #[doc = ""]
    #[doc = " @param connection The connection to which the event shall be applied."]
    #[doc = " @param buffer The buffer containing a format changed event."]
    #[doc = " @return MMAL_SUCCESS on success."]
    pub fn mmal_connection_event_format_changed(
        connection: *mut MMAL_CONNECTION_T,
        buffer: *mut MMAL_BUFFER_HEADER_T,
    ) -> MMAL_STATUS_T::Type;
}
extern "C" {
    #[doc = " Convert a status to a statically-allocated string."]
    #[doc = ""]
    #[doc = " @param status The MMAL status code."]
    #[doc = " @return A C string describing the status code."]
    pub fn mmal_status_to_string(status: MMAL_STATUS_T::Type) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Convert stride to pixel width for a given pixel encoding."]
    #[doc = ""]
    #[doc = " @param encoding The pixel encoding (such as one of the \\ref MmalEncodings \"pre-defined encodings\")"]
    #[doc = " @param stride The stride in bytes."]
    #[doc = " @return The width in pixels."]
    pub fn mmal_encoding_stride_to_width(encoding: u32, stride: u32) -> u32;
}
extern "C" {
    #[doc = " Convert pixel width to stride for a given pixel encoding"]
    #[doc = ""]
    #[doc = " @param encoding The pixel encoding (such as one of the \\ref MmalEncodings \"pre-defined encodings\")"]
    #[doc = " @param width The width in pixels."]
    #[doc = " @return The stride in bytes."]
    pub fn mmal_encoding_width_to_stride(encoding: u32, width: u32) -> u32;
}
extern "C" {
    #[doc = " Return the 16 line high sliced version of a given pixel encoding"]
    #[doc = ""]
    #[doc = " @param encoding The pixel encoding (such as one of the \\ref MmalEncodings \"pre-defined encodings\")"]
    #[doc = " @return The sliced equivalent, or MMAL_ENCODING_UNKNOWN if not supported."]
    pub fn mmal_encoding_get_slice_variant(encoding: u32) -> u32;
}
extern "C" {
    #[doc = " Convert a port type to a string."]
    #[doc = ""]
    #[doc = " @param type The MMAL port type."]
    #[doc = " @return A NULL-terminated string describing the port type."]
    pub fn mmal_port_type_to_string(type_: MMAL_PORT_TYPE_T) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get a parameter from a port allocating the required amount of memory"]
    #[doc = " for the parameter (i.e. for variable length parameters like URI or arrays)."]
    #[doc = " The size field will be set on output to the actual size of the"]
    #[doc = " parameter allocated and retrieved."]
    #[doc = ""]
    #[doc = " The pointer returned must be released by a call to \\ref mmal_port_parameter_free()."]
    #[doc = ""]
    #[doc = " @param port port to send request to"]
    #[doc = " @param id parameter id"]
    #[doc = " @param size initial size hint for allocation (can be 0)"]
    #[doc = " @param status status of the parameter get operation (can be 0)"]
    #[doc = " @return pointer to the header of the parameter or NULL on failure."]
    pub fn mmal_port_parameter_alloc_get(
        port: *mut MMAL_PORT_T,
        id: u32,
        size: u32,
        status: *mut MMAL_STATUS_T::Type,
    ) -> *mut MMAL_PARAMETER_HEADER_T;
}
extern "C" {
    #[doc = " Free a parameter structure previously allocated via"]
    #[doc = " \\ref mmal_port_parameter_alloc_get()."]
    #[doc = ""]
    #[doc = " @param param pointer to header of the parameter"]
    pub fn mmal_port_parameter_free(param: *mut MMAL_PARAMETER_HEADER_T);
}
extern "C" {
    #[doc = " Copy buffer header metadata from source to destination."]
    #[doc = ""]
    #[doc = " @param dest The destination buffer header."]
    #[doc = " @param src  The source buffer header."]
    pub fn mmal_buffer_header_copy_header(
        dest: *mut MMAL_BUFFER_HEADER_T,
        src: *const MMAL_BUFFER_HEADER_T,
    );
}
extern "C" {
    #[doc = " Create a pool of MMAL_BUFFER_HEADER_T associated with a specific port."]
    #[doc = " This allows a client to allocate memory for the payload buffers based on the preferences"]
    #[doc = " of a port. This for instance will allow the port to allocate memory which can be shared"]
    #[doc = " between the host processor and videocore."]
    #[doc = " After allocation, all allocated buffer headers will have been added to the queue."]
    #[doc = ""]
    #[doc = " It is valid to create a pool with no buffer headers, or with zero size payload buffers."]
    #[doc = " The mmal_pool_resize() function can be used to increase or decrease the number of buffer"]
    #[doc = " headers, or the size of the payload buffers, after creation of the pool."]
    #[doc = ""]
    #[doc = " @param port         Port responsible for creating the pool."]
    #[doc = " @param headers      Number of buffers which will be allocated with the pool."]
    #[doc = " @param payload_size Size of the payload buffer which will be allocated in"]
    #[doc = "                     each of the buffer headers."]
    #[doc = " @return Pointer to the newly created pool or NULL on failure."]
    pub fn mmal_port_pool_create(
        port: *mut MMAL_PORT_T,
        headers: ::std::os::raw::c_uint,
        payload_size: u32,
    ) -> *mut MMAL_POOL_T;
}
extern "C" {
    #[doc = " Destroy a pool of MMAL_BUFFER_HEADER_T associated with a specific port."]
    #[doc = " This will also deallocate all of the memory which was allocated when creating or"]
    #[doc = " resizing the pool."]
    #[doc = ""]
    #[doc = " @param port  Pointer to the port responsible for creating the pool."]
    #[doc = " @param pool  Pointer to the pool to be destroyed."]
    pub fn mmal_port_pool_destroy(port: *mut MMAL_PORT_T, pool: *mut MMAL_POOL_T);
}
extern "C" {
    #[doc = " Log the content of a \\ref MMAL_PORT_T structure."]
    #[doc = ""]
    #[doc = " @param port  Pointer to the port to dump."]
    pub fn mmal_log_dump_port(port: *mut MMAL_PORT_T);
}
extern "C" {
    #[doc = " Log the content of a \\ref MMAL_ES_FORMAT_T structure."]
    #[doc = ""]
    #[doc = " @param format  Pointer to the format to dump."]
    pub fn mmal_log_dump_format(format: *mut MMAL_ES_FORMAT_T);
}
extern "C" {
    #[doc = " Return the nth port."]
    #[doc = ""]
    #[doc = " @param comp   component to query"]
    #[doc = " @param index  port index"]
    #[doc = " @param type   port type"]
    #[doc = ""]
    #[doc = " @return port or NULL if not found"]
    pub fn mmal_util_get_port(
        comp: *mut MMAL_COMPONENT_T,
        type_: MMAL_PORT_TYPE_T,
        index: ::std::os::raw::c_uint,
    ) -> *mut MMAL_PORT_T;
}
extern "C" {
    #[doc = " Convert a 4cc into a string."]
    #[doc = ""]
    #[doc = " @param buf    Destination for result"]
    #[doc = " @param len    Size of result buffer"]
    #[doc = " @param fourcc 4cc to be converted"]
    #[doc = " @return converted string (buf)"]
    #[doc = ""]
    pub fn mmal_4cc_to_string(
        buf: *mut ::std::os::raw::c_char,
        len: usize,
        fourcc: u32,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " On FW prior to June 2016, camera and video_splitter"]
    #[doc = "  had BGR24 and RGB24 support reversed."]
    #[doc = "  This is now fixed, and this function will return whether the"]
    #[doc = "  FW has the fix or not."]
    #[doc = ""]
    #[doc = " @param port   MMAL port to check (on camera or video_splitter)"]
    #[doc = " @return 0 if old firmware, 1 if new."]
    #[doc = ""]
    pub fn mmal_util_rgb_order_fixed(port: *mut MMAL_PORT_T) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Helper function to set the value of a boolean parameter."]
    #[doc = " @param port   port on which to set the parameter"]
    #[doc = " @param id     parameter id"]
    #[doc = " @param value  value to set the parameter to"]
    #[doc = ""]
    #[doc = " @return MMAL_SUCCESS or error"]
    pub fn mmal_port_parameter_set_boolean(
        port: *mut MMAL_PORT_T,
        id: u32,
        value: MMAL_BOOL_T,
    ) -> MMAL_STATUS_T::Type;
}
extern "C" {
    #[doc = " Helper function to get the value of a boolean parameter."]
    #[doc = " @param port   port on which to get the parameter"]
    #[doc = " @param id     parameter id"]
    #[doc = " @param value  pointer to where the value will be returned"]
    #[doc = ""]
    #[doc = " @return MMAL_SUCCESS or error"]
    pub fn mmal_port_parameter_get_boolean(
        port: *mut MMAL_PORT_T,
        id: u32,
        value: *mut MMAL_BOOL_T,
    ) -> MMAL_STATUS_T::Type;
}
extern "C" {
    #[doc = " Helper function to set the value of a 64 bits unsigned integer parameter."]
    #[doc = " @param port   port on which to set the parameter"]
    #[doc = " @param id     parameter id"]
    #[doc = " @param value  value to set the parameter to"]
    #[doc = ""]
    #[doc = " @return MMAL_SUCCESS or error"]
    pub fn mmal_port_parameter_set_uint64(
        port: *mut MMAL_PORT_T,
        id: u32,
        value: u64,
    ) -> MMAL_STATUS_T::Type;
}
extern "C" {
    #[doc = " Helper function to get the value of a 64 bits unsigned integer parameter."]
    #[doc = " @param port   port on which to get the parameter"]
    #[doc = " @param id     parameter id"]
    #[doc = " @param value  pointer to where the value will be returned"]
    #[doc = ""]
    #[doc = " @return MMAL_SUCCESS or error"]
    pub fn mmal_port_parameter_get_uint64(
        port: *mut MMAL_PORT_T,
        id: u32,
        value: *mut u64,
    ) -> MMAL_STATUS_T::Type;
}
extern "C" {
    #[doc = " Helper function to set the value of a 64 bits signed integer parameter."]
    #[doc = " @param port   port on which to set the parameter"]
    #[doc = " @param id     parameter id"]
    #[doc = " @param value  value to set the parameter to"]
    #[doc = ""]
    #[doc = " @return MMAL_SUCCESS or error"]
    pub fn mmal_port_parameter_set_int64(
        port: *mut MMAL_PORT_T,
        id: u32,
        value: i64,
    ) -> MMAL_STATUS_T::Type;
}
extern "C" {
    #[doc = " Helper function to get the value of a 64 bits signed integer parameter."]
    #[doc = " @param port   port on which to get the parameter"]
    #[doc = " @param id     parameter id"]
    #[doc = " @param value  pointer to where the value will be returned"]
    #[doc = ""]
    #[doc = " @return MMAL_SUCCESS or error"]
    pub fn mmal_port_parameter_get_int64(
        port: *mut MMAL_PORT_T,
        id: u32,
        value: *mut i64,
    ) -> MMAL_STATUS_T::Type;
}
extern "C" {
    #[doc = " Helper function to set the value of a 32 bits unsigned integer parameter."]
    #[doc = " @param port   port on which to set the parameter"]
    #[doc = " @param id     parameter id"]
    #[doc = " @param value  value to set the parameter to"]
    #[doc = ""]
    #[doc = " @return MMAL_SUCCESS or error"]
    pub fn mmal_port_parameter_set_uint32(
        port: *mut MMAL_PORT_T,
        id: u32,
        value: u32,
    ) -> MMAL_STATUS_T::Type;
}
extern "C" {
    #[doc = " Helper function to get the value of a 32 bits unsigned integer parameter."]
    #[doc = " @param port   port on which to get the parameter"]
    #[doc = " @param id     parameter id"]
    #[doc = " @param value  pointer to where the value will be returned"]
    #[doc = ""]
    #[doc = " @return MMAL_SUCCESS or error"]
    pub fn mmal_port_parameter_get_uint32(
        port: *mut MMAL_PORT_T,
        id: u32,
        value: *mut u32,
    ) -> MMAL_STATUS_T::Type;
}
extern "C" {
    #[doc = " Helper function to set the value of a 32 bits signed integer parameter."]
    #[doc = " @param port   port on which to set the parameter"]
    #[doc = " @param id     parameter id"]
    #[doc = " @param value  value to set the parameter to"]
    #[doc = ""]
    #[doc = " @return MMAL_SUCCESS or error"]
    pub fn mmal_port_parameter_set_int32(
        port: *mut MMAL_PORT_T,
        id: u32,
        value: i32,
    ) -> MMAL_STATUS_T::Type;
}
extern "C" {
    #[doc = " Helper function to get the value of a 32 bits signed integer parameter."]
    #[doc = " @param port   port on which to get the parameter"]
    #[doc = " @param id     parameter id"]
    #[doc = " @param value  pointer to where the value will be returned"]
    #[doc = ""]
    #[doc = " @return MMAL_SUCCESS or error"]
    pub fn mmal_port_parameter_get_int32(
        port: *mut MMAL_PORT_T,
        id: u32,
        value: *mut i32,
    ) -> MMAL_STATUS_T::Type;
}
extern "C" {
    #[doc = " Helper function to set the value of a rational parameter."]
    #[doc = " @param port   port on which to set the parameter"]
    #[doc = " @param id     parameter id"]
    #[doc = " @param value  value to set the parameter to"]
    #[doc = ""]
    #[doc = " @return MMAL_SUCCESS or error"]
    pub fn mmal_port_parameter_set_rational(
        port: *mut MMAL_PORT_T,
        id: u32,
        value: MMAL_RATIONAL_T,
    ) -> MMAL_STATUS_T::Type;
}
extern "C" {
    #[doc = " Helper function to get the value of a rational parameter."]
    #[doc = " @param port   port on which to get the parameter"]
    #[doc = " @param id     parameter id"]
    #[doc = " @param value  pointer to where the value will be returned"]
    #[doc = ""]
    #[doc = " @return MMAL_SUCCESS or error"]
    pub fn mmal_port_parameter_get_rational(
        port: *mut MMAL_PORT_T,
        id: u32,
        value: *mut MMAL_RATIONAL_T,
    ) -> MMAL_STATUS_T::Type;
}
extern "C" {
    #[doc = " Helper function to set the value of a string parameter."]
    #[doc = " @param port   port on which to set the parameter"]
    #[doc = " @param id     parameter id"]
    #[doc = " @param value  null-terminated string value"]
    #[doc = ""]
    #[doc = " @return MMAL_SUCCESS or error"]
    pub fn mmal_port_parameter_set_string(
        port: *mut MMAL_PORT_T,
        id: u32,
        value: *const ::std::os::raw::c_char,
    ) -> MMAL_STATUS_T::Type;
}
extern "C" {
    #[doc = " Helper function to set the value of an array of bytes parameter."]
    #[doc = " @param port   port on which to set the parameter"]
    #[doc = " @param id     parameter id"]
    #[doc = " @param data   pointer to the array of bytes"]
    #[doc = " @param size   size of the array of bytes"]
    #[doc = ""]
    #[doc = " @return MMAL_SUCCESS or error"]
    pub fn mmal_port_parameter_set_bytes(
        port: *mut MMAL_PORT_T,
        id: u32,
        data: *const u8,
        size: ::std::os::raw::c_uint,
    ) -> MMAL_STATUS_T::Type;
}
extern "C" {
    #[doc = " Helper function to set a MMAL_PARAMETER_URI_T parameter on a port."]
    #[doc = " @param port   port on which to set the parameter"]
    #[doc = " @param uri    URI string"]
    #[doc = ""]
    #[doc = " @return MMAL_SUCCESS or error"]
    pub fn mmal_util_port_set_uri(
        port: *mut MMAL_PORT_T,
        uri: *const ::std::os::raw::c_char,
    ) -> MMAL_STATUS_T::Type;
}
extern "C" {
    #[doc = " Set the display region."]
    #[doc = " @param port   port to configure"]
    #[doc = " @param region region"]
    #[doc = ""]
    #[doc = " @return MMAL_SUCCESS or error"]
    pub fn mmal_util_set_display_region(
        port: *mut MMAL_PORT_T,
        region: *mut MMAL_DISPLAYREGION_T,
    ) -> MMAL_STATUS_T::Type;
}
extern "C" {
    #[doc = " Tell the camera to use the STC for timestamps rather than the clock."]
    #[doc = ""]
    #[doc = " @param port   port to configure"]
    #[doc = " @param mode   STC mode to use"]
    #[doc = " @return MMAL_SUCCESS or error"]
    pub fn mmal_util_camera_use_stc_timestamp(
        port: *mut MMAL_PORT_T,
        mode: MMAL_CAMERA_STC_MODE_T,
    ) -> MMAL_STATUS_T::Type;
}
extern "C" {
    #[doc = " Get the MMAL core statistics for a given port."]
    #[doc = ""]
    #[doc = " @param port  port to query"]
    #[doc = " @param dir   port direction"]
    #[doc = " @param reset reset the stats as well"]
    #[doc = " @param stats filled in with results"]
    #[doc = " @return MMAL_SUCCESS or error"]
    pub fn mmal_util_get_core_port_stats(
        port: *mut MMAL_PORT_T,
        dir: MMAL_CORE_STATS_DIR,
        reset: MMAL_BOOL_T,
        stats: *mut MMAL_CORE_STATISTICS_T,
    ) -> MMAL_STATUS_T::Type;
}
extern "C" {
    pub fn bcm_host_init();
}
extern "C" {
    pub fn bcm_host_deinit();
}
extern "C" {
    pub fn bcm_host_get_peripheral_address() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn bcm_host_get_peripheral_size() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn bcm_host_get_sdram_address() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn bcm_host_get_model_type() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bcm_host_is_model_pi4() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bcm_host_is_fkms_active() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bcm_host_is_kms_active() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bcm_host_get_processor_id() -> ::std::os::raw::c_int;
}
pub const MMAL_STATS_COMP_STATE_T_MMAL_STATS_COMP_IDLE: MMAL_STATS_COMP_STATE_T = 0;
pub const MMAL_STATS_COMP_STATE_T_MMAL_STATS_COMP_CREATED: MMAL_STATS_COMP_STATE_T = 1;
pub const MMAL_STATS_COMP_STATE_T_MMAL_STATS_COMP_DESTROYING: MMAL_STATS_COMP_STATE_T = 2;
pub const MMAL_STATS_COMP_STATE_T_MMAL_STATS_COMP_DESTROYED: MMAL_STATS_COMP_STATE_T = 3;
pub const MMAL_STATS_COMP_STATE_T_MMAL_STATS_COMP_UNUSED: MMAL_STATS_COMP_STATE_T = 4294967295;
#[doc = " State of components created by the VC adaptation layer, used for"]
#[doc = " statistics reporting."]
pub type MMAL_STATS_COMP_STATE_T = u32;
#[doc = " Per-component statistics collected by the VC adaptation layer."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_VC_COMP_STATS_T {
    pub comp: *mut MMAL_DRIVER_COMPONENT_T,
    pub state: MMAL_STATS_COMP_STATE_T,
    pub pid: u32,
    pub pool_mem_alloc_size: u32,
    pub name: [::std::os::raw::c_char; 20usize],
}
#[test]
fn bindgen_test_layout_MMAL_VC_COMP_STATS_T() {
    assert_eq!(
        ::std::mem::size_of::<MMAL_VC_COMP_STATS_T>(),
        36usize,
        concat!("Size of: ", stringify!(MMAL_VC_COMP_STATS_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_VC_COMP_STATS_T>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_VC_COMP_STATS_T))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_VC_COMP_STATS_T>())).comp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_VC_COMP_STATS_T),
            "::",
            stringify!(comp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_VC_COMP_STATS_T>())).state as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_VC_COMP_STATS_T),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_VC_COMP_STATS_T>())).pid as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_VC_COMP_STATS_T),
            "::",
            stringify!(pid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_VC_COMP_STATS_T>())).pool_mem_alloc_size as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_VC_COMP_STATS_T),
            "::",
            stringify!(pool_mem_alloc_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_VC_COMP_STATS_T>())).name as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_VC_COMP_STATS_T),
            "::",
            stringify!(name)
        )
    );
}
#[doc = " VC adaptation layer statistics."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_VC_STATS_T {
    pub buffers: MMAL_VC_STATS_T__bindgen_ty_1,
    pub service: MMAL_VC_STATS_T_service,
    pub commands: MMAL_VC_STATS_T_commands,
    pub events: MMAL_VC_STATS_T__bindgen_ty_2,
    pub components: MMAL_VC_STATS_T__bindgen_ty_3,
    pub worker: MMAL_VC_STATS_T__bindgen_ty_4,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_VC_STATS_T__bindgen_ty_1 {
    #[doc = "< Count of data buffers received"]
    pub rx: u32,
    #[doc = "< Count of zero-copy data buffers received"]
    pub rx_zero_copy: u32,
    #[doc = "< Empty data buffers (to be filled)"]
    pub rx_empty: u32,
    #[doc = "< Gave up partway through"]
    pub rx_fails: u32,
    #[doc = "< Count of data buffers sent"]
    pub tx: u32,
    #[doc = "< Count of zero-copy data buffers sent"]
    pub tx_zero_copy: u32,
    #[doc = "< Count of empty data buffers sent"]
    pub tx_empty: u32,
    #[doc = "< Gave up partway through"]
    pub tx_fails: u32,
    #[doc = "< Messages sent directly in the control message"]
    pub tx_short_msg: u32,
    #[doc = "< Messages received directly in the control message"]
    pub rx_short_msg: u32,
}
#[test]
fn bindgen_test_layout_MMAL_VC_STATS_T__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<MMAL_VC_STATS_T__bindgen_ty_1>(),
        40usize,
        concat!("Size of: ", stringify!(MMAL_VC_STATS_T__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_VC_STATS_T__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_VC_STATS_T__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_VC_STATS_T__bindgen_ty_1>())).rx as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_VC_STATS_T__bindgen_ty_1),
            "::",
            stringify!(rx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_VC_STATS_T__bindgen_ty_1>())).rx_zero_copy as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_VC_STATS_T__bindgen_ty_1),
            "::",
            stringify!(rx_zero_copy)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_VC_STATS_T__bindgen_ty_1>())).rx_empty as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_VC_STATS_T__bindgen_ty_1),
            "::",
            stringify!(rx_empty)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_VC_STATS_T__bindgen_ty_1>())).rx_fails as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_VC_STATS_T__bindgen_ty_1),
            "::",
            stringify!(rx_fails)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_VC_STATS_T__bindgen_ty_1>())).tx as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_VC_STATS_T__bindgen_ty_1),
            "::",
            stringify!(tx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_VC_STATS_T__bindgen_ty_1>())).tx_zero_copy as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_VC_STATS_T__bindgen_ty_1),
            "::",
            stringify!(tx_zero_copy)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_VC_STATS_T__bindgen_ty_1>())).tx_empty as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_VC_STATS_T__bindgen_ty_1),
            "::",
            stringify!(tx_empty)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_VC_STATS_T__bindgen_ty_1>())).tx_fails as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_VC_STATS_T__bindgen_ty_1),
            "::",
            stringify!(tx_fails)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_VC_STATS_T__bindgen_ty_1>())).tx_short_msg as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_VC_STATS_T__bindgen_ty_1),
            "::",
            stringify!(tx_short_msg)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_VC_STATS_T__bindgen_ty_1>())).rx_short_msg as *const _
                as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_VC_STATS_T__bindgen_ty_1),
            "::",
            stringify!(rx_short_msg)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_VC_STATS_T_service {
    #[doc = "< How many services created"]
    pub created: u32,
    #[doc = "< How many destroyed"]
    pub pending_destroy: u32,
    #[doc = "< How many destroyed"]
    pub destroyed: u32,
    #[doc = "< Failures to create a service"]
    pub failures: u32,
}
#[test]
fn bindgen_test_layout_MMAL_VC_STATS_T_service() {
    assert_eq!(
        ::std::mem::size_of::<MMAL_VC_STATS_T_service>(),
        16usize,
        concat!("Size of: ", stringify!(MMAL_VC_STATS_T_service))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_VC_STATS_T_service>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_VC_STATS_T_service))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_VC_STATS_T_service>())).created as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_VC_STATS_T_service),
            "::",
            stringify!(created)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_VC_STATS_T_service>())).pending_destroy as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_VC_STATS_T_service),
            "::",
            stringify!(pending_destroy)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_VC_STATS_T_service>())).destroyed as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_VC_STATS_T_service),
            "::",
            stringify!(destroyed)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_VC_STATS_T_service>())).failures as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_VC_STATS_T_service),
            "::",
            stringify!(failures)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_VC_STATS_T_commands {
    pub bad_messages: u32,
    pub executed: u32,
    pub failed: u32,
    pub replies: u32,
    pub reply_fails: u32,
}
#[test]
fn bindgen_test_layout_MMAL_VC_STATS_T_commands() {
    assert_eq!(
        ::std::mem::size_of::<MMAL_VC_STATS_T_commands>(),
        20usize,
        concat!("Size of: ", stringify!(MMAL_VC_STATS_T_commands))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_VC_STATS_T_commands>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_VC_STATS_T_commands))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_VC_STATS_T_commands>())).bad_messages as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_VC_STATS_T_commands),
            "::",
            stringify!(bad_messages)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_VC_STATS_T_commands>())).executed as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_VC_STATS_T_commands),
            "::",
            stringify!(executed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_VC_STATS_T_commands>())).failed as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_VC_STATS_T_commands),
            "::",
            stringify!(failed)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_VC_STATS_T_commands>())).replies as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_VC_STATS_T_commands),
            "::",
            stringify!(replies)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_VC_STATS_T_commands>())).reply_fails as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_VC_STATS_T_commands),
            "::",
            stringify!(reply_fails)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_VC_STATS_T__bindgen_ty_2 {
    #[doc = "< Count of events sent"]
    pub tx: u32,
    #[doc = "< Count of events not fully sent"]
    pub tx_fails: u32,
}
#[test]
fn bindgen_test_layout_MMAL_VC_STATS_T__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<MMAL_VC_STATS_T__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(MMAL_VC_STATS_T__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_VC_STATS_T__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_VC_STATS_T__bindgen_ty_2))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_VC_STATS_T__bindgen_ty_2>())).tx as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_VC_STATS_T__bindgen_ty_2),
            "::",
            stringify!(tx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_VC_STATS_T__bindgen_ty_2>())).tx_fails as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_VC_STATS_T__bindgen_ty_2),
            "::",
            stringify!(tx_fails)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_VC_STATS_T__bindgen_ty_3 {
    pub created: u32,
    pub destroyed: u32,
    pub destroying: u32,
    pub failed: u32,
    pub list_size: u32,
    pub component_list: [MMAL_VC_COMP_STATS_T; 8usize],
}
#[test]
fn bindgen_test_layout_MMAL_VC_STATS_T__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<MMAL_VC_STATS_T__bindgen_ty_3>(),
        308usize,
        concat!("Size of: ", stringify!(MMAL_VC_STATS_T__bindgen_ty_3))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_VC_STATS_T__bindgen_ty_3>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_VC_STATS_T__bindgen_ty_3))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_VC_STATS_T__bindgen_ty_3>())).created as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_VC_STATS_T__bindgen_ty_3),
            "::",
            stringify!(created)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_VC_STATS_T__bindgen_ty_3>())).destroyed as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_VC_STATS_T__bindgen_ty_3),
            "::",
            stringify!(destroyed)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_VC_STATS_T__bindgen_ty_3>())).destroying as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_VC_STATS_T__bindgen_ty_3),
            "::",
            stringify!(destroying)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_VC_STATS_T__bindgen_ty_3>())).failed as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_VC_STATS_T__bindgen_ty_3),
            "::",
            stringify!(failed)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_VC_STATS_T__bindgen_ty_3>())).list_size as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_VC_STATS_T__bindgen_ty_3),
            "::",
            stringify!(list_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_VC_STATS_T__bindgen_ty_3>())).component_list as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_VC_STATS_T__bindgen_ty_3),
            "::",
            stringify!(component_list)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_VC_STATS_T__bindgen_ty_4 {
    pub enqueued_messages: u32,
    pub dequeued_messages: u32,
    pub max_parameter_set_delay: u32,
    pub max_messages_waiting: u32,
}
#[test]
fn bindgen_test_layout_MMAL_VC_STATS_T__bindgen_ty_4() {
    assert_eq!(
        ::std::mem::size_of::<MMAL_VC_STATS_T__bindgen_ty_4>(),
        16usize,
        concat!("Size of: ", stringify!(MMAL_VC_STATS_T__bindgen_ty_4))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_VC_STATS_T__bindgen_ty_4>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_VC_STATS_T__bindgen_ty_4))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_VC_STATS_T__bindgen_ty_4>())).enqueued_messages as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_VC_STATS_T__bindgen_ty_4),
            "::",
            stringify!(enqueued_messages)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_VC_STATS_T__bindgen_ty_4>())).dequeued_messages as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_VC_STATS_T__bindgen_ty_4),
            "::",
            stringify!(dequeued_messages)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_VC_STATS_T__bindgen_ty_4>())).max_parameter_set_delay
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_VC_STATS_T__bindgen_ty_4),
            "::",
            stringify!(max_parameter_set_delay)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMAL_VC_STATS_T__bindgen_ty_4>())).max_messages_waiting
                as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_VC_STATS_T__bindgen_ty_4),
            "::",
            stringify!(max_messages_waiting)
        )
    );
}
#[test]
fn bindgen_test_layout_MMAL_VC_STATS_T() {
    assert_eq!(
        ::std::mem::size_of::<MMAL_VC_STATS_T>(),
        408usize,
        concat!("Size of: ", stringify!(MMAL_VC_STATS_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_VC_STATS_T>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_VC_STATS_T))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_VC_STATS_T>())).buffers as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_VC_STATS_T),
            "::",
            stringify!(buffers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_VC_STATS_T>())).service as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_VC_STATS_T),
            "::",
            stringify!(service)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_VC_STATS_T>())).commands as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_VC_STATS_T),
            "::",
            stringify!(commands)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_VC_STATS_T>())).events as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_VC_STATS_T),
            "::",
            stringify!(events)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_VC_STATS_T>())).components as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_VC_STATS_T),
            "::",
            stringify!(components)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_VC_STATS_T>())).worker as *const _ as usize },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_VC_STATS_T),
            "::",
            stringify!(worker)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct MMAL_VC_HOST_LOG_T {
    #[doc = " Simple circular buffer of plain text log messages separated by NUL"]
    pub buffer: [::std::os::raw::c_char; 16384usize],
    #[doc = " For VCDBG validation and to help detect buffer overflow"]
    pub magic: u32,
    #[doc = " Write offset into buffer"]
    pub offset: i32,
    #[doc = " Counter of host messages logged since boot"]
    pub count: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_MMAL_VC_HOST_LOG_T() {
    assert_eq!(
        ::std::mem::size_of::<MMAL_VC_HOST_LOG_T>(),
        16396usize,
        concat!("Size of: ", stringify!(MMAL_VC_HOST_LOG_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_VC_HOST_LOG_T>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_VC_HOST_LOG_T))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_VC_HOST_LOG_T>())).buffer as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_VC_HOST_LOG_T),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_VC_HOST_LOG_T>())).magic as *const _ as usize },
        16384usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_VC_HOST_LOG_T),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_VC_HOST_LOG_T>())).offset as *const _ as usize },
        16388usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_VC_HOST_LOG_T),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMAL_VC_HOST_LOG_T>())).count as *const _ as usize },
        16392usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_VC_HOST_LOG_T),
            "::",
            stringify!(count)
        )
    );
}
impl ::std::fmt::Debug for MMAL_VC_HOST_LOG_T {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "MMAL_VC_HOST_LOG_T {{ buffer: [{}], magic: {:?}, offset: {:?}, count: {:?} }}",
            self.buffer
                .iter()
                .enumerate()
                .map(|(i, v)| format!("{}{:?}", if i > 0 { ", " } else { "" }, v))
                .collect::<String>(),
            self.magic,
            self.offset,
            self.count
        )
    }
}
pub const MMAL_STATS_RESULT_T_MMAL_STATS_FOUND: MMAL_STATS_RESULT_T = 0;
pub const MMAL_STATS_RESULT_T_MMAL_STATS_COMPONENT_NOT_FOUND: MMAL_STATS_RESULT_T = 1;
pub const MMAL_STATS_RESULT_T_MMAL_STATS_PORT_NOT_FOUND: MMAL_STATS_RESULT_T = 2;
pub const MMAL_STATS_RESULT_T_MMAL_STATS_INVALID: MMAL_STATS_RESULT_T = 2147483647;
#[doc = " Status from querying MMAL core statistics."]
pub type MMAL_STATS_RESULT_T = u32;
extern "C" {
    pub fn mmal_vc_init() -> MMAL_STATUS_T::Type;
}
extern "C" {
    pub fn mmal_vc_init_fd(dev_vchiq_fd: ::std::os::raw::c_int) -> MMAL_STATUS_T::Type;
}
extern "C" {
    pub fn mmal_vc_deinit();
}
extern "C" {
    pub fn mmal_vc_use() -> MMAL_STATUS_T::Type;
}
extern "C" {
    pub fn mmal_vc_release() -> MMAL_STATUS_T::Type;
}
extern "C" {
    pub fn mmal_vc_get_version(
        major: *mut u32,
        minor: *mut u32,
        minimum: *mut u32,
    ) -> MMAL_STATUS_T::Type;
}
extern "C" {
    pub fn mmal_vc_get_stats(
        stats: *mut MMAL_VC_STATS_T,
        reset: ::std::os::raw::c_int,
    ) -> MMAL_STATUS_T::Type;
}
extern "C" {
    #[doc = " Return the MMAL core statistics for a given component/port."]
    #[doc = ""]
    #[doc = " @param stats         Updated with given port statistics"]
    #[doc = " @param result        Whether the port/component was found"]
    #[doc = " @param name          Filled in with the name of the port"]
    #[doc = " @param namelen       Length of name"]
    #[doc = " @param component     Which component (indexed from zero)"]
    #[doc = " @param port_type     Which type of port"]
    #[doc = " @param port          Which port (index from zero)"]
    #[doc = " @param reset         Reset the stats."]
    pub fn mmal_vc_get_core_stats(
        stats: *mut MMAL_CORE_STATISTICS_T,
        result: *mut MMAL_STATS_RESULT_T,
        name: *mut ::std::os::raw::c_char,
        namelen: usize,
        type_: MMAL_PORT_TYPE_T,
        component: ::std::os::raw::c_uint,
        port: ::std::os::raw::c_uint,
        dir: MMAL_CORE_STATS_DIR,
        reset: MMAL_BOOL_T,
    ) -> MMAL_STATUS_T::Type;
}
extern "C" {
    #[doc = " Stores an arbitrary text message in a circular buffer inside the MMAL VC server."]
    #[doc = " The purpose of this message is to log high level events from the host in order"]
    #[doc = " to diagnose problems that require multiple actions to reproduce. e.g. taking"]
    #[doc = " multiple pictures with different settings."]
    #[doc = ""]
    #[doc = " @param   msg  The message text."]
    #[doc = " @return  MMAL_SUCCESS if the message was logged or MMAL_ENOSYS if the API"]
    #[doc = "          if not supported."]
    pub fn mmal_vc_host_log(msg: *const ::std::os::raw::c_char) -> MMAL_STATUS_T::Type;
}
extern "C" {
    #[doc = " Consumes memory in the relocatable heap."]
    #[doc = ""]
    #[doc = " The existing reserved memory is freed first then the new chunk is allocated."]
    #[doc = " If zero is specified for the size then the previously reserved memory"]
    #[doc = " is freed and no allocation occurs."]
    #[doc = ""]
    #[doc = " At startup no memory is reserved."]
    #[doc = ""]
    #[doc = " @param size    Size of memory to consume in bytes."]
    #[doc = " @param handle  Set to the mem handle for the reserved memory or zero"]
    #[doc = "                if no memory was allocated."]
    #[doc = " @return        MMAL_SUCCESS if memory was reserved (or size zero requested),"]
    #[doc = "                MMAL_ENOSPC if the allocation failed or MMAL_ENOSYS if the"]
    #[doc = "                API is not supported e.g in release mode VC images."]
    #[doc = " @internal"]
    pub fn mmal_vc_consume_mem(size: usize, handle: *mut u32) -> MMAL_STATUS_T::Type;
}
pub const MMAL_VC_COMPACT_MODE_T_MMAL_VC_COMPACT_NONE: MMAL_VC_COMPACT_MODE_T = 0;
pub const MMAL_VC_COMPACT_MODE_T_MMAL_VC_COMPACT_NORMAL: MMAL_VC_COMPACT_MODE_T = 1;
pub const MMAL_VC_COMPACT_MODE_T_MMAL_VC_COMPACT_DISCARD: MMAL_VC_COMPACT_MODE_T = 2;
pub const MMAL_VC_COMPACT_MODE_T_MMAL_VC_COMPACT_AGGRESSIVE: MMAL_VC_COMPACT_MODE_T = 4;
pub const MMAL_VC_COMPACT_MODE_T_MMAL_VC_COMPACT_SHUFFLE: MMAL_VC_COMPACT_MODE_T = 128;
pub const MMAL_VC_COMPACT_MODE_T_MMAL_VC_COMPACT_ALL: MMAL_VC_COMPACT_MODE_T = 7;
pub type MMAL_VC_COMPACT_MODE_T = u32;
extern "C" {
    #[doc = " Trigger relocatable heap compaction."]
    #[doc = " @internal"]
    pub fn mmal_vc_compact(mode: MMAL_VC_COMPACT_MODE_T, duration: *mut u32)
        -> MMAL_STATUS_T::Type;
}
extern "C" {
    #[doc = " Trigger LMK action from VC, for diagnostics."]
    #[doc = " @internal"]
    pub fn mmal_vc_lmk(alloc_size: u32) -> MMAL_STATUS_T::Type;
}
#[doc = "< There are 'n' named semaphores per 1 actual semaphore"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VCOS_NAMED_SEMAPHORE_IMPL_T {
    pub _address: u8,
}
pub type __builtin_va_list = __va_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list {
    pub __ap: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list() {
    assert_eq!(
        ::std::mem::size_of::<__va_list>(),
        4usize,
        concat!("Size of: ", stringify!(__va_list))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list>(),
        4usize,
        concat!("Alignment of ", stringify!(__va_list))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list>())).__ap as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list),
            "::",
            stringify!(__ap)
        )
    );
}
#[doc = "< Data private to the framework"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_BUFFER_HEADER_PRIVATE_T {
    pub _address: u8,
}
#[doc = "< Private member used by the framework"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PORT_PRIVATE_T {
    pub _address: u8,
}
#[doc = "< Field reserved for use by the client"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PORT_USERDATA_T {
    pub _address: u8,
}
#[doc = " Pointer to private data of the client"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_COMPONENT_USERDATA_T {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_DRIVER_COMPONENT_T {
    pub _address: u8,
}
